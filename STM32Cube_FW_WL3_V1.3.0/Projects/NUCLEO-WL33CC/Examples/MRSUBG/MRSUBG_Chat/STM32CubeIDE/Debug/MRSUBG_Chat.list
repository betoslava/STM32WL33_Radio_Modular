
MRSUBG_Chat.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .intvec       000000c0  10040000  10040000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00005698  100400c0  100400c0  000010c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .init         00000004  10045758  10045758  00006758  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .fini         00000004  1004575c  1004575c  0000675c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .ARM.exidx    00000008  10045760  10045760  00006760  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .data         00000070  20000684  10045768  00007684  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .ram_preamble 0000002c  20000004  10045768  00007004  2**2
                  ALLOC
  7 .bss          00000650  20000034  20000034  00008034  2**2
                  ALLOC
  8 .noinit       00000000  200006f4  100457d8  00000000  2**0
                  ALLOC
  9 .heap         00000000  200006f4  200006f4  000076f4  2**0
                  CONTENTS
 10 CSTACK        00000c00  20007400  20007400  00008400  2**0
                  ALLOC
 11 .rom_info     00000000  10000000  10000000  000076f4  2**0
                  CONTENTS
 12 .ARM.attributes 00000028  00000000  00000000  000076f4  2**0
                  CONTENTS, READONLY
 13 .debug_line   0000e4f1  00000000  00000000  0000771c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_line_str 000000a7  00000000  00000000  00015c0d  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_info   0000dcd9  00000000  00000000  00015cb4  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_abbrev 000023ad  00000000  00000000  0002398d  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_aranges 00000d18  00000000  00000000  00025d40  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_str    000d45a4  00000000  00000000  00026a58  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_rnglists 000009f7  00000000  00000000  000faffc  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_macro  0001e8a3  00000000  00000000  000fb9f3  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .comment      00000043  00000000  00000000  0011a296  2**0
                  CONTENTS, READONLY
 22 .debug_frame  000036e8  00000000  00000000  0011a2dc  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

100400c0 <__gnu_thumb1_case_shi>:
100400c0:	b403      	push	{r0, r1}
100400c2:	4671      	mov	r1, lr
100400c4:	0849      	lsrs	r1, r1, #1
100400c6:	0040      	lsls	r0, r0, #1
100400c8:	0049      	lsls	r1, r1, #1
100400ca:	5e09      	ldrsh	r1, [r1, r0]
100400cc:	0049      	lsls	r1, r1, #1
100400ce:	448e      	add	lr, r1
100400d0:	bc03      	pop	{r0, r1}
100400d2:	4770      	bx	lr

100400d4 <__udivsi3>:
100400d4:	2200      	movs	r2, #0
100400d6:	0843      	lsrs	r3, r0, #1
100400d8:	428b      	cmp	r3, r1
100400da:	d374      	bcc.n	100401c6 <__udivsi3+0xf2>
100400dc:	0903      	lsrs	r3, r0, #4
100400de:	428b      	cmp	r3, r1
100400e0:	d35f      	bcc.n	100401a2 <__udivsi3+0xce>
100400e2:	0a03      	lsrs	r3, r0, #8
100400e4:	428b      	cmp	r3, r1
100400e6:	d344      	bcc.n	10040172 <__udivsi3+0x9e>
100400e8:	0b03      	lsrs	r3, r0, #12
100400ea:	428b      	cmp	r3, r1
100400ec:	d328      	bcc.n	10040140 <__udivsi3+0x6c>
100400ee:	0c03      	lsrs	r3, r0, #16
100400f0:	428b      	cmp	r3, r1
100400f2:	d30d      	bcc.n	10040110 <__udivsi3+0x3c>
100400f4:	22ff      	movs	r2, #255	@ 0xff
100400f6:	0209      	lsls	r1, r1, #8
100400f8:	ba12      	rev	r2, r2
100400fa:	0c03      	lsrs	r3, r0, #16
100400fc:	428b      	cmp	r3, r1
100400fe:	d302      	bcc.n	10040106 <__udivsi3+0x32>
10040100:	1212      	asrs	r2, r2, #8
10040102:	0209      	lsls	r1, r1, #8
10040104:	d065      	beq.n	100401d2 <__udivsi3+0xfe>
10040106:	0b03      	lsrs	r3, r0, #12
10040108:	428b      	cmp	r3, r1
1004010a:	d319      	bcc.n	10040140 <__udivsi3+0x6c>
1004010c:	e000      	b.n	10040110 <__udivsi3+0x3c>
1004010e:	0a09      	lsrs	r1, r1, #8
10040110:	0bc3      	lsrs	r3, r0, #15
10040112:	428b      	cmp	r3, r1
10040114:	d301      	bcc.n	1004011a <__udivsi3+0x46>
10040116:	03cb      	lsls	r3, r1, #15
10040118:	1ac0      	subs	r0, r0, r3
1004011a:	4152      	adcs	r2, r2
1004011c:	0b83      	lsrs	r3, r0, #14
1004011e:	428b      	cmp	r3, r1
10040120:	d301      	bcc.n	10040126 <__udivsi3+0x52>
10040122:	038b      	lsls	r3, r1, #14
10040124:	1ac0      	subs	r0, r0, r3
10040126:	4152      	adcs	r2, r2
10040128:	0b43      	lsrs	r3, r0, #13
1004012a:	428b      	cmp	r3, r1
1004012c:	d301      	bcc.n	10040132 <__udivsi3+0x5e>
1004012e:	034b      	lsls	r3, r1, #13
10040130:	1ac0      	subs	r0, r0, r3
10040132:	4152      	adcs	r2, r2
10040134:	0b03      	lsrs	r3, r0, #12
10040136:	428b      	cmp	r3, r1
10040138:	d301      	bcc.n	1004013e <__udivsi3+0x6a>
1004013a:	030b      	lsls	r3, r1, #12
1004013c:	1ac0      	subs	r0, r0, r3
1004013e:	4152      	adcs	r2, r2
10040140:	0ac3      	lsrs	r3, r0, #11
10040142:	428b      	cmp	r3, r1
10040144:	d301      	bcc.n	1004014a <__udivsi3+0x76>
10040146:	02cb      	lsls	r3, r1, #11
10040148:	1ac0      	subs	r0, r0, r3
1004014a:	4152      	adcs	r2, r2
1004014c:	0a83      	lsrs	r3, r0, #10
1004014e:	428b      	cmp	r3, r1
10040150:	d301      	bcc.n	10040156 <__udivsi3+0x82>
10040152:	028b      	lsls	r3, r1, #10
10040154:	1ac0      	subs	r0, r0, r3
10040156:	4152      	adcs	r2, r2
10040158:	0a43      	lsrs	r3, r0, #9
1004015a:	428b      	cmp	r3, r1
1004015c:	d301      	bcc.n	10040162 <__udivsi3+0x8e>
1004015e:	024b      	lsls	r3, r1, #9
10040160:	1ac0      	subs	r0, r0, r3
10040162:	4152      	adcs	r2, r2
10040164:	0a03      	lsrs	r3, r0, #8
10040166:	428b      	cmp	r3, r1
10040168:	d301      	bcc.n	1004016e <__udivsi3+0x9a>
1004016a:	020b      	lsls	r3, r1, #8
1004016c:	1ac0      	subs	r0, r0, r3
1004016e:	4152      	adcs	r2, r2
10040170:	d2cd      	bcs.n	1004010e <__udivsi3+0x3a>
10040172:	09c3      	lsrs	r3, r0, #7
10040174:	428b      	cmp	r3, r1
10040176:	d301      	bcc.n	1004017c <__udivsi3+0xa8>
10040178:	01cb      	lsls	r3, r1, #7
1004017a:	1ac0      	subs	r0, r0, r3
1004017c:	4152      	adcs	r2, r2
1004017e:	0983      	lsrs	r3, r0, #6
10040180:	428b      	cmp	r3, r1
10040182:	d301      	bcc.n	10040188 <__udivsi3+0xb4>
10040184:	018b      	lsls	r3, r1, #6
10040186:	1ac0      	subs	r0, r0, r3
10040188:	4152      	adcs	r2, r2
1004018a:	0943      	lsrs	r3, r0, #5
1004018c:	428b      	cmp	r3, r1
1004018e:	d301      	bcc.n	10040194 <__udivsi3+0xc0>
10040190:	014b      	lsls	r3, r1, #5
10040192:	1ac0      	subs	r0, r0, r3
10040194:	4152      	adcs	r2, r2
10040196:	0903      	lsrs	r3, r0, #4
10040198:	428b      	cmp	r3, r1
1004019a:	d301      	bcc.n	100401a0 <__udivsi3+0xcc>
1004019c:	010b      	lsls	r3, r1, #4
1004019e:	1ac0      	subs	r0, r0, r3
100401a0:	4152      	adcs	r2, r2
100401a2:	08c3      	lsrs	r3, r0, #3
100401a4:	428b      	cmp	r3, r1
100401a6:	d301      	bcc.n	100401ac <__udivsi3+0xd8>
100401a8:	00cb      	lsls	r3, r1, #3
100401aa:	1ac0      	subs	r0, r0, r3
100401ac:	4152      	adcs	r2, r2
100401ae:	0883      	lsrs	r3, r0, #2
100401b0:	428b      	cmp	r3, r1
100401b2:	d301      	bcc.n	100401b8 <__udivsi3+0xe4>
100401b4:	008b      	lsls	r3, r1, #2
100401b6:	1ac0      	subs	r0, r0, r3
100401b8:	4152      	adcs	r2, r2
100401ba:	0843      	lsrs	r3, r0, #1
100401bc:	428b      	cmp	r3, r1
100401be:	d301      	bcc.n	100401c4 <__udivsi3+0xf0>
100401c0:	004b      	lsls	r3, r1, #1
100401c2:	1ac0      	subs	r0, r0, r3
100401c4:	4152      	adcs	r2, r2
100401c6:	1a41      	subs	r1, r0, r1
100401c8:	d200      	bcs.n	100401cc <__udivsi3+0xf8>
100401ca:	4601      	mov	r1, r0
100401cc:	4152      	adcs	r2, r2
100401ce:	4610      	mov	r0, r2
100401d0:	4770      	bx	lr
100401d2:	e7ff      	b.n	100401d4 <__udivsi3+0x100>
100401d4:	b501      	push	{r0, lr}
100401d6:	2000      	movs	r0, #0
100401d8:	f000 f8f0 	bl	100403bc <__aeabi_idiv0>
100401dc:	bd02      	pop	{r1, pc}
100401de:	46c0      	nop			@ (mov r8, r8)

100401e0 <__aeabi_uidivmod>:
100401e0:	2900      	cmp	r1, #0
100401e2:	d0f7      	beq.n	100401d4 <__udivsi3+0x100>
100401e4:	e776      	b.n	100400d4 <__udivsi3>
100401e6:	4770      	bx	lr

100401e8 <__divsi3>:
100401e8:	4603      	mov	r3, r0
100401ea:	430b      	orrs	r3, r1
100401ec:	d47f      	bmi.n	100402ee <__divsi3+0x106>
100401ee:	2200      	movs	r2, #0
100401f0:	0843      	lsrs	r3, r0, #1
100401f2:	428b      	cmp	r3, r1
100401f4:	d374      	bcc.n	100402e0 <__divsi3+0xf8>
100401f6:	0903      	lsrs	r3, r0, #4
100401f8:	428b      	cmp	r3, r1
100401fa:	d35f      	bcc.n	100402bc <__divsi3+0xd4>
100401fc:	0a03      	lsrs	r3, r0, #8
100401fe:	428b      	cmp	r3, r1
10040200:	d344      	bcc.n	1004028c <__divsi3+0xa4>
10040202:	0b03      	lsrs	r3, r0, #12
10040204:	428b      	cmp	r3, r1
10040206:	d328      	bcc.n	1004025a <__divsi3+0x72>
10040208:	0c03      	lsrs	r3, r0, #16
1004020a:	428b      	cmp	r3, r1
1004020c:	d30d      	bcc.n	1004022a <__divsi3+0x42>
1004020e:	22ff      	movs	r2, #255	@ 0xff
10040210:	0209      	lsls	r1, r1, #8
10040212:	ba12      	rev	r2, r2
10040214:	0c03      	lsrs	r3, r0, #16
10040216:	428b      	cmp	r3, r1
10040218:	d302      	bcc.n	10040220 <__divsi3+0x38>
1004021a:	1212      	asrs	r2, r2, #8
1004021c:	0209      	lsls	r1, r1, #8
1004021e:	d065      	beq.n	100402ec <__divsi3+0x104>
10040220:	0b03      	lsrs	r3, r0, #12
10040222:	428b      	cmp	r3, r1
10040224:	d319      	bcc.n	1004025a <__divsi3+0x72>
10040226:	e000      	b.n	1004022a <__divsi3+0x42>
10040228:	0a09      	lsrs	r1, r1, #8
1004022a:	0bc3      	lsrs	r3, r0, #15
1004022c:	428b      	cmp	r3, r1
1004022e:	d301      	bcc.n	10040234 <__divsi3+0x4c>
10040230:	03cb      	lsls	r3, r1, #15
10040232:	1ac0      	subs	r0, r0, r3
10040234:	4152      	adcs	r2, r2
10040236:	0b83      	lsrs	r3, r0, #14
10040238:	428b      	cmp	r3, r1
1004023a:	d301      	bcc.n	10040240 <__divsi3+0x58>
1004023c:	038b      	lsls	r3, r1, #14
1004023e:	1ac0      	subs	r0, r0, r3
10040240:	4152      	adcs	r2, r2
10040242:	0b43      	lsrs	r3, r0, #13
10040244:	428b      	cmp	r3, r1
10040246:	d301      	bcc.n	1004024c <__divsi3+0x64>
10040248:	034b      	lsls	r3, r1, #13
1004024a:	1ac0      	subs	r0, r0, r3
1004024c:	4152      	adcs	r2, r2
1004024e:	0b03      	lsrs	r3, r0, #12
10040250:	428b      	cmp	r3, r1
10040252:	d301      	bcc.n	10040258 <__divsi3+0x70>
10040254:	030b      	lsls	r3, r1, #12
10040256:	1ac0      	subs	r0, r0, r3
10040258:	4152      	adcs	r2, r2
1004025a:	0ac3      	lsrs	r3, r0, #11
1004025c:	428b      	cmp	r3, r1
1004025e:	d301      	bcc.n	10040264 <__divsi3+0x7c>
10040260:	02cb      	lsls	r3, r1, #11
10040262:	1ac0      	subs	r0, r0, r3
10040264:	4152      	adcs	r2, r2
10040266:	0a83      	lsrs	r3, r0, #10
10040268:	428b      	cmp	r3, r1
1004026a:	d301      	bcc.n	10040270 <__divsi3+0x88>
1004026c:	028b      	lsls	r3, r1, #10
1004026e:	1ac0      	subs	r0, r0, r3
10040270:	4152      	adcs	r2, r2
10040272:	0a43      	lsrs	r3, r0, #9
10040274:	428b      	cmp	r3, r1
10040276:	d301      	bcc.n	1004027c <__divsi3+0x94>
10040278:	024b      	lsls	r3, r1, #9
1004027a:	1ac0      	subs	r0, r0, r3
1004027c:	4152      	adcs	r2, r2
1004027e:	0a03      	lsrs	r3, r0, #8
10040280:	428b      	cmp	r3, r1
10040282:	d301      	bcc.n	10040288 <__divsi3+0xa0>
10040284:	020b      	lsls	r3, r1, #8
10040286:	1ac0      	subs	r0, r0, r3
10040288:	4152      	adcs	r2, r2
1004028a:	d2cd      	bcs.n	10040228 <__divsi3+0x40>
1004028c:	09c3      	lsrs	r3, r0, #7
1004028e:	428b      	cmp	r3, r1
10040290:	d301      	bcc.n	10040296 <__divsi3+0xae>
10040292:	01cb      	lsls	r3, r1, #7
10040294:	1ac0      	subs	r0, r0, r3
10040296:	4152      	adcs	r2, r2
10040298:	0983      	lsrs	r3, r0, #6
1004029a:	428b      	cmp	r3, r1
1004029c:	d301      	bcc.n	100402a2 <__divsi3+0xba>
1004029e:	018b      	lsls	r3, r1, #6
100402a0:	1ac0      	subs	r0, r0, r3
100402a2:	4152      	adcs	r2, r2
100402a4:	0943      	lsrs	r3, r0, #5
100402a6:	428b      	cmp	r3, r1
100402a8:	d301      	bcc.n	100402ae <__divsi3+0xc6>
100402aa:	014b      	lsls	r3, r1, #5
100402ac:	1ac0      	subs	r0, r0, r3
100402ae:	4152      	adcs	r2, r2
100402b0:	0903      	lsrs	r3, r0, #4
100402b2:	428b      	cmp	r3, r1
100402b4:	d301      	bcc.n	100402ba <__divsi3+0xd2>
100402b6:	010b      	lsls	r3, r1, #4
100402b8:	1ac0      	subs	r0, r0, r3
100402ba:	4152      	adcs	r2, r2
100402bc:	08c3      	lsrs	r3, r0, #3
100402be:	428b      	cmp	r3, r1
100402c0:	d301      	bcc.n	100402c6 <__divsi3+0xde>
100402c2:	00cb      	lsls	r3, r1, #3
100402c4:	1ac0      	subs	r0, r0, r3
100402c6:	4152      	adcs	r2, r2
100402c8:	0883      	lsrs	r3, r0, #2
100402ca:	428b      	cmp	r3, r1
100402cc:	d301      	bcc.n	100402d2 <__divsi3+0xea>
100402ce:	008b      	lsls	r3, r1, #2
100402d0:	1ac0      	subs	r0, r0, r3
100402d2:	4152      	adcs	r2, r2
100402d4:	0843      	lsrs	r3, r0, #1
100402d6:	428b      	cmp	r3, r1
100402d8:	d301      	bcc.n	100402de <__divsi3+0xf6>
100402da:	004b      	lsls	r3, r1, #1
100402dc:	1ac0      	subs	r0, r0, r3
100402de:	4152      	adcs	r2, r2
100402e0:	1a41      	subs	r1, r0, r1
100402e2:	d200      	bcs.n	100402e6 <__divsi3+0xfe>
100402e4:	4601      	mov	r1, r0
100402e6:	4152      	adcs	r2, r2
100402e8:	4610      	mov	r0, r2
100402ea:	4770      	bx	lr
100402ec:	e05d      	b.n	100403aa <__divsi3+0x1c2>
100402ee:	0fca      	lsrs	r2, r1, #31
100402f0:	d000      	beq.n	100402f4 <__divsi3+0x10c>
100402f2:	4249      	negs	r1, r1
100402f4:	1003      	asrs	r3, r0, #32
100402f6:	d300      	bcc.n	100402fa <__divsi3+0x112>
100402f8:	4240      	negs	r0, r0
100402fa:	4053      	eors	r3, r2
100402fc:	2200      	movs	r2, #0
100402fe:	469c      	mov	ip, r3
10040300:	0903      	lsrs	r3, r0, #4
10040302:	428b      	cmp	r3, r1
10040304:	d32d      	bcc.n	10040362 <__divsi3+0x17a>
10040306:	0a03      	lsrs	r3, r0, #8
10040308:	428b      	cmp	r3, r1
1004030a:	d312      	bcc.n	10040332 <__divsi3+0x14a>
1004030c:	22fc      	movs	r2, #252	@ 0xfc
1004030e:	0189      	lsls	r1, r1, #6
10040310:	ba12      	rev	r2, r2
10040312:	0a03      	lsrs	r3, r0, #8
10040314:	428b      	cmp	r3, r1
10040316:	d30c      	bcc.n	10040332 <__divsi3+0x14a>
10040318:	0189      	lsls	r1, r1, #6
1004031a:	1192      	asrs	r2, r2, #6
1004031c:	428b      	cmp	r3, r1
1004031e:	d308      	bcc.n	10040332 <__divsi3+0x14a>
10040320:	0189      	lsls	r1, r1, #6
10040322:	1192      	asrs	r2, r2, #6
10040324:	428b      	cmp	r3, r1
10040326:	d304      	bcc.n	10040332 <__divsi3+0x14a>
10040328:	0189      	lsls	r1, r1, #6
1004032a:	d03a      	beq.n	100403a2 <__divsi3+0x1ba>
1004032c:	1192      	asrs	r2, r2, #6
1004032e:	e000      	b.n	10040332 <__divsi3+0x14a>
10040330:	0989      	lsrs	r1, r1, #6
10040332:	09c3      	lsrs	r3, r0, #7
10040334:	428b      	cmp	r3, r1
10040336:	d301      	bcc.n	1004033c <__divsi3+0x154>
10040338:	01cb      	lsls	r3, r1, #7
1004033a:	1ac0      	subs	r0, r0, r3
1004033c:	4152      	adcs	r2, r2
1004033e:	0983      	lsrs	r3, r0, #6
10040340:	428b      	cmp	r3, r1
10040342:	d301      	bcc.n	10040348 <__divsi3+0x160>
10040344:	018b      	lsls	r3, r1, #6
10040346:	1ac0      	subs	r0, r0, r3
10040348:	4152      	adcs	r2, r2
1004034a:	0943      	lsrs	r3, r0, #5
1004034c:	428b      	cmp	r3, r1
1004034e:	d301      	bcc.n	10040354 <__divsi3+0x16c>
10040350:	014b      	lsls	r3, r1, #5
10040352:	1ac0      	subs	r0, r0, r3
10040354:	4152      	adcs	r2, r2
10040356:	0903      	lsrs	r3, r0, #4
10040358:	428b      	cmp	r3, r1
1004035a:	d301      	bcc.n	10040360 <__divsi3+0x178>
1004035c:	010b      	lsls	r3, r1, #4
1004035e:	1ac0      	subs	r0, r0, r3
10040360:	4152      	adcs	r2, r2
10040362:	08c3      	lsrs	r3, r0, #3
10040364:	428b      	cmp	r3, r1
10040366:	d301      	bcc.n	1004036c <__divsi3+0x184>
10040368:	00cb      	lsls	r3, r1, #3
1004036a:	1ac0      	subs	r0, r0, r3
1004036c:	4152      	adcs	r2, r2
1004036e:	0883      	lsrs	r3, r0, #2
10040370:	428b      	cmp	r3, r1
10040372:	d301      	bcc.n	10040378 <__divsi3+0x190>
10040374:	008b      	lsls	r3, r1, #2
10040376:	1ac0      	subs	r0, r0, r3
10040378:	4152      	adcs	r2, r2
1004037a:	d2d9      	bcs.n	10040330 <__divsi3+0x148>
1004037c:	0843      	lsrs	r3, r0, #1
1004037e:	428b      	cmp	r3, r1
10040380:	d301      	bcc.n	10040386 <__divsi3+0x19e>
10040382:	004b      	lsls	r3, r1, #1
10040384:	1ac0      	subs	r0, r0, r3
10040386:	4152      	adcs	r2, r2
10040388:	1a41      	subs	r1, r0, r1
1004038a:	d200      	bcs.n	1004038e <__divsi3+0x1a6>
1004038c:	4601      	mov	r1, r0
1004038e:	4663      	mov	r3, ip
10040390:	4152      	adcs	r2, r2
10040392:	105b      	asrs	r3, r3, #1
10040394:	4610      	mov	r0, r2
10040396:	d301      	bcc.n	1004039c <__divsi3+0x1b4>
10040398:	4240      	negs	r0, r0
1004039a:	2b00      	cmp	r3, #0
1004039c:	d500      	bpl.n	100403a0 <__divsi3+0x1b8>
1004039e:	4249      	negs	r1, r1
100403a0:	4770      	bx	lr
100403a2:	4663      	mov	r3, ip
100403a4:	105b      	asrs	r3, r3, #1
100403a6:	d300      	bcc.n	100403aa <__divsi3+0x1c2>
100403a8:	4240      	negs	r0, r0
100403aa:	b501      	push	{r0, lr}
100403ac:	2000      	movs	r0, #0
100403ae:	f000 f805 	bl	100403bc <__aeabi_idiv0>
100403b2:	bd02      	pop	{r1, pc}

100403b4 <__aeabi_idivmod>:
100403b4:	2900      	cmp	r1, #0
100403b6:	d0f8      	beq.n	100403aa <__divsi3+0x1c2>
100403b8:	e716      	b.n	100401e8 <__divsi3>
100403ba:	4770      	bx	lr

100403bc <__aeabi_idiv0>:
100403bc:	4770      	bx	lr
100403be:	46c0      	nop			@ (mov r8, r8)

100403c0 <__aeabi_uldivmod>:
100403c0:	2b00      	cmp	r3, #0
100403c2:	d111      	bne.n	100403e8 <__aeabi_uldivmod+0x28>
100403c4:	2a00      	cmp	r2, #0
100403c6:	d10f      	bne.n	100403e8 <__aeabi_uldivmod+0x28>
100403c8:	2900      	cmp	r1, #0
100403ca:	d100      	bne.n	100403ce <__aeabi_uldivmod+0xe>
100403cc:	2800      	cmp	r0, #0
100403ce:	d002      	beq.n	100403d6 <__aeabi_uldivmod+0x16>
100403d0:	2100      	movs	r1, #0
100403d2:	43c9      	mvns	r1, r1
100403d4:	0008      	movs	r0, r1
100403d6:	b407      	push	{r0, r1, r2}
100403d8:	4802      	ldr	r0, [pc, #8]	@ (100403e4 <__aeabi_uldivmod+0x24>)
100403da:	a102      	add	r1, pc, #8	@ (adr r1, 100403e4 <__aeabi_uldivmod+0x24>)
100403dc:	1840      	adds	r0, r0, r1
100403de:	9002      	str	r0, [sp, #8]
100403e0:	bd03      	pop	{r0, r1, pc}
100403e2:	46c0      	nop			@ (mov r8, r8)
100403e4:	ffffffd9 	.word	0xffffffd9
100403e8:	b403      	push	{r0, r1}
100403ea:	4668      	mov	r0, sp
100403ec:	b501      	push	{r0, lr}
100403ee:	9802      	ldr	r0, [sp, #8]
100403f0:	f000 f834 	bl	1004045c <__udivmoddi4>
100403f4:	9b01      	ldr	r3, [sp, #4]
100403f6:	469e      	mov	lr, r3
100403f8:	b002      	add	sp, #8
100403fa:	bc0c      	pop	{r2, r3}
100403fc:	4770      	bx	lr
100403fe:	46c0      	nop			@ (mov r8, r8)

10040400 <__aeabi_lmul>:
10040400:	b5f0      	push	{r4, r5, r6, r7, lr}
10040402:	46ce      	mov	lr, r9
10040404:	4699      	mov	r9, r3
10040406:	0c03      	lsrs	r3, r0, #16
10040408:	469c      	mov	ip, r3
1004040a:	0413      	lsls	r3, r2, #16
1004040c:	4647      	mov	r7, r8
1004040e:	0c1b      	lsrs	r3, r3, #16
10040410:	001d      	movs	r5, r3
10040412:	000e      	movs	r6, r1
10040414:	4661      	mov	r1, ip
10040416:	0404      	lsls	r4, r0, #16
10040418:	0c24      	lsrs	r4, r4, #16
1004041a:	b580      	push	{r7, lr}
1004041c:	0007      	movs	r7, r0
1004041e:	0c10      	lsrs	r0, r2, #16
10040420:	434b      	muls	r3, r1
10040422:	4365      	muls	r5, r4
10040424:	4341      	muls	r1, r0
10040426:	4360      	muls	r0, r4
10040428:	0c2c      	lsrs	r4, r5, #16
1004042a:	18c0      	adds	r0, r0, r3
1004042c:	1824      	adds	r4, r4, r0
1004042e:	468c      	mov	ip, r1
10040430:	42a3      	cmp	r3, r4
10040432:	d903      	bls.n	1004043c <__aeabi_lmul+0x3c>
10040434:	2380      	movs	r3, #128	@ 0x80
10040436:	025b      	lsls	r3, r3, #9
10040438:	4698      	mov	r8, r3
1004043a:	44c4      	add	ip, r8
1004043c:	4649      	mov	r1, r9
1004043e:	4379      	muls	r1, r7
10040440:	4356      	muls	r6, r2
10040442:	0c23      	lsrs	r3, r4, #16
10040444:	042d      	lsls	r5, r5, #16
10040446:	0c2d      	lsrs	r5, r5, #16
10040448:	1989      	adds	r1, r1, r6
1004044a:	4463      	add	r3, ip
1004044c:	0424      	lsls	r4, r4, #16
1004044e:	1960      	adds	r0, r4, r5
10040450:	18c9      	adds	r1, r1, r3
10040452:	bcc0      	pop	{r6, r7}
10040454:	46b9      	mov	r9, r7
10040456:	46b0      	mov	r8, r6
10040458:	bdf0      	pop	{r4, r5, r6, r7, pc}
1004045a:	46c0      	nop			@ (mov r8, r8)

1004045c <__udivmoddi4>:
1004045c:	b5f0      	push	{r4, r5, r6, r7, lr}
1004045e:	4657      	mov	r7, sl
10040460:	464e      	mov	r6, r9
10040462:	4645      	mov	r5, r8
10040464:	46de      	mov	lr, fp
10040466:	b5e0      	push	{r5, r6, r7, lr}
10040468:	0004      	movs	r4, r0
1004046a:	000d      	movs	r5, r1
1004046c:	4692      	mov	sl, r2
1004046e:	4699      	mov	r9, r3
10040470:	b083      	sub	sp, #12
10040472:	428b      	cmp	r3, r1
10040474:	d830      	bhi.n	100404d8 <__udivmoddi4+0x7c>
10040476:	d02d      	beq.n	100404d4 <__udivmoddi4+0x78>
10040478:	4649      	mov	r1, r9
1004047a:	4650      	mov	r0, sl
1004047c:	f000 f8ba 	bl	100405f4 <__clzdi2>
10040480:	0029      	movs	r1, r5
10040482:	0006      	movs	r6, r0
10040484:	0020      	movs	r0, r4
10040486:	f000 f8b5 	bl	100405f4 <__clzdi2>
1004048a:	1a33      	subs	r3, r6, r0
1004048c:	4698      	mov	r8, r3
1004048e:	3b20      	subs	r3, #32
10040490:	d434      	bmi.n	100404fc <__udivmoddi4+0xa0>
10040492:	469b      	mov	fp, r3
10040494:	4653      	mov	r3, sl
10040496:	465a      	mov	r2, fp
10040498:	4093      	lsls	r3, r2
1004049a:	4642      	mov	r2, r8
1004049c:	001f      	movs	r7, r3
1004049e:	4653      	mov	r3, sl
100404a0:	4093      	lsls	r3, r2
100404a2:	001e      	movs	r6, r3
100404a4:	42af      	cmp	r7, r5
100404a6:	d83b      	bhi.n	10040520 <__udivmoddi4+0xc4>
100404a8:	42af      	cmp	r7, r5
100404aa:	d100      	bne.n	100404ae <__udivmoddi4+0x52>
100404ac:	e079      	b.n	100405a2 <__udivmoddi4+0x146>
100404ae:	465b      	mov	r3, fp
100404b0:	1ba4      	subs	r4, r4, r6
100404b2:	41bd      	sbcs	r5, r7
100404b4:	2b00      	cmp	r3, #0
100404b6:	da00      	bge.n	100404ba <__udivmoddi4+0x5e>
100404b8:	e076      	b.n	100405a8 <__udivmoddi4+0x14c>
100404ba:	2200      	movs	r2, #0
100404bc:	2300      	movs	r3, #0
100404be:	9200      	str	r2, [sp, #0]
100404c0:	9301      	str	r3, [sp, #4]
100404c2:	2301      	movs	r3, #1
100404c4:	465a      	mov	r2, fp
100404c6:	4093      	lsls	r3, r2
100404c8:	9301      	str	r3, [sp, #4]
100404ca:	2301      	movs	r3, #1
100404cc:	4642      	mov	r2, r8
100404ce:	4093      	lsls	r3, r2
100404d0:	9300      	str	r3, [sp, #0]
100404d2:	e029      	b.n	10040528 <__udivmoddi4+0xcc>
100404d4:	4282      	cmp	r2, r0
100404d6:	d9cf      	bls.n	10040478 <__udivmoddi4+0x1c>
100404d8:	2200      	movs	r2, #0
100404da:	2300      	movs	r3, #0
100404dc:	9200      	str	r2, [sp, #0]
100404de:	9301      	str	r3, [sp, #4]
100404e0:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
100404e2:	2b00      	cmp	r3, #0
100404e4:	d001      	beq.n	100404ea <__udivmoddi4+0x8e>
100404e6:	601c      	str	r4, [r3, #0]
100404e8:	605d      	str	r5, [r3, #4]
100404ea:	9800      	ldr	r0, [sp, #0]
100404ec:	9901      	ldr	r1, [sp, #4]
100404ee:	b003      	add	sp, #12
100404f0:	bcf0      	pop	{r4, r5, r6, r7}
100404f2:	46bb      	mov	fp, r7
100404f4:	46b2      	mov	sl, r6
100404f6:	46a9      	mov	r9, r5
100404f8:	46a0      	mov	r8, r4
100404fa:	bdf0      	pop	{r4, r5, r6, r7, pc}
100404fc:	4642      	mov	r2, r8
100404fe:	469b      	mov	fp, r3
10040500:	2320      	movs	r3, #32
10040502:	1a9b      	subs	r3, r3, r2
10040504:	4652      	mov	r2, sl
10040506:	40da      	lsrs	r2, r3
10040508:	4641      	mov	r1, r8
1004050a:	0013      	movs	r3, r2
1004050c:	464a      	mov	r2, r9
1004050e:	408a      	lsls	r2, r1
10040510:	0017      	movs	r7, r2
10040512:	4642      	mov	r2, r8
10040514:	431f      	orrs	r7, r3
10040516:	4653      	mov	r3, sl
10040518:	4093      	lsls	r3, r2
1004051a:	001e      	movs	r6, r3
1004051c:	42af      	cmp	r7, r5
1004051e:	d9c3      	bls.n	100404a8 <__udivmoddi4+0x4c>
10040520:	2200      	movs	r2, #0
10040522:	2300      	movs	r3, #0
10040524:	9200      	str	r2, [sp, #0]
10040526:	9301      	str	r3, [sp, #4]
10040528:	4643      	mov	r3, r8
1004052a:	2b00      	cmp	r3, #0
1004052c:	d0d8      	beq.n	100404e0 <__udivmoddi4+0x84>
1004052e:	07fb      	lsls	r3, r7, #31
10040530:	0872      	lsrs	r2, r6, #1
10040532:	431a      	orrs	r2, r3
10040534:	4646      	mov	r6, r8
10040536:	087b      	lsrs	r3, r7, #1
10040538:	e00e      	b.n	10040558 <__udivmoddi4+0xfc>
1004053a:	42ab      	cmp	r3, r5
1004053c:	d101      	bne.n	10040542 <__udivmoddi4+0xe6>
1004053e:	42a2      	cmp	r2, r4
10040540:	d80c      	bhi.n	1004055c <__udivmoddi4+0x100>
10040542:	1aa4      	subs	r4, r4, r2
10040544:	419d      	sbcs	r5, r3
10040546:	2001      	movs	r0, #1
10040548:	1924      	adds	r4, r4, r4
1004054a:	416d      	adcs	r5, r5
1004054c:	2100      	movs	r1, #0
1004054e:	3e01      	subs	r6, #1
10040550:	1824      	adds	r4, r4, r0
10040552:	414d      	adcs	r5, r1
10040554:	2e00      	cmp	r6, #0
10040556:	d006      	beq.n	10040566 <__udivmoddi4+0x10a>
10040558:	42ab      	cmp	r3, r5
1004055a:	d9ee      	bls.n	1004053a <__udivmoddi4+0xde>
1004055c:	3e01      	subs	r6, #1
1004055e:	1924      	adds	r4, r4, r4
10040560:	416d      	adcs	r5, r5
10040562:	2e00      	cmp	r6, #0
10040564:	d1f8      	bne.n	10040558 <__udivmoddi4+0xfc>
10040566:	9800      	ldr	r0, [sp, #0]
10040568:	9901      	ldr	r1, [sp, #4]
1004056a:	465b      	mov	r3, fp
1004056c:	1900      	adds	r0, r0, r4
1004056e:	4169      	adcs	r1, r5
10040570:	2b00      	cmp	r3, #0
10040572:	db24      	blt.n	100405be <__udivmoddi4+0x162>
10040574:	002b      	movs	r3, r5
10040576:	465a      	mov	r2, fp
10040578:	4644      	mov	r4, r8
1004057a:	40d3      	lsrs	r3, r2
1004057c:	002a      	movs	r2, r5
1004057e:	40e2      	lsrs	r2, r4
10040580:	001c      	movs	r4, r3
10040582:	465b      	mov	r3, fp
10040584:	0015      	movs	r5, r2
10040586:	2b00      	cmp	r3, #0
10040588:	db2a      	blt.n	100405e0 <__udivmoddi4+0x184>
1004058a:	0026      	movs	r6, r4
1004058c:	409e      	lsls	r6, r3
1004058e:	0033      	movs	r3, r6
10040590:	0026      	movs	r6, r4
10040592:	4647      	mov	r7, r8
10040594:	40be      	lsls	r6, r7
10040596:	0032      	movs	r2, r6
10040598:	1a80      	subs	r0, r0, r2
1004059a:	4199      	sbcs	r1, r3
1004059c:	9000      	str	r0, [sp, #0]
1004059e:	9101      	str	r1, [sp, #4]
100405a0:	e79e      	b.n	100404e0 <__udivmoddi4+0x84>
100405a2:	42a3      	cmp	r3, r4
100405a4:	d8bc      	bhi.n	10040520 <__udivmoddi4+0xc4>
100405a6:	e782      	b.n	100404ae <__udivmoddi4+0x52>
100405a8:	4642      	mov	r2, r8
100405aa:	2320      	movs	r3, #32
100405ac:	2100      	movs	r1, #0
100405ae:	1a9b      	subs	r3, r3, r2
100405b0:	2200      	movs	r2, #0
100405b2:	9100      	str	r1, [sp, #0]
100405b4:	9201      	str	r2, [sp, #4]
100405b6:	2201      	movs	r2, #1
100405b8:	40da      	lsrs	r2, r3
100405ba:	9201      	str	r2, [sp, #4]
100405bc:	e785      	b.n	100404ca <__udivmoddi4+0x6e>
100405be:	4642      	mov	r2, r8
100405c0:	2320      	movs	r3, #32
100405c2:	1a9b      	subs	r3, r3, r2
100405c4:	002a      	movs	r2, r5
100405c6:	4646      	mov	r6, r8
100405c8:	409a      	lsls	r2, r3
100405ca:	0023      	movs	r3, r4
100405cc:	40f3      	lsrs	r3, r6
100405ce:	4644      	mov	r4, r8
100405d0:	4313      	orrs	r3, r2
100405d2:	002a      	movs	r2, r5
100405d4:	40e2      	lsrs	r2, r4
100405d6:	001c      	movs	r4, r3
100405d8:	465b      	mov	r3, fp
100405da:	0015      	movs	r5, r2
100405dc:	2b00      	cmp	r3, #0
100405de:	dad4      	bge.n	1004058a <__udivmoddi4+0x12e>
100405e0:	4642      	mov	r2, r8
100405e2:	002f      	movs	r7, r5
100405e4:	2320      	movs	r3, #32
100405e6:	0026      	movs	r6, r4
100405e8:	4097      	lsls	r7, r2
100405ea:	1a9b      	subs	r3, r3, r2
100405ec:	40de      	lsrs	r6, r3
100405ee:	003b      	movs	r3, r7
100405f0:	4333      	orrs	r3, r6
100405f2:	e7cd      	b.n	10040590 <__udivmoddi4+0x134>

100405f4 <__clzdi2>:
100405f4:	b510      	push	{r4, lr}
100405f6:	2900      	cmp	r1, #0
100405f8:	d103      	bne.n	10040602 <__clzdi2+0xe>
100405fa:	f000 f807 	bl	1004060c <__clzsi2>
100405fe:	3020      	adds	r0, #32
10040600:	e002      	b.n	10040608 <__clzdi2+0x14>
10040602:	0008      	movs	r0, r1
10040604:	f000 f802 	bl	1004060c <__clzsi2>
10040608:	bd10      	pop	{r4, pc}
1004060a:	46c0      	nop			@ (mov r8, r8)

1004060c <__clzsi2>:
1004060c:	211c      	movs	r1, #28
1004060e:	2301      	movs	r3, #1
10040610:	041b      	lsls	r3, r3, #16
10040612:	4298      	cmp	r0, r3
10040614:	d301      	bcc.n	1004061a <__clzsi2+0xe>
10040616:	0c00      	lsrs	r0, r0, #16
10040618:	3910      	subs	r1, #16
1004061a:	0a1b      	lsrs	r3, r3, #8
1004061c:	4298      	cmp	r0, r3
1004061e:	d301      	bcc.n	10040624 <__clzsi2+0x18>
10040620:	0a00      	lsrs	r0, r0, #8
10040622:	3908      	subs	r1, #8
10040624:	091b      	lsrs	r3, r3, #4
10040626:	4298      	cmp	r0, r3
10040628:	d301      	bcc.n	1004062e <__clzsi2+0x22>
1004062a:	0900      	lsrs	r0, r0, #4
1004062c:	3904      	subs	r1, #4
1004062e:	a202      	add	r2, pc, #8	@ (adr r2, 10040638 <__clzsi2+0x2c>)
10040630:	5c10      	ldrb	r0, [r2, r0]
10040632:	1840      	adds	r0, r0, r1
10040634:	4770      	bx	lr
10040636:	46c0      	nop			@ (mov r8, r8)
10040638:	02020304 	.word	0x02020304
1004063c:	01010101 	.word	0x01010101
	...

10040648 <Reset_Handler>:

	.section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
   ldr   r0, =_estack
10040648:	480c      	ldr	r0, [pc, #48]	@ (1004067c <LoopForever+0x2>)
   mov   sp, r0          /* set stack pointer */
1004064a:	4685      	mov	sp, r0
/* Call the clock system initialization function.*/
  bl  SystemInit
1004064c:	f000 fe14 	bl	10041278 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  movs  r1, #0
10040650:	2100      	movs	r1, #0
  b  LoopCopyDataInit
10040652:	e003      	b.n	1004065c <LoopCopyDataInit>

10040654 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
10040654:	4b0a      	ldr	r3, [pc, #40]	@ (10040680 <LoopForever+0x6>)
  ldr  r3, [r3, r1]
10040656:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
10040658:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
1004065a:	3104      	adds	r1, #4

1004065c <LoopCopyDataInit>:

LoopCopyDataInit:
  ldr  r0, =_sdata
1004065c:	4809      	ldr	r0, [pc, #36]	@ (10040684 <LoopForever+0xa>)
  ldr  r3, =_edata
1004065e:	4b0a      	ldr	r3, [pc, #40]	@ (10040688 <LoopForever+0xe>)
  adds  r2, r0, r1
10040660:	1842      	adds	r2, r0, r1
  cmp  r2, r3
10040662:	429a      	cmp	r2, r3
  bcc  CopyDataInit
10040664:	d3f6      	bcc.n	10040654 <CopyDataInit>
  ldr  r2, =_sbss
10040666:	4a09      	ldr	r2, [pc, #36]	@ (1004068c <LoopForever+0x12>)
  b  LoopFillZerobss
10040668:	e002      	b.n	10040670 <LoopFillZerobss>

1004066a <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
  movs  r3, #0
1004066a:	2300      	movs	r3, #0
  str  r3, [r2]
1004066c:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
1004066e:	3204      	adds	r2, #4

10040670 <LoopFillZerobss>:


LoopFillZerobss:
  ldr  r3, = _ebss
10040670:	4b07      	ldr	r3, [pc, #28]	@ (10040690 <LoopForever+0x16>)
  cmp  r2, r3
10040672:	429a      	cmp	r2, r3
  bcc  FillZerobss
10040674:	d3f9      	bcc.n	1004066a <FillZerobss>

/* Call the application's entry point.*/
  bl  main
10040676:	f000 f85d 	bl	10040734 <main>

1004067a <LoopForever>:

LoopForever:
    b LoopForever
1004067a:	e7fe      	b.n	1004067a <LoopForever>
   ldr   r0, =_estack
1004067c:	20008000 	.word	0x20008000
  ldr  r3, =_sidata
10040680:	10045768 	.word	0x10045768
  ldr  r0, =_sdata
10040684:	20000684 	.word	0x20000684
  ldr  r3, =_edata
10040688:	200006f4 	.word	0x200006f4
  ldr  r2, =_sbss
1004068c:	20000034 	.word	0x20000034
  ldr  r3, = _ebss
10040690:	20000684 	.word	0x20000684

10040694 <ADC_IRQHandler>:
 * @retval : None
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
10040694:	e7fe      	b.n	10040694 <ADC_IRQHandler>
	...

10040698 <LL_AHB1_GRP1_EnableClock>:
  * @arg LL_AHB1_GRP1_PERIPH_RNG
  * @arg LL_AHB1_GRP1_PERIPH_AES
  * @retval None
  */
__STATIC_INLINE void LL_AHB1_GRP1_EnableClock(uint32_t Periphs)
{
10040698:	b580      	push	{r7, lr}
1004069a:	b084      	sub	sp, #16
1004069c:	af00      	add	r7, sp, #0
1004069e:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  SET_BIT(RCC->AHBENR, Periphs);
100406a0:	4b07      	ldr	r3, [pc, #28]	@ (100406c0 <LL_AHB1_GRP1_EnableClock+0x28>)
100406a2:	6d19      	ldr	r1, [r3, #80]	@ 0x50
100406a4:	4b06      	ldr	r3, [pc, #24]	@ (100406c0 <LL_AHB1_GRP1_EnableClock+0x28>)
100406a6:	687a      	ldr	r2, [r7, #4]
100406a8:	430a      	orrs	r2, r1
100406aa:	651a      	str	r2, [r3, #80]	@ 0x50
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->AHBENR, Periphs);
100406ac:	4b04      	ldr	r3, [pc, #16]	@ (100406c0 <LL_AHB1_GRP1_EnableClock+0x28>)
100406ae:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
100406b0:	687a      	ldr	r2, [r7, #4]
100406b2:	4013      	ands	r3, r2
100406b4:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
100406b6:	68fb      	ldr	r3, [r7, #12]
}
100406b8:	46c0      	nop			@ (mov r8, r8)
100406ba:	46bd      	mov	sp, r7
100406bc:	b004      	add	sp, #16
100406be:	bd80      	pop	{r7, pc}
100406c0:	48400000 	.word	0x48400000

100406c4 <LL_MRSubG_StrobeCommand>:
  * @param  xCommandCode code of the command to send.
           This parameter can be any value of @ref MRSubGCmd.
  * @retval None.
  */
__STATIC_INLINE void LL_MRSubG_StrobeCommand(MRSubGCmd xCommandCode)
{
100406c4:	b580      	push	{r7, lr}
100406c6:	b082      	sub	sp, #8
100406c8:	af00      	add	r7, sp, #0
100406ca:	0002      	movs	r2, r0
100406cc:	1dfb      	adds	r3, r7, #7
100406ce:	701a      	strb	r2, [r3, #0]
  MODIFY_REG_FIELD(MR_SUBG_GLOB_DYNAMIC->COMMAND, MR_SUBG_GLOB_DYNAMIC_COMMAND_COMMAND_ID, xCommandCode);
100406d0:	4b07      	ldr	r3, [pc, #28]	@ (100406f0 <LL_MRSubG_StrobeCommand+0x2c>)
100406d2:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
100406d4:	220f      	movs	r2, #15
100406d6:	4393      	bics	r3, r2
100406d8:	0019      	movs	r1, r3
100406da:	1dfb      	adds	r3, r7, #7
100406dc:	781b      	ldrb	r3, [r3, #0]
100406de:	220f      	movs	r2, #15
100406e0:	401a      	ands	r2, r3
100406e2:	4b03      	ldr	r3, [pc, #12]	@ (100406f0 <LL_MRSubG_StrobeCommand+0x2c>)
100406e4:	430a      	orrs	r2, r1
100406e6:	629a      	str	r2, [r3, #40]	@ 0x28
}
100406e8:	46c0      	nop			@ (mov r8, r8)
100406ea:	46bd      	mov	sp, r7
100406ec:	b002      	add	sp, #8
100406ee:	bd80      	pop	{r7, pc}
100406f0:	49000500 	.word	0x49000500

100406f4 <LL_USART_EnableIT_RXNE_RXFNE>:
  * @rmtoll CR1        RXNEIE_RXFNEIE  LL_USART_EnableIT_RXNE_RXFNE
  * @param  USARTx USART Instance
  * @retval None
  */
__STATIC_INLINE void LL_USART_EnableIT_RXNE_RXFNE(USART_TypeDef *USARTx)
{
100406f4:	b580      	push	{r7, lr}
100406f6:	b086      	sub	sp, #24
100406f8:	af00      	add	r7, sp, #0
100406fa:	6078      	str	r0, [r7, #4]
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
100406fc:	f3ef 8310 	mrs	r3, PRIMASK
10040700:	60bb      	str	r3, [r7, #8]
  return(result);
10040702:	68bb      	ldr	r3, [r7, #8]
  ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_RXNEIE_RXFNEIE);
10040704:	617b      	str	r3, [r7, #20]
10040706:	2301      	movs	r3, #1
10040708:	60fb      	str	r3, [r7, #12]
  \details Assigns the given value to the Priority Mask Register.
  \param [in]    priMask  Priority Mask
 */
__STATIC_FORCEINLINE void __set_PRIMASK(uint32_t priMask)
{
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
1004070a:	68fb      	ldr	r3, [r7, #12]
1004070c:	f383 8810 	msr	PRIMASK, r3
}
10040710:	46c0      	nop			@ (mov r8, r8)
10040712:	687b      	ldr	r3, [r7, #4]
10040714:	681b      	ldr	r3, [r3, #0]
10040716:	2220      	movs	r2, #32
10040718:	431a      	orrs	r2, r3
1004071a:	687b      	ldr	r3, [r7, #4]
1004071c:	601a      	str	r2, [r3, #0]
1004071e:	697b      	ldr	r3, [r7, #20]
10040720:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
10040722:	693b      	ldr	r3, [r7, #16]
10040724:	f383 8810 	msr	PRIMASK, r3
}
10040728:	46c0      	nop			@ (mov r8, r8)
}
1004072a:	46c0      	nop			@ (mov r8, r8)
1004072c:	46bd      	mov	sp, r7
1004072e:	b006      	add	sp, #24
10040730:	bd80      	pop	{r7, pc}
	...

10040734 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
10040734:	b580      	push	{r7, lr}
10040736:	b084      	sub	sp, #16
10040738:	af00      	add	r7, sp, #0
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
1004073a:	f000 fec4 	bl	100414c6 <HAL_Init>
  /* USER CODE BEGIN Init */
  
  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();
1004073e:	f000 f8c9 	bl	100408d4 <SystemClock_Config>

  /* Configure the peripherals common clocks */
  PeriphCommonClock_Config();
10040742:	f000 f8fe 	bl	10040942 <PeriphCommonClock_Config>
  /* USER CODE BEGIN SysInit */
  
  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
10040746:	f000 f973 	bl	10040a30 <MX_GPIO_Init>
  MX_MRSUBG_Init();
1004074a:	f000 f91b 	bl	10040984 <MX_MRSUBG_Init>
  /* USER CODE BEGIN 2 */
  
  COM_InitTypeDef COM_Init;

  COM_Init.BaudRate= 115200;
1004074e:	003b      	movs	r3, r7
10040750:	22e1      	movs	r2, #225	@ 0xe1
10040752:	0252      	lsls	r2, r2, #9
10040754:	601a      	str	r2, [r3, #0]
  COM_Init.HwFlowCtl = COM_HWCONTROL_NONE;
10040756:	003b      	movs	r3, r7
10040758:	2200      	movs	r2, #0
1004075a:	819a      	strh	r2, [r3, #12]
  COM_Init.WordLength = COM_WORDLENGTH_8B;
1004075c:	003b      	movs	r3, r7
1004075e:	2200      	movs	r2, #0
10040760:	605a      	str	r2, [r3, #4]
  COM_Init.Parity = COM_PARITY_NONE;
10040762:	003b      	movs	r3, r7
10040764:	2200      	movs	r2, #0
10040766:	815a      	strh	r2, [r3, #10]
  COM_Init.StopBits = COM_STOPBITS_1;
10040768:	003b      	movs	r3, r7
1004076a:	2200      	movs	r2, #0
1004076c:	811a      	strh	r2, [r3, #8]
  BSP_COM_Init(COM1, &COM_Init);
1004076e:	003b      	movs	r3, r7
10040770:	0019      	movs	r1, r3
10040772:	2000      	movs	r0, #0
10040774:	f000 fc2e 	bl	10040fd4 <BSP_COM_Init>
  
  LL_USART_EnableIT_RXNE(USART1);  
10040778:	4b4b      	ldr	r3, [pc, #300]	@ (100408a8 <main+0x174>)
1004077a:	0018      	movs	r0, r3
1004077c:	f7ff ffba 	bl	100406f4 <LL_USART_EnableIT_RXNE_RXFNE>
  
  HAL_NVIC_SetPriority(USART1_IRQn, 1, 0);
10040780:	2200      	movs	r2, #0
10040782:	2101      	movs	r1, #1
10040784:	2008      	movs	r0, #8
10040786:	f000 ffcf 	bl	10041728 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(USART1_IRQn);
1004078a:	2008      	movs	r0, #8
1004078c:	f000 ffe1 	bl	10041752 <HAL_NVIC_EnableIRQ>
  
#if defined(__GNUC__) && !defined(__ARMCC_VERSION)
  setvbuf(stdout, NULL, _IONBF, 0);
10040790:	4b46      	ldr	r3, [pc, #280]	@ (100408ac <main+0x178>)
10040792:	681b      	ldr	r3, [r3, #0]
10040794:	6898      	ldr	r0, [r3, #8]
10040796:	2300      	movs	r3, #0
10040798:	2202      	movs	r2, #2
1004079a:	2100      	movs	r1, #0
1004079c:	f003 ff78 	bl	10044690 <setvbuf>
#endif  
  
  /* Payload length config */
  HAL_MRSubG_PktBasicSetPayloadLength(MSG_SIZE);
100407a0:	2014      	movs	r0, #20
100407a2:	f002 fbc9 	bl	10042f38 <HAL_MRSubG_PktBasicSetPayloadLength>
  
  /* Init & Enable IRQ */
  __HAL_MRSUBG_SET_RFSEQ_IRQ_ENABLE(MR_SUBG_GLOB_DYNAMIC_RFSEQ_IRQ_ENABLE_RX_OK_E | MR_SUBG_GLOB_DYNAMIC_RFSEQ_IRQ_ENABLE_TX_DONE_E);
100407a6:	4b42      	ldr	r3, [pc, #264]	@ (100408b0 <main+0x17c>)
100407a8:	2203      	movs	r2, #3
100407aa:	61da      	str	r2, [r3, #28]
  
  /* Set the databuffer pointer and put the device in RX mode */
  __HAL_MRSUBG_SET_DATABUFFER0_POINTER((uint32_t)&rx_data);	
100407ac:	4b41      	ldr	r3, [pc, #260]	@ (100408b4 <main+0x180>)
100407ae:	4a42      	ldr	r2, [pc, #264]	@ (100408b8 <main+0x184>)
100407b0:	615a      	str	r2, [r3, #20]
  __HAL_MRSUBG_STROBE_CMD(CMD_RX);  
100407b2:	2002      	movs	r0, #2
100407b4:	f7ff ff86 	bl	100406c4 <LL_MRSubG_StrobeCommand>
  
  printf("STM32WL3 Chat Application.\n\r");
100407b8:	4b40      	ldr	r3, [pc, #256]	@ (100408bc <main+0x188>)
100407ba:	0018      	movs	r0, r3
100407bc:	f003 ff4e 	bl	1004465c <iprintf>
  {
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
    /* While waiting for incoming messages, acquire text from the user */
    tx_data_size = 0;
100407c0:	4b3f      	ldr	r3, [pc, #252]	@ (100408c0 <main+0x18c>)
100407c2:	2200      	movs	r2, #0
100407c4:	701a      	strb	r2, [r3, #0]
    
    while(__io_getcharNonBlocking(&tx_data[tx_data_size]));
100407c6:	46c0      	nop			@ (mov r8, r8)
100407c8:	4b3d      	ldr	r3, [pc, #244]	@ (100408c0 <main+0x18c>)
100407ca:	781b      	ldrb	r3, [r3, #0]
100407cc:	001a      	movs	r2, r3
100407ce:	4b3d      	ldr	r3, [pc, #244]	@ (100408c4 <main+0x190>)
100407d0:	18d3      	adds	r3, r2, r3
100407d2:	0018      	movs	r0, r3
100407d4:	f000 f937 	bl	10040a46 <__io_getcharNonBlocking>
100407d8:	1e03      	subs	r3, r0, #0
100407da:	d1f5      	bne.n	100407c8 <main+0x94>
    
    /* reset the data to be sent */
    tx_data_size=0;
100407dc:	4b38      	ldr	r3, [pc, #224]	@ (100408c0 <main+0x18c>)
100407de:	2200      	movs	r2, #0
100407e0:	701a      	strb	r2, [r3, #0]
    
    printf("tx>");   
100407e2:	4b39      	ldr	r3, [pc, #228]	@ (100408c8 <main+0x194>)
100407e4:	0018      	movs	r0, r3
100407e6:	f003 ff39 	bl	1004465c <iprintf>
    
    do
    {
      while(!__io_getcharNonBlocking(&tx_data[tx_data_size]));
100407ea:	46c0      	nop			@ (mov r8, r8)
100407ec:	4b34      	ldr	r3, [pc, #208]	@ (100408c0 <main+0x18c>)
100407ee:	781b      	ldrb	r3, [r3, #0]
100407f0:	001a      	movs	r2, r3
100407f2:	4b34      	ldr	r3, [pc, #208]	@ (100408c4 <main+0x190>)
100407f4:	18d3      	adds	r3, r2, r3
100407f6:	0018      	movs	r0, r3
100407f8:	f000 f925 	bl	10040a46 <__io_getcharNonBlocking>
100407fc:	1e03      	subs	r3, r0, #0
100407fe:	d0f5      	beq.n	100407ec <main+0xb8>
      
      if((char)tx_data[tx_data_size] != '\r' && (char)tx_data[tx_data_size] != '\n')
10040800:	4b2f      	ldr	r3, [pc, #188]	@ (100408c0 <main+0x18c>)
10040802:	781b      	ldrb	r3, [r3, #0]
10040804:	001a      	movs	r2, r3
10040806:	4b2f      	ldr	r3, [pc, #188]	@ (100408c4 <main+0x190>)
10040808:	5c9b      	ldrb	r3, [r3, r2]
1004080a:	2b0d      	cmp	r3, #13
1004080c:	d019      	beq.n	10040842 <main+0x10e>
1004080e:	4b2c      	ldr	r3, [pc, #176]	@ (100408c0 <main+0x18c>)
10040810:	781b      	ldrb	r3, [r3, #0]
10040812:	001a      	movs	r2, r3
10040814:	4b2b      	ldr	r3, [pc, #172]	@ (100408c4 <main+0x190>)
10040816:	5c9b      	ldrb	r3, [r3, r2]
10040818:	2b0a      	cmp	r3, #10
1004081a:	d012      	beq.n	10040842 <main+0x10e>
      {
        putchar(tx_data[tx_data_size]);
1004081c:	4b28      	ldr	r3, [pc, #160]	@ (100408c0 <main+0x18c>)
1004081e:	781b      	ldrb	r3, [r3, #0]
10040820:	001a      	movs	r2, r3
10040822:	4b28      	ldr	r3, [pc, #160]	@ (100408c4 <main+0x190>)
10040824:	5c9b      	ldrb	r3, [r3, r2]
10040826:	0018      	movs	r0, r3
10040828:	f003 ff28 	bl	1004467c <putchar>
      {
        putchar('\n');
        putchar('\r');
        break;
      }
      tx_data_size++;
1004082c:	4b24      	ldr	r3, [pc, #144]	@ (100408c0 <main+0x18c>)
1004082e:	781b      	ldrb	r3, [r3, #0]
10040830:	3301      	adds	r3, #1
10040832:	b2da      	uxtb	r2, r3
10040834:	4b22      	ldr	r3, [pc, #136]	@ (100408c0 <main+0x18c>)
10040836:	701a      	strb	r2, [r3, #0]
      /* if '\r' has been received */
    }while(tx_data_size != MSG_SIZE);
10040838:	4b21      	ldr	r3, [pc, #132]	@ (100408c0 <main+0x18c>)
1004083a:	781b      	ldrb	r3, [r3, #0]
1004083c:	2b14      	cmp	r3, #20
1004083e:	d1d4      	bne.n	100407ea <main+0xb6>
10040840:	e006      	b.n	10040850 <main+0x11c>
        putchar('\n');
10040842:	200a      	movs	r0, #10
10040844:	f003 ff1a 	bl	1004467c <putchar>
        putchar('\r');
10040848:	200d      	movs	r0, #13
1004084a:	f003 ff17 	bl	1004467c <putchar>
        break;
1004084e:	46c0      	nop			@ (mov r8, r8)
    
    /* payload length config */
    HAL_MRSubG_PktBasicSetPayloadLength(tx_data_size);
10040850:	4b1b      	ldr	r3, [pc, #108]	@ (100408c0 <main+0x18c>)
10040852:	781b      	ldrb	r3, [r3, #0]
10040854:	0018      	movs	r0, r3
10040856:	f002 fb6f 	bl	10042f38 <HAL_MRSubG_PktBasicSetPayloadLength>
    
    __HAL_MRSUBG_STROBE_CMD(CMD_SABORT);
1004085a:	2005      	movs	r0, #5
1004085c:	f7ff ff32 	bl	100406c4 <LL_MRSubG_StrobeCommand>
    
    /* wait for SABORT... */
    while ((__HAL_MRSUBG_GET_RFSEQ_IRQ_STATUS() & MR_SUBG_GLOB_STATUS_RFSEQ_IRQ_STATUS_SABORT_DONE_F) == 0) {};
10040860:	46c0      	nop			@ (mov r8, r8)
10040862:	4b1a      	ldr	r3, [pc, #104]	@ (100408cc <main+0x198>)
10040864:	681a      	ldr	r2, [r3, #0]
10040866:	2380      	movs	r3, #128	@ 0x80
10040868:	005b      	lsls	r3, r3, #1
1004086a:	4013      	ands	r3, r2
1004086c:	d0f9      	beq.n	10040862 <main+0x12e>
    __HAL_MRSUBG_CLEAR_RFSEQ_IRQ_FLAG(MR_SUBG_GLOB_STATUS_RFSEQ_IRQ_STATUS_SABORT_DONE_F);
1004086e:	4b17      	ldr	r3, [pc, #92]	@ (100408cc <main+0x198>)
10040870:	2280      	movs	r2, #128	@ 0x80
10040872:	0052      	lsls	r2, r2, #1
10040874:	601a      	str	r2, [r3, #0]
    
    /* Set the pointer to the data buffer */
    __HAL_MRSUBG_SET_DATABUFFER0_POINTER((uint32_t)&tx_data);
10040876:	4b0f      	ldr	r3, [pc, #60]	@ (100408b4 <main+0x180>)
10040878:	4a12      	ldr	r2, [pc, #72]	@ (100408c4 <main+0x190>)
1004087a:	615a      	str	r2, [r3, #20]
    
    /* Send the TX command */
    __HAL_MRSUBG_STROBE_CMD(CMD_TX);
1004087c:	2001      	movs	r0, #1
1004087e:	f7ff ff21 	bl	100406c4 <LL_MRSubG_StrobeCommand>
    
    /* wait for TX done */
    while(!xTxDoneFlag);
10040882:	46c0      	nop			@ (mov r8, r8)
10040884:	4b12      	ldr	r3, [pc, #72]	@ (100408d0 <main+0x19c>)
10040886:	781b      	ldrb	r3, [r3, #0]
10040888:	b2db      	uxtb	r3, r3
1004088a:	2b00      	cmp	r3, #0
1004088c:	d0fa      	beq.n	10040884 <main+0x150>
    xTxDoneFlag = RESET;
1004088e:	4b10      	ldr	r3, [pc, #64]	@ (100408d0 <main+0x19c>)
10040890:	2200      	movs	r2, #0
10040892:	701a      	strb	r2, [r3, #0]
    
    /* Revert the device to RX */
    HAL_MRSubG_PktBasicSetPayloadLength(MSG_SIZE);
10040894:	2014      	movs	r0, #20
10040896:	f002 fb4f 	bl	10042f38 <HAL_MRSubG_PktBasicSetPayloadLength>
    
    __HAL_MRSUBG_SET_DATABUFFER0_POINTER((uint32_t)&rx_data);
1004089a:	4b06      	ldr	r3, [pc, #24]	@ (100408b4 <main+0x180>)
1004089c:	4a06      	ldr	r2, [pc, #24]	@ (100408b8 <main+0x184>)
1004089e:	615a      	str	r2, [r3, #20]
    __HAL_MRSUBG_STROBE_CMD(CMD_RX); 
100408a0:	2002      	movs	r0, #2
100408a2:	f7ff ff0f 	bl	100406c4 <LL_MRSubG_StrobeCommand>
    tx_data_size = 0;
100408a6:	e78b      	b.n	100407c0 <main+0x8c>
100408a8:	41004000 	.word	0x41004000
100408ac:	200006a4 	.word	0x200006a4
100408b0:	49000500 	.word	0x49000500
100408b4:	49000400 	.word	0x49000400
100408b8:	20000078 	.word	0x20000078
100408bc:	1004554c 	.word	0x1004554c
100408c0:	2000008c 	.word	0x2000008c
100408c4:	20000064 	.word	0x20000064
100408c8:	1004556c 	.word	0x1004556c
100408cc:	49000600 	.word	0x49000600
100408d0:	20000060 	.word	0x20000060

100408d4 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
100408d4:	b590      	push	{r4, r7, lr}
100408d6:	b089      	sub	sp, #36	@ 0x24
100408d8:	af00      	add	r7, sp, #0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
100408da:	2408      	movs	r4, #8
100408dc:	193b      	adds	r3, r7, r4
100408de:	0018      	movs	r0, r3
100408e0:	2318      	movs	r3, #24
100408e2:	001a      	movs	r2, r3
100408e4:	2100      	movs	r1, #0
100408e6:	f003 ffd5 	bl	10044894 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
100408ea:	003b      	movs	r3, r7
100408ec:	0018      	movs	r0, r3
100408ee:	2308      	movs	r3, #8
100408f0:	001a      	movs	r2, r3
100408f2:	2100      	movs	r1, #0
100408f4:	f003 ffce 	bl	10044894 <memset>

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE|RCC_OSCILLATORTYPE_LSE;
100408f8:	193b      	adds	r3, r7, r4
100408fa:	2203      	movs	r2, #3
100408fc:	601a      	str	r2, [r3, #0]
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
100408fe:	193b      	adds	r3, r7, r4
10040900:	2280      	movs	r2, #128	@ 0x80
10040902:	0252      	lsls	r2, r2, #9
10040904:	605a      	str	r2, [r3, #4]
  RCC_OscInitStruct.LSEState = RCC_LSE_ON;
10040906:	193b      	adds	r3, r7, r4
10040908:	2210      	movs	r2, #16
1004090a:	60da      	str	r2, [r3, #12]
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
1004090c:	193b      	adds	r3, r7, r4
1004090e:	0018      	movs	r0, r3
10040910:	f002 fd9c 	bl	1004344c <HAL_RCC_OscConfig>
10040914:	1e03      	subs	r3, r0, #0
10040916:	d001      	beq.n	1004091c <SystemClock_Config+0x48>
  {
    Error_Handler();
10040918:	f000 f96e 	bl	10040bf8 <Error_Handler>
  }

  /** Configure the SYSCLKSource and SYSCLKDivider
  */
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_RC64MPLL;
1004091c:	003b      	movs	r3, r7
1004091e:	2200      	movs	r2, #0
10040920:	601a      	str	r2, [r3, #0]
  RCC_ClkInitStruct.SYSCLKDivider = RCC_RC64MPLL_DIV1;
10040922:	003b      	movs	r3, r7
10040924:	2200      	movs	r2, #0
10040926:	605a      	str	r2, [r3, #4]

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_WAIT_STATES_1) != HAL_OK)
10040928:	003b      	movs	r3, r7
1004092a:	2110      	movs	r1, #16
1004092c:	0018      	movs	r0, r3
1004092e:	f002 fee3 	bl	100436f8 <HAL_RCC_ClockConfig>
10040932:	1e03      	subs	r3, r0, #0
10040934:	d001      	beq.n	1004093a <SystemClock_Config+0x66>
  {
    Error_Handler();
10040936:	f000 f95f 	bl	10040bf8 <Error_Handler>
  }
}
1004093a:	46c0      	nop			@ (mov r8, r8)
1004093c:	46bd      	mov	sp, r7
1004093e:	b009      	add	sp, #36	@ 0x24
10040940:	bd90      	pop	{r4, r7, pc}

10040942 <PeriphCommonClock_Config>:
/**
  * @brief Peripherals Common Clock Configuration
  * @retval None
  */
void PeriphCommonClock_Config(void)
{
10040942:	b580      	push	{r7, lr}
10040944:	b086      	sub	sp, #24
10040946:	af00      	add	r7, sp, #0
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
10040948:	003b      	movs	r3, r7
1004094a:	0018      	movs	r0, r3
1004094c:	2318      	movs	r3, #24
1004094e:	001a      	movs	r2, r3
10040950:	2100      	movs	r1, #0
10040952:	f003 ff9f 	bl	10044894 <memset>

  /** Initializes the peripherals clock
  */
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_SMPS;
10040956:	003b      	movs	r3, r7
10040958:	2202      	movs	r2, #2
1004095a:	601a      	str	r2, [r3, #0]
  PeriphClkInitStruct.SmpsDivSelection = RCC_SMPSCLK_DIV4;
1004095c:	003b      	movs	r3, r7
1004095e:	2280      	movs	r2, #128	@ 0x80
10040960:	0152      	lsls	r2, r2, #5
10040962:	611a      	str	r2, [r3, #16]
  PeriphClkInitStruct.KRMRateMultiplier = 4;
10040964:	003b      	movs	r3, r7
10040966:	2204      	movs	r2, #4
10040968:	615a      	str	r2, [r3, #20]

  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
1004096a:	003b      	movs	r3, r7
1004096c:	0018      	movs	r0, r3
1004096e:	f003 f82d 	bl	100439cc <HAL_RCCEx_PeriphCLKConfig>
10040972:	1e03      	subs	r3, r0, #0
10040974:	d001      	beq.n	1004097a <PeriphCommonClock_Config+0x38>
  {
    Error_Handler();
10040976:	f000 f93f 	bl	10040bf8 <Error_Handler>
  }
}
1004097a:	46c0      	nop			@ (mov r8, r8)
1004097c:	46bd      	mov	sp, r7
1004097e:	b006      	add	sp, #24
10040980:	bd80      	pop	{r7, pc}
	...

10040984 <MX_MRSUBG_Init>:
  * @brief MRSUBG Initialization Function
  * @param None
  * @retval None
  */
static void MX_MRSUBG_Init(void)
{
10040984:	b580      	push	{r7, lr}
10040986:	af00      	add	r7, sp, #0

  /* USER CODE END MRSUBG_Init 1 */

  /** Configures the radio parameters
  */
  MRSUBG_RadioInitStruct.lFrequencyBase = 868000000;
10040988:	4b23      	ldr	r3, [pc, #140]	@ (10040a18 <MX_MRSUBG_Init+0x94>)
1004098a:	4a24      	ldr	r2, [pc, #144]	@ (10040a1c <MX_MRSUBG_Init+0x98>)
1004098c:	601a      	str	r2, [r3, #0]
  MRSUBG_RadioInitStruct.xModulationSelect = MOD_2FSK;
1004098e:	4b22      	ldr	r3, [pc, #136]	@ (10040a18 <MX_MRSUBG_Init+0x94>)
10040990:	2200      	movs	r2, #0
10040992:	711a      	strb	r2, [r3, #4]
  MRSUBG_RadioInitStruct.lDatarate = 38400;
10040994:	4b20      	ldr	r3, [pc, #128]	@ (10040a18 <MX_MRSUBG_Init+0x94>)
10040996:	2296      	movs	r2, #150	@ 0x96
10040998:	0212      	lsls	r2, r2, #8
1004099a:	609a      	str	r2, [r3, #8]
  MRSUBG_RadioInitStruct.lFreqDev = 20000;
1004099c:	4b1e      	ldr	r3, [pc, #120]	@ (10040a18 <MX_MRSUBG_Init+0x94>)
1004099e:	4a20      	ldr	r2, [pc, #128]	@ (10040a20 <MX_MRSUBG_Init+0x9c>)
100409a0:	60da      	str	r2, [r3, #12]
  MRSUBG_RadioInitStruct.lBandwidth = 100000;
100409a2:	4b1d      	ldr	r3, [pc, #116]	@ (10040a18 <MX_MRSUBG_Init+0x94>)
100409a4:	4a1f      	ldr	r2, [pc, #124]	@ (10040a24 <MX_MRSUBG_Init+0xa0>)
100409a6:	611a      	str	r2, [r3, #16]
  MRSUBG_RadioInitStruct.dsssExp = 0;
100409a8:	4b1b      	ldr	r3, [pc, #108]	@ (10040a18 <MX_MRSUBG_Init+0x94>)
100409aa:	2200      	movs	r2, #0
100409ac:	751a      	strb	r2, [r3, #20]
  MRSUBG_RadioInitStruct.outputPower = 14;
100409ae:	4b1a      	ldr	r3, [pc, #104]	@ (10040a18 <MX_MRSUBG_Init+0x94>)
100409b0:	220e      	movs	r2, #14
100409b2:	755a      	strb	r2, [r3, #21]
  MRSUBG_RadioInitStruct.PADrvMode = PA_DRV_TX_HP;
100409b4:	4b18      	ldr	r3, [pc, #96]	@ (10040a18 <MX_MRSUBG_Init+0x94>)
100409b6:	2202      	movs	r2, #2
100409b8:	759a      	strb	r2, [r3, #22]
  HAL_MRSubG_Init(&MRSUBG_RadioInitStruct);
100409ba:	4b17      	ldr	r3, [pc, #92]	@ (10040a18 <MX_MRSUBG_Init+0x94>)
100409bc:	0018      	movs	r0, r3
100409be:	f001 ffab 	bl	10042918 <HAL_MRSubG_Init>

  /** Configures the packet parameters
  */
  MRSUBG_PacketSettingsStruct.PreambleLength = 16;
100409c2:	4b19      	ldr	r3, [pc, #100]	@ (10040a28 <MX_MRSUBG_Init+0xa4>)
100409c4:	2210      	movs	r2, #16
100409c6:	801a      	strh	r2, [r3, #0]
  MRSUBG_PacketSettingsStruct.PostambleLength = 0;
100409c8:	4b17      	ldr	r3, [pc, #92]	@ (10040a28 <MX_MRSUBG_Init+0xa4>)
100409ca:	2200      	movs	r2, #0
100409cc:	805a      	strh	r2, [r3, #2]
  MRSUBG_PacketSettingsStruct.SyncLength = 31;
100409ce:	4b16      	ldr	r3, [pc, #88]	@ (10040a28 <MX_MRSUBG_Init+0xa4>)
100409d0:	221f      	movs	r2, #31
100409d2:	711a      	strb	r2, [r3, #4]
  MRSUBG_PacketSettingsStruct.SyncWord = 0x88888888;
100409d4:	4b14      	ldr	r3, [pc, #80]	@ (10040a28 <MX_MRSUBG_Init+0xa4>)
100409d6:	4a15      	ldr	r2, [pc, #84]	@ (10040a2c <MX_MRSUBG_Init+0xa8>)
100409d8:	609a      	str	r2, [r3, #8]
  MRSUBG_PacketSettingsStruct.FixVarLength = VARIABLE;
100409da:	4b13      	ldr	r3, [pc, #76]	@ (10040a28 <MX_MRSUBG_Init+0xa4>)
100409dc:	2201      	movs	r2, #1
100409de:	731a      	strb	r2, [r3, #12]
  MRSUBG_PacketSettingsStruct.PreambleSequence = PRE_SEQ_0101;
100409e0:	4b11      	ldr	r3, [pc, #68]	@ (10040a28 <MX_MRSUBG_Init+0xa4>)
100409e2:	2200      	movs	r2, #0
100409e4:	735a      	strb	r2, [r3, #13]
  MRSUBG_PacketSettingsStruct.PostambleSequence = POST_SEQ_0101;
100409e6:	4b10      	ldr	r3, [pc, #64]	@ (10040a28 <MX_MRSUBG_Init+0xa4>)
100409e8:	2200      	movs	r2, #0
100409ea:	739a      	strb	r2, [r3, #14]
  MRSUBG_PacketSettingsStruct.CrcMode = PKT_CRC_MODE_8BITS;
100409ec:	4b0e      	ldr	r3, [pc, #56]	@ (10040a28 <MX_MRSUBG_Init+0xa4>)
100409ee:	2201      	movs	r2, #1
100409f0:	73da      	strb	r2, [r3, #15]
  MRSUBG_PacketSettingsStruct.Coding = CODING_NONE;
100409f2:	4b0d      	ldr	r3, [pc, #52]	@ (10040a28 <MX_MRSUBG_Init+0xa4>)
100409f4:	2200      	movs	r2, #0
100409f6:	741a      	strb	r2, [r3, #16]
  MRSUBG_PacketSettingsStruct.DataWhitening = ENABLE;
100409f8:	4b0b      	ldr	r3, [pc, #44]	@ (10040a28 <MX_MRSUBG_Init+0xa4>)
100409fa:	2201      	movs	r2, #1
100409fc:	745a      	strb	r2, [r3, #17]
  MRSUBG_PacketSettingsStruct.LengthWidth = BYTE_LEN_1;
100409fe:	4b0a      	ldr	r3, [pc, #40]	@ (10040a28 <MX_MRSUBG_Init+0xa4>)
10040a00:	2200      	movs	r2, #0
10040a02:	749a      	strb	r2, [r3, #18]
  MRSUBG_PacketSettingsStruct.SyncPresent = ENABLE;
10040a04:	4b08      	ldr	r3, [pc, #32]	@ (10040a28 <MX_MRSUBG_Init+0xa4>)
10040a06:	2201      	movs	r2, #1
10040a08:	74da      	strb	r2, [r3, #19]
  HAL_MRSubG_PacketBasicInit(&MRSUBG_PacketSettingsStruct);
10040a0a:	4b07      	ldr	r3, [pc, #28]	@ (10040a28 <MX_MRSUBG_Init+0xa4>)
10040a0c:	0018      	movs	r0, r3
10040a0e:	f002 faad 	bl	10042f6c <HAL_MRSubG_PacketBasicInit>
  /* USER CODE BEGIN MRSUBG_Init 2 */

  /* USER CODE END MRSUBG_Init 2 */

}
10040a12:	46c0      	nop			@ (mov r8, r8)
10040a14:	46bd      	mov	sp, r7
10040a16:	bd80      	pop	{r7, pc}
10040a18:	20000034 	.word	0x20000034
10040a1c:	33bca100 	.word	0x33bca100
10040a20:	00004e20 	.word	0x00004e20
10040a24:	000186a0 	.word	0x000186a0
10040a28:	2000004c 	.word	0x2000004c
10040a2c:	88888888 	.word	0x88888888

10040a30 <MX_GPIO_Init>:
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
10040a30:	b580      	push	{r7, lr}
10040a32:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MX_GPIO_Init_1 */
  /* USER CODE END MX_GPIO_Init_1 */

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOA_CLK_ENABLE();
10040a34:	2004      	movs	r0, #4
10040a36:	f7ff fe2f 	bl	10040698 <LL_AHB1_GRP1_EnableClock>
  __HAL_RCC_GPIOB_CLK_ENABLE();
10040a3a:	2008      	movs	r0, #8
10040a3c:	f7ff fe2c 	bl	10040698 <LL_AHB1_GRP1_EnableClock>

  /* USER CODE BEGIN MX_GPIO_Init_2 */
  /* USER CODE END MX_GPIO_Init_2 */
}
10040a40:	46c0      	nop			@ (mov r8, r8)
10040a42:	46bd      	mov	sp, r7
10040a44:	bd80      	pop	{r7, pc}

10040a46 <__io_getcharNonBlocking>:

/* USER CODE BEGIN 4 */

uint8_t __io_getcharNonBlocking(uint8_t *data)
{
10040a46:	b580      	push	{r7, lr}
10040a48:	b082      	sub	sp, #8
10040a4a:	af00      	add	r7, sp, #0
10040a4c:	6078      	str	r0, [r7, #4]
  if (Read_Buffer_Pop(data))
10040a4e:	687b      	ldr	r3, [r7, #4]
10040a50:	0018      	movs	r0, r3
10040a52:	f000 f809 	bl	10040a68 <Read_Buffer_Pop>
10040a56:	1e03      	subs	r3, r0, #0
10040a58:	d001      	beq.n	10040a5e <__io_getcharNonBlocking+0x18>
    return 1;
10040a5a:	2301      	movs	r3, #1
10040a5c:	e000      	b.n	10040a60 <__io_getcharNonBlocking+0x1a>
  else
    return 0;
10040a5e:	2300      	movs	r3, #0
}
10040a60:	0018      	movs	r0, r3
10040a62:	46bd      	mov	sp, r7
10040a64:	b002      	add	sp, #8
10040a66:	bd80      	pop	{r7, pc}

10040a68 <Read_Buffer_Pop>:

uint8_t Read_Buffer_Pop(uint8_t *byte)
{
10040a68:	b580      	push	{r7, lr}
10040a6a:	b082      	sub	sp, #8
10040a6c:	af00      	add	r7, sp, #0
10040a6e:	6078      	str	r0, [r7, #4]
  if(READ_BUFFER_IS_EMPTY())
10040a70:	4b10      	ldr	r3, [pc, #64]	@ (10040ab4 <Read_Buffer_Pop+0x4c>)
10040a72:	681a      	ldr	r2, [r3, #0]
10040a74:	4b10      	ldr	r3, [pc, #64]	@ (10040ab8 <Read_Buffer_Pop+0x50>)
10040a76:	681b      	ldr	r3, [r3, #0]
10040a78:	429a      	cmp	r2, r3
10040a7a:	d101      	bne.n	10040a80 <Read_Buffer_Pop+0x18>
    return 0;
10040a7c:	2300      	movs	r3, #0
10040a7e:	e014      	b.n	10040aaa <Read_Buffer_Pop+0x42>

  *byte = Read_Buffer[Read_ptr_out];
10040a80:	4b0d      	ldr	r3, [pc, #52]	@ (10040ab8 <Read_Buffer_Pop+0x50>)
10040a82:	681b      	ldr	r3, [r3, #0]
10040a84:	4a0d      	ldr	r2, [pc, #52]	@ (10040abc <Read_Buffer_Pop+0x54>)
10040a86:	5cd2      	ldrb	r2, [r2, r3]
10040a88:	687b      	ldr	r3, [r7, #4]
10040a8a:	701a      	strb	r2, [r3, #0]
  Read_ptr_out++;
10040a8c:	4b0a      	ldr	r3, [pc, #40]	@ (10040ab8 <Read_Buffer_Pop+0x50>)
10040a8e:	681b      	ldr	r3, [r3, #0]
10040a90:	1c5a      	adds	r2, r3, #1
10040a92:	4b09      	ldr	r3, [pc, #36]	@ (10040ab8 <Read_Buffer_Pop+0x50>)
10040a94:	601a      	str	r2, [r3, #0]

  if(Read_ptr_out == READ_DATA_SIZE)
10040a96:	4b08      	ldr	r3, [pc, #32]	@ (10040ab8 <Read_Buffer_Pop+0x50>)
10040a98:	681a      	ldr	r2, [r3, #0]
10040a9a:	2380      	movs	r3, #128	@ 0x80
10040a9c:	00db      	lsls	r3, r3, #3
10040a9e:	429a      	cmp	r2, r3
10040aa0:	d102      	bne.n	10040aa8 <Read_Buffer_Pop+0x40>
    Read_ptr_out = 0;
10040aa2:	4b05      	ldr	r3, [pc, #20]	@ (10040ab8 <Read_Buffer_Pop+0x50>)
10040aa4:	2200      	movs	r2, #0
10040aa6:	601a      	str	r2, [r3, #0]

  return 1;
10040aa8:	2301      	movs	r3, #1
}
10040aaa:	0018      	movs	r0, r3
10040aac:	46bd      	mov	sp, r7
10040aae:	b002      	add	sp, #8
10040ab0:	bd80      	pop	{r7, pc}
10040ab2:	46c0      	nop			@ (mov r8, r8)
10040ab4:	20000490 	.word	0x20000490
10040ab8:	20000494 	.word	0x20000494
10040abc:	20000090 	.word	0x20000090

10040ac0 <Read_Buffer_Push>:

void Read_Buffer_Push(uint8_t byte)
{
10040ac0:	b580      	push	{r7, lr}
10040ac2:	b082      	sub	sp, #8
10040ac4:	af00      	add	r7, sp, #0
10040ac6:	0002      	movs	r2, r0
10040ac8:	1dfb      	adds	r3, r7, #7
10040aca:	701a      	strb	r2, [r3, #0]
  Read_Buffer[Read_ptr_in] = byte;
10040acc:	4b0b      	ldr	r3, [pc, #44]	@ (10040afc <Read_Buffer_Push+0x3c>)
10040ace:	681b      	ldr	r3, [r3, #0]
10040ad0:	4a0b      	ldr	r2, [pc, #44]	@ (10040b00 <Read_Buffer_Push+0x40>)
10040ad2:	1df9      	adds	r1, r7, #7
10040ad4:	7809      	ldrb	r1, [r1, #0]
10040ad6:	54d1      	strb	r1, [r2, r3]

  Read_ptr_in++;
10040ad8:	4b08      	ldr	r3, [pc, #32]	@ (10040afc <Read_Buffer_Push+0x3c>)
10040ada:	681b      	ldr	r3, [r3, #0]
10040adc:	1c5a      	adds	r2, r3, #1
10040ade:	4b07      	ldr	r3, [pc, #28]	@ (10040afc <Read_Buffer_Push+0x3c>)
10040ae0:	601a      	str	r2, [r3, #0]

  /* To avoid buffer overflow */
  if(Read_ptr_in == READ_DATA_SIZE)
10040ae2:	4b06      	ldr	r3, [pc, #24]	@ (10040afc <Read_Buffer_Push+0x3c>)
10040ae4:	681a      	ldr	r2, [r3, #0]
10040ae6:	2380      	movs	r3, #128	@ 0x80
10040ae8:	00db      	lsls	r3, r3, #3
10040aea:	429a      	cmp	r2, r3
10040aec:	d102      	bne.n	10040af4 <Read_Buffer_Push+0x34>
  {
    Read_ptr_in = 0;
10040aee:	4b03      	ldr	r3, [pc, #12]	@ (10040afc <Read_Buffer_Push+0x3c>)
10040af0:	2200      	movs	r2, #0
10040af2:	601a      	str	r2, [r3, #0]
  }
}
10040af4:	46c0      	nop			@ (mov r8, r8)
10040af6:	46bd      	mov	sp, r7
10040af8:	b002      	add	sp, #8
10040afa:	bd80      	pop	{r7, pc}
10040afc:	20000490 	.word	0x20000490
10040b00:	20000090 	.word	0x20000090

10040b04 <Process_InputData>:

void Process_InputData(uint8_t* data_buffer, uint16_t Nb_bytes)
{
10040b04:	b590      	push	{r4, r7, lr}
10040b06:	b085      	sub	sp, #20
10040b08:	af00      	add	r7, sp, #0
10040b0a:	6078      	str	r0, [r7, #4]
10040b0c:	000a      	movs	r2, r1
10040b0e:	1cbb      	adds	r3, r7, #2
10040b10:	801a      	strh	r2, [r3, #0]
  for(uint16_t i = 0; i < Nb_bytes; i++){
10040b12:	230e      	movs	r3, #14
10040b14:	18fb      	adds	r3, r7, r3
10040b16:	2200      	movs	r2, #0
10040b18:	801a      	strh	r2, [r3, #0]
10040b1a:	e00d      	b.n	10040b38 <Process_InputData+0x34>
    Read_Buffer_Push(data_buffer[i]);
10040b1c:	240e      	movs	r4, #14
10040b1e:	193b      	adds	r3, r7, r4
10040b20:	881b      	ldrh	r3, [r3, #0]
10040b22:	687a      	ldr	r2, [r7, #4]
10040b24:	18d3      	adds	r3, r2, r3
10040b26:	781b      	ldrb	r3, [r3, #0]
10040b28:	0018      	movs	r0, r3
10040b2a:	f7ff ffc9 	bl	10040ac0 <Read_Buffer_Push>
  for(uint16_t i = 0; i < Nb_bytes; i++){
10040b2e:	193b      	adds	r3, r7, r4
10040b30:	881a      	ldrh	r2, [r3, #0]
10040b32:	193b      	adds	r3, r7, r4
10040b34:	3201      	adds	r2, #1
10040b36:	801a      	strh	r2, [r3, #0]
10040b38:	230e      	movs	r3, #14
10040b3a:	18fa      	adds	r2, r7, r3
10040b3c:	1cbb      	adds	r3, r7, #2
10040b3e:	8812      	ldrh	r2, [r2, #0]
10040b40:	881b      	ldrh	r3, [r3, #0]
10040b42:	429a      	cmp	r2, r3
10040b44:	d3ea      	bcc.n	10040b1c <Process_InputData+0x18>
  }
}
10040b46:	46c0      	nop			@ (mov r8, r8)
10040b48:	46c0      	nop			@ (mov r8, r8)
10040b4a:	46bd      	mov	sp, r7
10040b4c:	b005      	add	sp, #20
10040b4e:	bd90      	pop	{r4, r7, pc}

10040b50 <HAL_MRSubG_IRQ_Callback>:

void HAL_MRSubG_IRQ_Callback(void){
10040b50:	b590      	push	{r4, r7, lr}
10040b52:	b085      	sub	sp, #20
10040b54:	af00      	add	r7, sp, #0
  uint32_t irq;
  
  irq = __HAL_MRSUBG_GET_RFSEQ_IRQ_STATUS();
10040b56:	4b22      	ldr	r3, [pc, #136]	@ (10040be0 <HAL_MRSubG_IRQ_Callback+0x90>)
10040b58:	681b      	ldr	r3, [r3, #0]
10040b5a:	60bb      	str	r3, [r7, #8]
  
  if (irq & MR_SUBG_GLOB_STATUS_RFSEQ_IRQ_STATUS_RX_OK_F) {
10040b5c:	68bb      	ldr	r3, [r7, #8]
10040b5e:	2202      	movs	r2, #2
10040b60:	4013      	ands	r3, r2
10040b62:	d02e      	beq.n	10040bc2 <HAL_MRSubG_IRQ_Callback+0x72>
    
    /* Clear the IRQ flag */
    __HAL_MRSUBG_CLEAR_RFSEQ_IRQ_FLAG(MR_SUBG_GLOB_STATUS_RFSEQ_IRQ_STATUS_RX_OK_F);
10040b64:	4b1e      	ldr	r3, [pc, #120]	@ (10040be0 <HAL_MRSubG_IRQ_Callback+0x90>)
10040b66:	2202      	movs	r2, #2
10040b68:	601a      	str	r2, [r3, #0]
    
    uint16_t rxBytes = __HAL_MRSUBG_GET_DATABUFFER_COUNT();
10040b6a:	4b1d      	ldr	r3, [pc, #116]	@ (10040be0 <HAL_MRSubG_IRQ_Callback+0x90>)
10040b6c:	69da      	ldr	r2, [r3, #28]
10040b6e:	1dbb      	adds	r3, r7, #6
10040b70:	801a      	strh	r2, [r3, #0]
    
    printf("\n\rrx>");
10040b72:	4b1c      	ldr	r3, [pc, #112]	@ (10040be4 <HAL_MRSubG_IRQ_Callback+0x94>)
10040b74:	0018      	movs	r0, r3
10040b76:	f003 fd71 	bl	1004465c <iprintf>
    
    /* Display the received message */
    for(uint8_t i=0 ; i<rxBytes; i++)
10040b7a:	230f      	movs	r3, #15
10040b7c:	18fb      	adds	r3, r7, r3
10040b7e:	2200      	movs	r2, #0
10040b80:	701a      	strb	r2, [r3, #0]
10040b82:	e00c      	b.n	10040b9e <HAL_MRSubG_IRQ_Callback+0x4e>
      printf("%c", rx_data[i]);
10040b84:	240f      	movs	r4, #15
10040b86:	193b      	adds	r3, r7, r4
10040b88:	781b      	ldrb	r3, [r3, #0]
10040b8a:	4a17      	ldr	r2, [pc, #92]	@ (10040be8 <HAL_MRSubG_IRQ_Callback+0x98>)
10040b8c:	5cd3      	ldrb	r3, [r2, r3]
10040b8e:	0018      	movs	r0, r3
10040b90:	f003 fd74 	bl	1004467c <putchar>
    for(uint8_t i=0 ; i<rxBytes; i++)
10040b94:	193b      	adds	r3, r7, r4
10040b96:	781a      	ldrb	r2, [r3, #0]
10040b98:	193b      	adds	r3, r7, r4
10040b9a:	3201      	adds	r2, #1
10040b9c:	701a      	strb	r2, [r3, #0]
10040b9e:	230f      	movs	r3, #15
10040ba0:	18fb      	adds	r3, r7, r3
10040ba2:	781b      	ldrb	r3, [r3, #0]
10040ba4:	b29b      	uxth	r3, r3
10040ba6:	1dba      	adds	r2, r7, #6
10040ba8:	8812      	ldrh	r2, [r2, #0]
10040baa:	429a      	cmp	r2, r3
10040bac:	d8ea      	bhi.n	10040b84 <HAL_MRSubG_IRQ_Callback+0x34>
    
    printf("\n\rtx>");
10040bae:	4b0f      	ldr	r3, [pc, #60]	@ (10040bec <HAL_MRSubG_IRQ_Callback+0x9c>)
10040bb0:	0018      	movs	r0, r3
10040bb2:	f003 fd53 	bl	1004465c <iprintf>
    
    /* Restart RX */
    __HAL_MRSUBG_SET_DATABUFFER0_POINTER((uint32_t)&rx_data);    
10040bb6:	4b0e      	ldr	r3, [pc, #56]	@ (10040bf0 <HAL_MRSubG_IRQ_Callback+0xa0>)
10040bb8:	4a0b      	ldr	r2, [pc, #44]	@ (10040be8 <HAL_MRSubG_IRQ_Callback+0x98>)
10040bba:	615a      	str	r2, [r3, #20]
    __HAL_MRSUBG_STROBE_CMD(CMD_RX);    
10040bbc:	2002      	movs	r0, #2
10040bbe:	f7ff fd81 	bl	100406c4 <LL_MRSubG_StrobeCommand>
  }
  
  if (irq & MR_SUBG_GLOB_STATUS_RFSEQ_IRQ_STATUS_TX_DONE_F ) {
10040bc2:	68bb      	ldr	r3, [r7, #8]
10040bc4:	2201      	movs	r2, #1
10040bc6:	4013      	ands	r3, r2
10040bc8:	d005      	beq.n	10040bd6 <HAL_MRSubG_IRQ_Callback+0x86>
    
    /* Clear the IRQ flag */
    __HAL_MRSUBG_CLEAR_RFSEQ_IRQ_FLAG(MR_SUBG_GLOB_STATUS_RFSEQ_IRQ_STATUS_TX_DONE_F);    
10040bca:	4b05      	ldr	r3, [pc, #20]	@ (10040be0 <HAL_MRSubG_IRQ_Callback+0x90>)
10040bcc:	2201      	movs	r2, #1
10040bce:	601a      	str	r2, [r3, #0]
    
    /* set the tx_done_flag to manage the event in the main() */
    xTxDoneFlag = SET;
10040bd0:	4b08      	ldr	r3, [pc, #32]	@ (10040bf4 <HAL_MRSubG_IRQ_Callback+0xa4>)
10040bd2:	2201      	movs	r2, #1
10040bd4:	701a      	strb	r2, [r3, #0]
  }  
}
10040bd6:	46c0      	nop			@ (mov r8, r8)
10040bd8:	46bd      	mov	sp, r7
10040bda:	b005      	add	sp, #20
10040bdc:	bd90      	pop	{r4, r7, pc}
10040bde:	46c0      	nop			@ (mov r8, r8)
10040be0:	49000600 	.word	0x49000600
10040be4:	10045570 	.word	0x10045570
10040be8:	20000078 	.word	0x20000078
10040bec:	10045578 	.word	0x10045578
10040bf0:	49000400 	.word	0x49000400
10040bf4:	20000060 	.word	0x20000060

10040bf8 <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
10040bf8:	b580      	push	{r7, lr}
10040bfa:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  while(1)
10040bfc:	46c0      	nop			@ (mov r8, r8)
10040bfe:	e7fd      	b.n	10040bfc <Error_Handler+0x4>

10040c00 <LL_APB0_GRP1_EnableClock>:
  * @arg LL_APB0_GRP1_PERIPH_WDG
  * @arg LL_APB0_GRP1_PERIPH_DBGMCU
  * @retval None
  */
__STATIC_INLINE void LL_APB0_GRP1_EnableClock(uint32_t Periphs)
{
10040c00:	b580      	push	{r7, lr}
10040c02:	b084      	sub	sp, #16
10040c04:	af00      	add	r7, sp, #0
10040c06:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  SET_BIT(RCC->APB0ENR, Periphs);
10040c08:	4b07      	ldr	r3, [pc, #28]	@ (10040c28 <LL_APB0_GRP1_EnableClock+0x28>)
10040c0a:	6d59      	ldr	r1, [r3, #84]	@ 0x54
10040c0c:	4b06      	ldr	r3, [pc, #24]	@ (10040c28 <LL_APB0_GRP1_EnableClock+0x28>)
10040c0e:	687a      	ldr	r2, [r7, #4]
10040c10:	430a      	orrs	r2, r1
10040c12:	655a      	str	r2, [r3, #84]	@ 0x54
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->APB0ENR, Periphs);
10040c14:	4b04      	ldr	r3, [pc, #16]	@ (10040c28 <LL_APB0_GRP1_EnableClock+0x28>)
10040c16:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
10040c18:	687a      	ldr	r2, [r7, #4]
10040c1a:	4013      	ands	r3, r2
10040c1c:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
10040c1e:	68fb      	ldr	r3, [r7, #12]
}
10040c20:	46c0      	nop			@ (mov r8, r8)
10040c22:	46bd      	mov	sp, r7
10040c24:	b004      	add	sp, #16
10040c26:	bd80      	pop	{r7, pc}
10040c28:	48400000 	.word	0x48400000

10040c2c <LL_APB2_GRP1_EnableClock>:
  * @arg LL_APB2_GRP1_PERIPH_MRSUBG
  * @arg LL_APB2_GRP1_PERIPH_LPAWUR
  * @retval None
  */
__STATIC_INLINE void LL_APB2_GRP1_EnableClock(uint32_t Periphs)
{
10040c2c:	b580      	push	{r7, lr}
10040c2e:	b084      	sub	sp, #16
10040c30:	af00      	add	r7, sp, #0
10040c32:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  SET_BIT(RCC->APB2ENR, Periphs);
10040c34:	4b07      	ldr	r3, [pc, #28]	@ (10040c54 <LL_APB2_GRP1_EnableClock+0x28>)
10040c36:	6e19      	ldr	r1, [r3, #96]	@ 0x60
10040c38:	4b06      	ldr	r3, [pc, #24]	@ (10040c54 <LL_APB2_GRP1_EnableClock+0x28>)
10040c3a:	687a      	ldr	r2, [r7, #4]
10040c3c:	430a      	orrs	r2, r1
10040c3e:	661a      	str	r2, [r3, #96]	@ 0x60
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->APB2ENR, Periphs);
10040c40:	4b04      	ldr	r3, [pc, #16]	@ (10040c54 <LL_APB2_GRP1_EnableClock+0x28>)
10040c42:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
10040c44:	687a      	ldr	r2, [r7, #4]
10040c46:	4013      	ands	r3, r2
10040c48:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
10040c4a:	68fb      	ldr	r3, [r7, #12]
}
10040c4c:	46c0      	nop			@ (mov r8, r8)
10040c4e:	46bd      	mov	sp, r7
10040c50:	b004      	add	sp, #16
10040c52:	bd80      	pop	{r7, pc}
10040c54:	48400000 	.word	0x48400000

10040c58 <LL_APB2_GRP1_IsEnabledClock>:
  * @arg LL_APB2_GRP1_PERIPH_MRSUBG
  * @arg LL_APB2_GRP1_PERIPH_LPAWUR
  * @retval uint32_t
  */
__STATIC_INLINE uint32_t LL_APB2_GRP1_IsEnabledClock(uint32_t Periphs)
{
10040c58:	b580      	push	{r7, lr}
10040c5a:	b082      	sub	sp, #8
10040c5c:	af00      	add	r7, sp, #0
10040c5e:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(RCC->APB2ENR, Periphs) == (Periphs)) ? 1UL : 0UL);
10040c60:	4b06      	ldr	r3, [pc, #24]	@ (10040c7c <LL_APB2_GRP1_IsEnabledClock+0x24>)
10040c62:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
10040c64:	687a      	ldr	r2, [r7, #4]
10040c66:	4013      	ands	r3, r2
10040c68:	687a      	ldr	r2, [r7, #4]
10040c6a:	429a      	cmp	r2, r3
10040c6c:	d101      	bne.n	10040c72 <LL_APB2_GRP1_IsEnabledClock+0x1a>
10040c6e:	2301      	movs	r3, #1
10040c70:	e000      	b.n	10040c74 <LL_APB2_GRP1_IsEnabledClock+0x1c>
10040c72:	2300      	movs	r3, #0
}
10040c74:	0018      	movs	r0, r3
10040c76:	46bd      	mov	sp, r7
10040c78:	b002      	add	sp, #8
10040c7a:	bd80      	pop	{r7, pc}
10040c7c:	48400000 	.word	0x48400000

10040c80 <LL_APB2_GRP1_ForceReset>:
  * @arg LL_APB2_GRP1_PERIPH_MRSUBG
  * @arg LL_APB2_GRP1_PERIPH_LPAWUR
  * @retval None
  */
__STATIC_INLINE void LL_APB2_GRP1_ForceReset(uint32_t Periphs)
{
10040c80:	b580      	push	{r7, lr}
10040c82:	b082      	sub	sp, #8
10040c84:	af00      	add	r7, sp, #0
10040c86:	6078      	str	r0, [r7, #4]
  SET_BIT(RCC->APB2RSTR, Periphs);
10040c88:	4b04      	ldr	r3, [pc, #16]	@ (10040c9c <LL_APB2_GRP1_ForceReset+0x1c>)
10040c8a:	6c19      	ldr	r1, [r3, #64]	@ 0x40
10040c8c:	4b03      	ldr	r3, [pc, #12]	@ (10040c9c <LL_APB2_GRP1_ForceReset+0x1c>)
10040c8e:	687a      	ldr	r2, [r7, #4]
10040c90:	430a      	orrs	r2, r1
10040c92:	641a      	str	r2, [r3, #64]	@ 0x40
}
10040c94:	46c0      	nop			@ (mov r8, r8)
10040c96:	46bd      	mov	sp, r7
10040c98:	b002      	add	sp, #8
10040c9a:	bd80      	pop	{r7, pc}
10040c9c:	48400000 	.word	0x48400000

10040ca0 <LL_APB2_GRP1_ReleaseReset>:
  * @arg LL_APB2_GRP1_PERIPH_MRSUBG
  * @arg LL_APB2_GRP1_PERIPH_LPAWUR
  * @retval None
  */
__STATIC_INLINE void LL_APB2_GRP1_ReleaseReset(uint32_t Periphs)
{
10040ca0:	b580      	push	{r7, lr}
10040ca2:	b082      	sub	sp, #8
10040ca4:	af00      	add	r7, sp, #0
10040ca6:	6078      	str	r0, [r7, #4]
  CLEAR_BIT(RCC->APB2RSTR, Periphs);
10040ca8:	4b05      	ldr	r3, [pc, #20]	@ (10040cc0 <LL_APB2_GRP1_ReleaseReset+0x20>)
10040caa:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
10040cac:	687b      	ldr	r3, [r7, #4]
10040cae:	43d9      	mvns	r1, r3
10040cb0:	4b03      	ldr	r3, [pc, #12]	@ (10040cc0 <LL_APB2_GRP1_ReleaseReset+0x20>)
10040cb2:	400a      	ands	r2, r1
10040cb4:	641a      	str	r2, [r3, #64]	@ 0x40
}
10040cb6:	46c0      	nop			@ (mov r8, r8)
10040cb8:	46bd      	mov	sp, r7
10040cba:	b002      	add	sp, #8
10040cbc:	bd80      	pop	{r7, pc}
10040cbe:	46c0      	nop			@ (mov r8, r8)
10040cc0:	48400000 	.word	0x48400000

10040cc4 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
10040cc4:	b580      	push	{r7, lr}
10040cc6:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
10040cc8:	2380      	movs	r3, #128	@ 0x80
10040cca:	005b      	lsls	r3, r3, #1
10040ccc:	0018      	movs	r0, r3
10040cce:	f7ff ff97 	bl	10040c00 <LL_APB0_GRP1_EnableClock>
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
10040cd2:	46c0      	nop			@ (mov r8, r8)
10040cd4:	46bd      	mov	sp, r7
10040cd6:	bd80      	pop	{r7, pc}

10040cd8 <HAL_MRSubG_MspInit>:
  * This function configures the hardware resources used in this example
  * @param hmrsubg: MRSubG handle pointer
  * @retval None
  */
void HAL_MRSubG_MspInit(void)
{
10040cd8:	b580      	push	{r7, lr}
10040cda:	b086      	sub	sp, #24
10040cdc:	af00      	add	r7, sp, #0
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
10040cde:	003b      	movs	r3, r7
10040ce0:	0018      	movs	r0, r3
10040ce2:	2318      	movs	r3, #24
10040ce4:	001a      	movs	r2, r3
10040ce6:	2100      	movs	r1, #0
10040ce8:	f003 fdd4 	bl	10044894 <memset>

    /* USER CODE END MRSubG_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC_WDG_SUBG_LPAWUR_LCD_LCSC;
10040cec:	003b      	movs	r3, r7
10040cee:	2220      	movs	r2, #32
10040cf0:	601a      	str	r2, [r3, #0]
    PeriphClkInitStruct.RTCWDGSUBGLPAWURLCDLCSCClockSelection = RCC_RTC_WDG_SUBG_LPAWUR_LCD_LCSC_CLKSOURCE_LSE;
10040cf2:	003b      	movs	r3, r7
10040cf4:	2280      	movs	r2, #128	@ 0x80
10040cf6:	0212      	lsls	r2, r2, #8
10040cf8:	609a      	str	r2, [r3, #8]
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
10040cfa:	003b      	movs	r3, r7
10040cfc:	0018      	movs	r0, r3
10040cfe:	f002 fe65 	bl	100439cc <HAL_RCCEx_PeriphCLKConfig>
10040d02:	1e03      	subs	r3, r0, #0
10040d04:	d001      	beq.n	10040d0a <HAL_MRSubG_MspInit+0x32>
    {
      Error_Handler();
10040d06:	f7ff ff77 	bl	10040bf8 <Error_Handler>
    }

    /* Peripheral clock enable */
    if (__HAL_RCC_MRSUBG_IS_CLK_DISABLED())
10040d0a:	2001      	movs	r0, #1
10040d0c:	f7ff ffa4 	bl	10040c58 <LL_APB2_GRP1_IsEnabledClock>
10040d10:	1e03      	subs	r3, r0, #0
10040d12:	d108      	bne.n	10040d26 <HAL_MRSubG_MspInit+0x4e>
    {
      /* MRSUBG Peripheral reset */
      __HAL_RCC_MRSUBG_FORCE_RESET();
10040d14:	2001      	movs	r0, #1
10040d16:	f7ff ffb3 	bl	10040c80 <LL_APB2_GRP1_ForceReset>
      __HAL_RCC_MRSUBG_RELEASE_RESET();
10040d1a:	2001      	movs	r0, #1
10040d1c:	f7ff ffc0 	bl	10040ca0 <LL_APB2_GRP1_ReleaseReset>

      /* Enable MRSUBG peripheral clock */
      __HAL_RCC_MRSUBG_CLK_ENABLE();
10040d20:	2001      	movs	r0, #1
10040d22:	f7ff ff83 	bl	10040c2c <LL_APB2_GRP1_EnableClock>
    }

    /* MRSUBG interrupt Init */
    HAL_NVIC_SetPriority(MRSUBG_IRQn, 0, 0);
10040d26:	2200      	movs	r2, #0
10040d28:	2100      	movs	r1, #0
10040d2a:	2015      	movs	r0, #21
10040d2c:	f000 fcfc 	bl	10041728 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(MRSUBG_IRQn);
10040d30:	2015      	movs	r0, #21
10040d32:	f000 fd0e 	bl	10041752 <HAL_NVIC_EnableIRQ>
    /* USER CODE BEGIN MRSubG_MspInit 1 */

    /* USER CODE END MRSubG_MspInit 1 */

}
10040d36:	46c0      	nop			@ (mov r8, r8)
10040d38:	46bd      	mov	sp, r7
10040d3a:	b006      	add	sp, #24
10040d3c:	bd80      	pop	{r7, pc}

10040d3e <LL_USART_IsActiveFlag_RXNE_RXFNE>:
{
10040d3e:	b580      	push	{r7, lr}
10040d40:	b082      	sub	sp, #8
10040d42:	af00      	add	r7, sp, #0
10040d44:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(USARTx->ISR, USART_ISR_RXNE_RXFNE) == (USART_ISR_RXNE_RXFNE)) ? 1UL : 0UL);
10040d46:	687b      	ldr	r3, [r7, #4]
10040d48:	69db      	ldr	r3, [r3, #28]
10040d4a:	2220      	movs	r2, #32
10040d4c:	4013      	ands	r3, r2
10040d4e:	2b20      	cmp	r3, #32
10040d50:	d101      	bne.n	10040d56 <LL_USART_IsActiveFlag_RXNE_RXFNE+0x18>
10040d52:	2301      	movs	r3, #1
10040d54:	e000      	b.n	10040d58 <LL_USART_IsActiveFlag_RXNE_RXFNE+0x1a>
10040d56:	2300      	movs	r3, #0
}
10040d58:	0018      	movs	r0, r3
10040d5a:	46bd      	mov	sp, r7
10040d5c:	b002      	add	sp, #8
10040d5e:	bd80      	pop	{r7, pc}

10040d60 <LL_USART_ReceiveData8>:
  * @rmtoll RDR          RDR           LL_USART_ReceiveData8
  * @param  USARTx USART Instance
  * @retval Value between Min_Data=0x00 and Max_Data=0xFF
  */
__STATIC_INLINE uint8_t LL_USART_ReceiveData8(const USART_TypeDef *USARTx)
{
10040d60:	b580      	push	{r7, lr}
10040d62:	b082      	sub	sp, #8
10040d64:	af00      	add	r7, sp, #0
10040d66:	6078      	str	r0, [r7, #4]
  return (uint8_t)(READ_BIT(USARTx->RDR, USART_RDR_RDR) & 0xFFU);
10040d68:	687b      	ldr	r3, [r7, #4]
10040d6a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
10040d6c:	b2db      	uxtb	r3, r3
}
10040d6e:	0018      	movs	r0, r3
10040d70:	46bd      	mov	sp, r7
10040d72:	b002      	add	sp, #8
10040d74:	bd80      	pop	{r7, pc}

10040d76 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
10040d76:	b580      	push	{r7, lr}
10040d78:	af00      	add	r7, sp, #0

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */

  /* USER CODE END NonMaskableInt_IRQn 1 */
}
10040d7a:	46c0      	nop			@ (mov r8, r8)
10040d7c:	46bd      	mov	sp, r7
10040d7e:	bd80      	pop	{r7, pc}

10040d80 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
10040d80:	b580      	push	{r7, lr}
10040d82:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
10040d84:	46c0      	nop			@ (mov r8, r8)
10040d86:	e7fd      	b.n	10040d84 <HardFault_Handler+0x4>

10040d88 <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
10040d88:	b580      	push	{r7, lr}
10040d8a:	af00      	add	r7, sp, #0

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
10040d8c:	46c0      	nop			@ (mov r8, r8)
10040d8e:	46bd      	mov	sp, r7
10040d90:	bd80      	pop	{r7, pc}

10040d92 <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
10040d92:	b580      	push	{r7, lr}
10040d94:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
10040d96:	46c0      	nop			@ (mov r8, r8)
10040d98:	46bd      	mov	sp, r7
10040d9a:	bd80      	pop	{r7, pc}

10040d9c <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
10040d9c:	b580      	push	{r7, lr}
10040d9e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
10040da0:	f000 fbf0 	bl	10041584 <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
10040da4:	46c0      	nop			@ (mov r8, r8)
10040da6:	46bd      	mov	sp, r7
10040da8:	bd80      	pop	{r7, pc}
	...

10040dac <USART1_IRQHandler>:

/**
  * @brief This function handles USART1 Interrupt.
  */
void USART1_IRQHandler(void)
{
10040dac:	b580      	push	{r7, lr}
10040dae:	b082      	sub	sp, #8
10040db0:	af00      	add	r7, sp, #0

  /* USER CODE END USART1_IRQn 0 */
  /* USER CODE BEGIN USART1_IRQn 1 */
  uint8_t read_data;
  /* If the RX FIFO is Not Empty */
  if(LL_USART_IsActiveFlag_RXNE(USART1) == 1) 
10040db2:	4b0c      	ldr	r3, [pc, #48]	@ (10040de4 <USART1_IRQHandler+0x38>)
10040db4:	0018      	movs	r0, r3
10040db6:	f7ff ffc2 	bl	10040d3e <LL_USART_IsActiveFlag_RXNE_RXFNE>
10040dba:	0003      	movs	r3, r0
10040dbc:	2b01      	cmp	r3, #1
10040dbe:	d10c      	bne.n	10040dda <USART1_IRQHandler+0x2e>
  {
    /* Read a byte from the RX FIFO */
    read_data = LL_USART_ReceiveData8(USART1);
10040dc0:	4b08      	ldr	r3, [pc, #32]	@ (10040de4 <USART1_IRQHandler+0x38>)
10040dc2:	0018      	movs	r0, r3
10040dc4:	f7ff ffcc 	bl	10040d60 <LL_USART_ReceiveData8>
10040dc8:	0003      	movs	r3, r0
10040dca:	001a      	movs	r2, r3
10040dcc:	1dfb      	adds	r3, r7, #7
10040dce:	701a      	strb	r2, [r3, #0]
    
    /* Send the data received to the user RX callback */
    Process_InputData(&read_data, 1);
10040dd0:	1dfb      	adds	r3, r7, #7
10040dd2:	2101      	movs	r1, #1
10040dd4:	0018      	movs	r0, r3
10040dd6:	f7ff fe95 	bl	10040b04 <Process_InputData>
  }
  /* USER CODE END USART1_IRQn 1 */
}
10040dda:	46c0      	nop			@ (mov r8, r8)
10040ddc:	46bd      	mov	sp, r7
10040dde:	b002      	add	sp, #8
10040de0:	bd80      	pop	{r7, pc}
10040de2:	46c0      	nop			@ (mov r8, r8)
10040de4:	41004000 	.word	0x41004000

10040de8 <MRSUBG_IRQHandler>:

/**
  * @brief This function handles MRSUBG interrupt.
  */
void MRSUBG_IRQHandler(void)
{
10040de8:	b580      	push	{r7, lr}
10040dea:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MRSUBG_IRQn 0 */

  /* USER CODE END MRSUBG_IRQn 0 */
  HAL_MRSubG_IRQHandler();
10040dec:	f002 f91a 	bl	10043024 <HAL_MRSubG_IRQHandler>
  /* USER CODE BEGIN MRSUBG_IRQn 1 */

  /* USER CODE END MRSUBG_IRQn 1 */
}
10040df0:	46c0      	nop			@ (mov r8, r8)
10040df2:	46bd      	mov	sp, r7
10040df4:	bd80      	pop	{r7, pc}

10040df6 <_read>:
  _kill(status, -1);
  while (1) {}    /* Make sure we hang here */
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
10040df6:	b580      	push	{r7, lr}
10040df8:	b086      	sub	sp, #24
10040dfa:	af00      	add	r7, sp, #0
10040dfc:	60f8      	str	r0, [r7, #12]
10040dfe:	60b9      	str	r1, [r7, #8]
10040e00:	607a      	str	r2, [r7, #4]
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
10040e02:	2300      	movs	r3, #0
10040e04:	617b      	str	r3, [r7, #20]
10040e06:	e00a      	b.n	10040e1e <_read+0x28>
  {
    *ptr++ = __io_getchar();
10040e08:	e000      	b.n	10040e0c <_read+0x16>
10040e0a:	bf00      	nop
10040e0c:	0001      	movs	r1, r0
10040e0e:	68bb      	ldr	r3, [r7, #8]
10040e10:	1c5a      	adds	r2, r3, #1
10040e12:	60ba      	str	r2, [r7, #8]
10040e14:	b2ca      	uxtb	r2, r1
10040e16:	701a      	strb	r2, [r3, #0]
  for (DataIdx = 0; DataIdx < len; DataIdx++)
10040e18:	697b      	ldr	r3, [r7, #20]
10040e1a:	3301      	adds	r3, #1
10040e1c:	617b      	str	r3, [r7, #20]
10040e1e:	697a      	ldr	r2, [r7, #20]
10040e20:	687b      	ldr	r3, [r7, #4]
10040e22:	429a      	cmp	r2, r3
10040e24:	dbf0      	blt.n	10040e08 <_read+0x12>
  }

  return len;
10040e26:	687b      	ldr	r3, [r7, #4]
}
10040e28:	0018      	movs	r0, r3
10040e2a:	46bd      	mov	sp, r7
10040e2c:	b006      	add	sp, #24
10040e2e:	bd80      	pop	{r7, pc}

10040e30 <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
10040e30:	b580      	push	{r7, lr}
10040e32:	b086      	sub	sp, #24
10040e34:	af00      	add	r7, sp, #0
10040e36:	60f8      	str	r0, [r7, #12]
10040e38:	60b9      	str	r1, [r7, #8]
10040e3a:	607a      	str	r2, [r7, #4]
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
10040e3c:	2300      	movs	r3, #0
10040e3e:	617b      	str	r3, [r7, #20]
10040e40:	e009      	b.n	10040e56 <_write+0x26>
  {
    __io_putchar(*ptr++);
10040e42:	68bb      	ldr	r3, [r7, #8]
10040e44:	1c5a      	adds	r2, r3, #1
10040e46:	60ba      	str	r2, [r7, #8]
10040e48:	781b      	ldrb	r3, [r3, #0]
10040e4a:	0018      	movs	r0, r3
10040e4c:	f000 f902 	bl	10041054 <__io_putchar>
  for (DataIdx = 0; DataIdx < len; DataIdx++)
10040e50:	697b      	ldr	r3, [r7, #20]
10040e52:	3301      	adds	r3, #1
10040e54:	617b      	str	r3, [r7, #20]
10040e56:	697a      	ldr	r2, [r7, #20]
10040e58:	687b      	ldr	r3, [r7, #4]
10040e5a:	429a      	cmp	r2, r3
10040e5c:	dbf1      	blt.n	10040e42 <_write+0x12>
  }
  return len;
10040e5e:	687b      	ldr	r3, [r7, #4]
}
10040e60:	0018      	movs	r0, r3
10040e62:	46bd      	mov	sp, r7
10040e64:	b006      	add	sp, #24
10040e66:	bd80      	pop	{r7, pc}

10040e68 <_close>:

int _close(int file)
{
10040e68:	b580      	push	{r7, lr}
10040e6a:	b082      	sub	sp, #8
10040e6c:	af00      	add	r7, sp, #0
10040e6e:	6078      	str	r0, [r7, #4]
  (void)file;
  return -1;
10040e70:	2301      	movs	r3, #1
10040e72:	425b      	negs	r3, r3
}
10040e74:	0018      	movs	r0, r3
10040e76:	46bd      	mov	sp, r7
10040e78:	b002      	add	sp, #8
10040e7a:	bd80      	pop	{r7, pc}

10040e7c <_fstat>:


int _fstat(int file, struct stat *st)
{
10040e7c:	b580      	push	{r7, lr}
10040e7e:	b082      	sub	sp, #8
10040e80:	af00      	add	r7, sp, #0
10040e82:	6078      	str	r0, [r7, #4]
10040e84:	6039      	str	r1, [r7, #0]
  (void)file;
  st->st_mode = S_IFCHR;
10040e86:	683b      	ldr	r3, [r7, #0]
10040e88:	2280      	movs	r2, #128	@ 0x80
10040e8a:	0192      	lsls	r2, r2, #6
10040e8c:	605a      	str	r2, [r3, #4]
  return 0;
10040e8e:	2300      	movs	r3, #0
}
10040e90:	0018      	movs	r0, r3
10040e92:	46bd      	mov	sp, r7
10040e94:	b002      	add	sp, #8
10040e96:	bd80      	pop	{r7, pc}

10040e98 <_isatty>:

int _isatty(int file)
{
10040e98:	b580      	push	{r7, lr}
10040e9a:	b082      	sub	sp, #8
10040e9c:	af00      	add	r7, sp, #0
10040e9e:	6078      	str	r0, [r7, #4]
  (void)file;
  return 1;
10040ea0:	2301      	movs	r3, #1
}
10040ea2:	0018      	movs	r0, r3
10040ea4:	46bd      	mov	sp, r7
10040ea6:	b002      	add	sp, #8
10040ea8:	bd80      	pop	{r7, pc}

10040eaa <_lseek>:

int _lseek(int file, int ptr, int dir)
{
10040eaa:	b580      	push	{r7, lr}
10040eac:	b084      	sub	sp, #16
10040eae:	af00      	add	r7, sp, #0
10040eb0:	60f8      	str	r0, [r7, #12]
10040eb2:	60b9      	str	r1, [r7, #8]
10040eb4:	607a      	str	r2, [r7, #4]
  (void)file;
  (void)ptr;
  (void)dir;
  return 0;
10040eb6:	2300      	movs	r3, #0
}
10040eb8:	0018      	movs	r0, r3
10040eba:	46bd      	mov	sp, r7
10040ebc:	b004      	add	sp, #16
10040ebe:	bd80      	pop	{r7, pc}

10040ec0 <_sbrk>:
 *
 * @param incr Memory size
 * @return Pointer to allocated memory
 */
void *_sbrk(ptrdiff_t incr)
{
10040ec0:	b580      	push	{r7, lr}
10040ec2:	b086      	sub	sp, #24
10040ec4:	af00      	add	r7, sp, #0
10040ec6:	6078      	str	r0, [r7, #4]
  extern uint8_t _end; /* Symbol defined in the linker script */
  extern uint8_t _estack; /* Symbol defined in the linker script */
  extern uint32_t _Min_Stack_Size; /* Symbol defined in the linker script */
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
10040ec8:	4a14      	ldr	r2, [pc, #80]	@ (10040f1c <_sbrk+0x5c>)
10040eca:	4b15      	ldr	r3, [pc, #84]	@ (10040f20 <_sbrk+0x60>)
10040ecc:	1ad3      	subs	r3, r2, r3
10040ece:	617b      	str	r3, [r7, #20]
  const uint8_t *max_heap = (uint8_t *)stack_limit;
10040ed0:	697b      	ldr	r3, [r7, #20]
10040ed2:	613b      	str	r3, [r7, #16]
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
10040ed4:	4b13      	ldr	r3, [pc, #76]	@ (10040f24 <_sbrk+0x64>)
10040ed6:	681b      	ldr	r3, [r3, #0]
10040ed8:	2b00      	cmp	r3, #0
10040eda:	d102      	bne.n	10040ee2 <_sbrk+0x22>
  {
    __sbrk_heap_end = &_end;
10040edc:	4b11      	ldr	r3, [pc, #68]	@ (10040f24 <_sbrk+0x64>)
10040ede:	4a12      	ldr	r2, [pc, #72]	@ (10040f28 <_sbrk+0x68>)
10040ee0:	601a      	str	r2, [r3, #0]
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
10040ee2:	4b10      	ldr	r3, [pc, #64]	@ (10040f24 <_sbrk+0x64>)
10040ee4:	681a      	ldr	r2, [r3, #0]
10040ee6:	687b      	ldr	r3, [r7, #4]
10040ee8:	18d3      	adds	r3, r2, r3
10040eea:	693a      	ldr	r2, [r7, #16]
10040eec:	429a      	cmp	r2, r3
10040eee:	d207      	bcs.n	10040f00 <_sbrk+0x40>
  {
    errno = ENOMEM;
10040ef0:	f003 fd26 	bl	10044940 <__errno>
10040ef4:	0003      	movs	r3, r0
10040ef6:	220c      	movs	r2, #12
10040ef8:	601a      	str	r2, [r3, #0]
    return (void *)-1;
10040efa:	2301      	movs	r3, #1
10040efc:	425b      	negs	r3, r3
10040efe:	e009      	b.n	10040f14 <_sbrk+0x54>
  }

  prev_heap_end = __sbrk_heap_end;
10040f00:	4b08      	ldr	r3, [pc, #32]	@ (10040f24 <_sbrk+0x64>)
10040f02:	681b      	ldr	r3, [r3, #0]
10040f04:	60fb      	str	r3, [r7, #12]
  __sbrk_heap_end += incr;
10040f06:	4b07      	ldr	r3, [pc, #28]	@ (10040f24 <_sbrk+0x64>)
10040f08:	681a      	ldr	r2, [r3, #0]
10040f0a:	687b      	ldr	r3, [r7, #4]
10040f0c:	18d2      	adds	r2, r2, r3
10040f0e:	4b05      	ldr	r3, [pc, #20]	@ (10040f24 <_sbrk+0x64>)
10040f10:	601a      	str	r2, [r3, #0]

  return (void *)prev_heap_end;
10040f12:	68fb      	ldr	r3, [r7, #12]
}
10040f14:	0018      	movs	r0, r3
10040f16:	46bd      	mov	sp, r7
10040f18:	b006      	add	sp, #24
10040f1a:	bd80      	pop	{r7, pc}
10040f1c:	20008000 	.word	0x20008000
10040f20:	00000c00 	.word	0x00000c00
10040f24:	20000498 	.word	0x20000498
10040f28:	200006f4 	.word	0x200006f4

10040f2c <LL_PWR_IsEnabledPUPDCfg>:
  * @brief  Check if pull-up and pull-down configuration is enabled
  * @rmtoll CR1          APC           LL_PWR_IsEnabledPUPDCfg
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_PWR_IsEnabledPUPDCfg(void)
{
10040f2c:	b580      	push	{r7, lr}
10040f2e:	af00      	add	r7, sp, #0
  return ((READ_BIT(PWR->CR1, PWR_CR1_APC) == (PWR_CR1_APC)) ? 1UL : 0UL);
10040f30:	4b05      	ldr	r3, [pc, #20]	@ (10040f48 <LL_PWR_IsEnabledPUPDCfg+0x1c>)
10040f32:	681b      	ldr	r3, [r3, #0]
10040f34:	2210      	movs	r2, #16
10040f36:	4013      	ands	r3, r2
10040f38:	2b10      	cmp	r3, #16
10040f3a:	d101      	bne.n	10040f40 <LL_PWR_IsEnabledPUPDCfg+0x14>
10040f3c:	2301      	movs	r3, #1
10040f3e:	e000      	b.n	10040f42 <LL_PWR_IsEnabledPUPDCfg+0x16>
10040f40:	2300      	movs	r3, #0
}
10040f42:	0018      	movs	r0, r3
10040f44:	46bd      	mov	sp, r7
10040f46:	bd80      	pop	{r7, pc}
10040f48:	48500000 	.word	0x48500000

10040f4c <LL_PWR_EnableGPIOPullUp>:
  * @retval None
  * @note   Please refer the user manual to know which IOs are able for this
  *         feature.
  */
__STATIC_INLINE void LL_PWR_EnableGPIOPullUp(uint32_t GPIO, uint32_t GPIONumber)
{
10040f4c:	b580      	push	{r7, lr}
10040f4e:	b082      	sub	sp, #8
10040f50:	af00      	add	r7, sp, #0
10040f52:	6078      	str	r0, [r7, #4]
10040f54:	6039      	str	r1, [r7, #0]
  CLEAR_BIT(*((__IO uint32_t *)(GPIO + 4UL)), GPIONumber);
10040f56:	687b      	ldr	r3, [r7, #4]
10040f58:	3304      	adds	r3, #4
10040f5a:	681a      	ldr	r2, [r3, #0]
10040f5c:	683b      	ldr	r3, [r7, #0]
10040f5e:	43d9      	mvns	r1, r3
10040f60:	687b      	ldr	r3, [r7, #4]
10040f62:	3304      	adds	r3, #4
10040f64:	400a      	ands	r2, r1
10040f66:	601a      	str	r2, [r3, #0]
  SET_BIT(*((__IO uint32_t *)GPIO), GPIONumber);
10040f68:	687b      	ldr	r3, [r7, #4]
10040f6a:	6819      	ldr	r1, [r3, #0]
10040f6c:	687b      	ldr	r3, [r7, #4]
10040f6e:	683a      	ldr	r2, [r7, #0]
10040f70:	430a      	orrs	r2, r1
10040f72:	601a      	str	r2, [r3, #0]
}
10040f74:	46c0      	nop			@ (mov r8, r8)
10040f76:	46bd      	mov	sp, r7
10040f78:	b002      	add	sp, #8
10040f7a:	bd80      	pop	{r7, pc}

10040f7c <LL_AHB1_GRP1_EnableClock>:
{
10040f7c:	b580      	push	{r7, lr}
10040f7e:	b084      	sub	sp, #16
10040f80:	af00      	add	r7, sp, #0
10040f82:	6078      	str	r0, [r7, #4]
  SET_BIT(RCC->AHBENR, Periphs);
10040f84:	4b07      	ldr	r3, [pc, #28]	@ (10040fa4 <LL_AHB1_GRP1_EnableClock+0x28>)
10040f86:	6d19      	ldr	r1, [r3, #80]	@ 0x50
10040f88:	4b06      	ldr	r3, [pc, #24]	@ (10040fa4 <LL_AHB1_GRP1_EnableClock+0x28>)
10040f8a:	687a      	ldr	r2, [r7, #4]
10040f8c:	430a      	orrs	r2, r1
10040f8e:	651a      	str	r2, [r3, #80]	@ 0x50
  tmpreg = READ_BIT(RCC->AHBENR, Periphs);
10040f90:	4b04      	ldr	r3, [pc, #16]	@ (10040fa4 <LL_AHB1_GRP1_EnableClock+0x28>)
10040f92:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
10040f94:	687a      	ldr	r2, [r7, #4]
10040f96:	4013      	ands	r3, r2
10040f98:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
10040f9a:	68fb      	ldr	r3, [r7, #12]
}
10040f9c:	46c0      	nop			@ (mov r8, r8)
10040f9e:	46bd      	mov	sp, r7
10040fa0:	b004      	add	sp, #16
10040fa2:	bd80      	pop	{r7, pc}
10040fa4:	48400000 	.word	0x48400000

10040fa8 <LL_APB1_GRP1_EnableClock>:
{
10040fa8:	b580      	push	{r7, lr}
10040faa:	b084      	sub	sp, #16
10040fac:	af00      	add	r7, sp, #0
10040fae:	6078      	str	r0, [r7, #4]
  SET_BIT(RCC->APB1ENR, Periphs);
10040fb0:	4b07      	ldr	r3, [pc, #28]	@ (10040fd0 <LL_APB1_GRP1_EnableClock+0x28>)
10040fb2:	6d99      	ldr	r1, [r3, #88]	@ 0x58
10040fb4:	4b06      	ldr	r3, [pc, #24]	@ (10040fd0 <LL_APB1_GRP1_EnableClock+0x28>)
10040fb6:	687a      	ldr	r2, [r7, #4]
10040fb8:	430a      	orrs	r2, r1
10040fba:	659a      	str	r2, [r3, #88]	@ 0x58
  tmpreg = READ_BIT(RCC->APB1ENR, Periphs);
10040fbc:	4b04      	ldr	r3, [pc, #16]	@ (10040fd0 <LL_APB1_GRP1_EnableClock+0x28>)
10040fbe:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
10040fc0:	687a      	ldr	r2, [r7, #4]
10040fc2:	4013      	ands	r3, r2
10040fc4:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
10040fc6:	68fb      	ldr	r3, [r7, #12]
}
10040fc8:	46c0      	nop			@ (mov r8, r8)
10040fca:	46bd      	mov	sp, r7
10040fcc:	b004      	add	sp, #16
10040fce:	bd80      	pop	{r7, pc}
10040fd0:	48400000 	.word	0x48400000

10040fd4 <BSP_COM_Init>:
  * @param  COM_Init Pointer to a COM_InitTypeDef structure that contains the
  *                  configuration information for the specified COM peripheral.
  * @retval BSP error code.
  */
int32_t BSP_COM_Init(COM_TypeDef COM, COM_InitTypeDef *COM_Init)
{
10040fd4:	b580      	push	{r7, lr}
10040fd6:	b084      	sub	sp, #16
10040fd8:	af00      	add	r7, sp, #0
10040fda:	0002      	movs	r2, r0
10040fdc:	6039      	str	r1, [r7, #0]
10040fde:	1dfb      	adds	r3, r7, #7
10040fe0:	701a      	strb	r2, [r3, #0]
  int32_t status = BSP_ERROR_NONE;
10040fe2:	2300      	movs	r3, #0
10040fe4:	60fb      	str	r3, [r7, #12]

  if (COM_Init == NULL)
10040fe6:	683b      	ldr	r3, [r7, #0]
10040fe8:	2b00      	cmp	r3, #0
10040fea:	d103      	bne.n	10040ff4 <BSP_COM_Init+0x20>
  {
    status = BSP_ERROR_WRONG_PARAM;
10040fec:	2302      	movs	r3, #2
10040fee:	425b      	negs	r3, r3
10040ff0:	60fb      	str	r3, [r7, #12]
10040ff2:	e026      	b.n	10041042 <BSP_COM_Init+0x6e>
  }
  else
  {
    /* Initialize COM instance */
    hcom_uart[COM].Instance = COM_UART[COM];
10040ff4:	1dfb      	adds	r3, r7, #7
10040ff6:	7819      	ldrb	r1, [r3, #0]
10040ff8:	1dfb      	adds	r3, r7, #7
10040ffa:	781a      	ldrb	r2, [r3, #0]
10040ffc:	4b13      	ldr	r3, [pc, #76]	@ (1004104c <BSP_COM_Init+0x78>)
10040ffe:	0089      	lsls	r1, r1, #2
10041000:	58c9      	ldr	r1, [r1, r3]
10041002:	4b13      	ldr	r3, [pc, #76]	@ (10041050 <BSP_COM_Init+0x7c>)
10041004:	2094      	movs	r0, #148	@ 0x94
10041006:	4342      	muls	r2, r0
10041008:	50d1      	str	r1, [r2, r3]

#if (USE_HAL_UART_REGISTER_CALLBACKS == 0)
    UART_MspInit(&hcom_uart[COM]);
1004100a:	1dfb      	adds	r3, r7, #7
1004100c:	781b      	ldrb	r3, [r3, #0]
1004100e:	2294      	movs	r2, #148	@ 0x94
10041010:	435a      	muls	r2, r3
10041012:	4b0f      	ldr	r3, [pc, #60]	@ (10041050 <BSP_COM_Init+0x7c>)
10041014:	18d3      	adds	r3, r2, r3
10041016:	0018      	movs	r0, r3
10041018:	f000 f868 	bl	100410ec <UART_MspInit>
        status = BSP_ERROR_MSP_FAILURE;
      }
    }
#endif

    if (status == BSP_ERROR_NONE)
1004101c:	68fb      	ldr	r3, [r7, #12]
1004101e:	2b00      	cmp	r3, #0
10041020:	d10f      	bne.n	10041042 <BSP_COM_Init+0x6e>
    {
      if (MX_USART1_Init(&hcom_uart[COM], COM_Init) != HAL_OK)
10041022:	1dfb      	adds	r3, r7, #7
10041024:	781b      	ldrb	r3, [r3, #0]
10041026:	2294      	movs	r2, #148	@ 0x94
10041028:	435a      	muls	r2, r3
1004102a:	4b09      	ldr	r3, [pc, #36]	@ (10041050 <BSP_COM_Init+0x7c>)
1004102c:	18d3      	adds	r3, r2, r3
1004102e:	683a      	ldr	r2, [r7, #0]
10041030:	0011      	movs	r1, r2
10041032:	0018      	movs	r0, r3
10041034:	f000 f828 	bl	10041088 <MX_USART1_Init>
10041038:	1e03      	subs	r3, r0, #0
1004103a:	d002      	beq.n	10041042 <BSP_COM_Init+0x6e>
      {
        status = BSP_ERROR_PERIPH_FAILURE;
1004103c:	2304      	movs	r3, #4
1004103e:	425b      	negs	r3, r3
10041040:	60fb      	str	r3, [r7, #12]
      }
    }
  }

  return status;
10041042:	68fb      	ldr	r3, [r7, #12]
}
10041044:	0018      	movs	r0, r3
10041046:	46bd      	mov	sp, r7
10041048:	b004      	add	sp, #16
1004104a:	bd80      	pop	{r7, pc}
1004104c:	20000684 	.word	0x20000684
10041050:	2000049c 	.word	0x2000049c

10041054 <__io_putchar>:
  return 1;
}

#elif __GNUC__
int __io_putchar(int ch)
{
10041054:	b580      	push	{r7, lr}
10041056:	b082      	sub	sp, #8
10041058:	af00      	add	r7, sp, #0
1004105a:	6078      	str	r0, [r7, #4]
  (void) HAL_UART_Transmit(&hcom_uart[COM_ActiveLogPort], (uint8_t *) &ch, 1, COM_POLL_TIMEOUT);
1004105c:	4b08      	ldr	r3, [pc, #32]	@ (10041080 <__io_putchar+0x2c>)
1004105e:	781b      	ldrb	r3, [r3, #0]
10041060:	001a      	movs	r2, r3
10041062:	2394      	movs	r3, #148	@ 0x94
10041064:	435a      	muls	r2, r3
10041066:	4b07      	ldr	r3, [pc, #28]	@ (10041084 <__io_putchar+0x30>)
10041068:	18d0      	adds	r0, r2, r3
1004106a:	23fa      	movs	r3, #250	@ 0xfa
1004106c:	009b      	lsls	r3, r3, #2
1004106e:	1d39      	adds	r1, r7, #4
10041070:	2201      	movs	r2, #1
10041072:	f002 fddb 	bl	10043c2c <HAL_UART_Transmit>
  return ch;
10041076:	687b      	ldr	r3, [r7, #4]
}
10041078:	0018      	movs	r0, r3
1004107a:	46bd      	mov	sp, r7
1004107c:	b002      	add	sp, #8
1004107e:	bd80      	pop	{r7, pc}
10041080:	20000530 	.word	0x20000530
10041084:	2000049c 	.word	0x2000049c

10041088 <MX_USART1_Init>:
  * @param  huart UART handle.
  * @param  MXInit UART initialization structure.
  * @retval HAL status.
  */
__weak HAL_StatusTypeDef MX_USART1_Init(UART_HandleTypeDef* huart, MX_UART_InitTypeDef *MXInit)
{
10041088:	b580      	push	{r7, lr}
1004108a:	b082      	sub	sp, #8
1004108c:	af00      	add	r7, sp, #0
1004108e:	6078      	str	r0, [r7, #4]
10041090:	6039      	str	r1, [r7, #0]
  /* UART configuration */
  huart->Init.BaudRate       = MXInit->BaudRate;
10041092:	683b      	ldr	r3, [r7, #0]
10041094:	681a      	ldr	r2, [r3, #0]
10041096:	687b      	ldr	r3, [r7, #4]
10041098:	605a      	str	r2, [r3, #4]
  huart->Init.WordLength     = (uint32_t) MXInit->WordLength;
1004109a:	683b      	ldr	r3, [r7, #0]
1004109c:	685a      	ldr	r2, [r3, #4]
1004109e:	687b      	ldr	r3, [r7, #4]
100410a0:	609a      	str	r2, [r3, #8]
  huart->Init.StopBits       = (uint32_t) MXInit->StopBits;
100410a2:	683b      	ldr	r3, [r7, #0]
100410a4:	891b      	ldrh	r3, [r3, #8]
100410a6:	001a      	movs	r2, r3
100410a8:	687b      	ldr	r3, [r7, #4]
100410aa:	60da      	str	r2, [r3, #12]
  huart->Init.Parity         = (uint32_t) MXInit->Parity;
100410ac:	683b      	ldr	r3, [r7, #0]
100410ae:	895b      	ldrh	r3, [r3, #10]
100410b0:	001a      	movs	r2, r3
100410b2:	687b      	ldr	r3, [r7, #4]
100410b4:	611a      	str	r2, [r3, #16]
  huart->Init.Mode           = UART_MODE_TX_RX;
100410b6:	687b      	ldr	r3, [r7, #4]
100410b8:	220c      	movs	r2, #12
100410ba:	615a      	str	r2, [r3, #20]
  huart->Init.HwFlowCtl      = (uint32_t) MXInit->HwFlowCtl;
100410bc:	683b      	ldr	r3, [r7, #0]
100410be:	899b      	ldrh	r3, [r3, #12]
100410c0:	001a      	movs	r2, r3
100410c2:	687b      	ldr	r3, [r7, #4]
100410c4:	619a      	str	r2, [r3, #24]
  huart->Init.OverSampling   = UART_OVERSAMPLING_8;
100410c6:	687b      	ldr	r3, [r7, #4]
100410c8:	2280      	movs	r2, #128	@ 0x80
100410ca:	0212      	lsls	r2, r2, #8
100410cc:	61da      	str	r2, [r3, #28]
  huart->Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
100410ce:	687b      	ldr	r3, [r7, #4]
100410d0:	2200      	movs	r2, #0
100410d2:	621a      	str	r2, [r3, #32]
  huart->Init.ClockPrescaler = UART_PRESCALER_DIV1;
100410d4:	687b      	ldr	r3, [r7, #4]
100410d6:	2200      	movs	r2, #0
100410d8:	625a      	str	r2, [r3, #36]	@ 0x24

  return HAL_UART_Init(huart);
100410da:	687b      	ldr	r3, [r7, #4]
100410dc:	0018      	movs	r0, r3
100410de:	f002 fd47 	bl	10043b70 <HAL_UART_Init>
100410e2:	0003      	movs	r3, r0
}
100410e4:	0018      	movs	r0, r3
100410e6:	46bd      	mov	sp, r7
100410e8:	b002      	add	sp, #8
100410ea:	bd80      	pop	{r7, pc}

100410ec <UART_MspInit>:
  * @brief  Initialize UART MSP.
  * @param  huart UART handle.
  * @retval None.
  */
static void UART_MspInit(UART_HandleTypeDef *huart)
{
100410ec:	b590      	push	{r4, r7, lr}
100410ee:	b089      	sub	sp, #36	@ 0x24
100410f0:	af00      	add	r7, sp, #0
100410f2:	6078      	str	r0, [r7, #4]

  /* Prevent unused argument(s) compilation warning */
  UNUSED(huart);

  /* Enable COM and GPIO clocks */
  COM1_TX_GPIO_CLK_ENABLE();
100410f4:	2004      	movs	r0, #4
100410f6:	f7ff ff41 	bl	10040f7c <LL_AHB1_GRP1_EnableClock>
  COM1_RX_GPIO_CLK_ENABLE();
100410fa:	2004      	movs	r0, #4
100410fc:	f7ff ff3e 	bl	10040f7c <LL_AHB1_GRP1_EnableClock>
  COM1_CLK_ENABLE();
10041100:	2380      	movs	r3, #128	@ 0x80
10041102:	00db      	lsls	r3, r3, #3
10041104:	0018      	movs	r0, r3
10041106:	f7ff ff4f 	bl	10040fa8 <LL_APB1_GRP1_EnableClock>

  /* Configure COM Tx as alternate function */
  GPIO_Init.Pin       = COM1_TX_PIN;
1004110a:	240c      	movs	r4, #12
1004110c:	193b      	adds	r3, r7, r4
1004110e:	2202      	movs	r2, #2
10041110:	601a      	str	r2, [r3, #0]
  GPIO_Init.Mode      = GPIO_MODE_AF_PP;
10041112:	193b      	adds	r3, r7, r4
10041114:	2202      	movs	r2, #2
10041116:	605a      	str	r2, [r3, #4]
  GPIO_Init.Speed     = GPIO_SPEED_FREQ_HIGH;
10041118:	193b      	adds	r3, r7, r4
1004111a:	2202      	movs	r2, #2
1004111c:	60da      	str	r2, [r3, #12]
  GPIO_Init.Pull      = GPIO_PULLUP;
1004111e:	193b      	adds	r3, r7, r4
10041120:	2201      	movs	r2, #1
10041122:	609a      	str	r2, [r3, #8]
  GPIO_Init.Alternate = COM1_TX_AF;
10041124:	193b      	adds	r3, r7, r4
10041126:	2201      	movs	r2, #1
10041128:	611a      	str	r2, [r3, #16]
  HAL_GPIO_Init(COM1_TX_GPIO_PORT, &GPIO_Init);
1004112a:	193a      	adds	r2, r7, r4
1004112c:	2390      	movs	r3, #144	@ 0x90
1004112e:	05db      	lsls	r3, r3, #23
10041130:	0011      	movs	r1, r2
10041132:	0018      	movs	r0, r3
10041134:	f000 fb2a 	bl	1004178c <HAL_GPIO_Init>
  if( LL_PWR_IsEnabledPUPDCfg() != 0)
10041138:	f7ff fef8 	bl	10040f2c <LL_PWR_IsEnabledPUPDCfg>
1004113c:	1e03      	subs	r3, r0, #0
1004113e:	d006      	beq.n	1004114e <UART_MspInit+0x62>
  {
    LL_PWR_EnableGPIOPullUp( LL_PWR_GPIO_A, GPIO_Init.Pin);
10041140:	193b      	adds	r3, r7, r4
10041142:	681b      	ldr	r3, [r3, #0]
10041144:	4a0b      	ldr	r2, [pc, #44]	@ (10041174 <UART_MspInit+0x88>)
10041146:	0019      	movs	r1, r3
10041148:	0010      	movs	r0, r2
1004114a:	f7ff feff 	bl	10040f4c <LL_PWR_EnableGPIOPullUp>
  }
  /* Configure COM Rx as alternate function */
  GPIO_Init.Pin       = COM1_RX_PIN;
1004114e:	210c      	movs	r1, #12
10041150:	187b      	adds	r3, r7, r1
10041152:	2280      	movs	r2, #128	@ 0x80
10041154:	0212      	lsls	r2, r2, #8
10041156:	601a      	str	r2, [r3, #0]
  GPIO_Init.Alternate = COM1_RX_AF;
10041158:	187b      	adds	r3, r7, r1
1004115a:	2201      	movs	r2, #1
1004115c:	611a      	str	r2, [r3, #16]
  HAL_GPIO_Init(COM1_RX_GPIO_PORT, &GPIO_Init);
1004115e:	187a      	adds	r2, r7, r1
10041160:	2390      	movs	r3, #144	@ 0x90
10041162:	05db      	lsls	r3, r3, #23
10041164:	0011      	movs	r1, r2
10041166:	0018      	movs	r0, r3
10041168:	f000 fb10 	bl	1004178c <HAL_GPIO_Init>
}
1004116c:	46c0      	nop			@ (mov r8, r8)
1004116e:	46bd      	mov	sp, r7
10041170:	b009      	add	sp, #36	@ 0x24
10041172:	bd90      	pop	{r4, r7, pc}
10041174:	48500020 	.word	0x48500020

10041178 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
10041178:	b590      	push	{r4, r7, lr}
1004117a:	b083      	sub	sp, #12
1004117c:	af00      	add	r7, sp, #0
1004117e:	0002      	movs	r2, r0
10041180:	6039      	str	r1, [r7, #0]
10041182:	1dfb      	adds	r3, r7, #7
10041184:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
10041186:	1dfb      	adds	r3, r7, #7
10041188:	781b      	ldrb	r3, [r3, #0]
1004118a:	2b7f      	cmp	r3, #127	@ 0x7f
1004118c:	d828      	bhi.n	100411e0 <__NVIC_SetPriority+0x68>
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
1004118e:	4a2f      	ldr	r2, [pc, #188]	@ (1004124c <__NVIC_SetPriority+0xd4>)
10041190:	1dfb      	adds	r3, r7, #7
10041192:	781b      	ldrb	r3, [r3, #0]
10041194:	b25b      	sxtb	r3, r3
10041196:	089b      	lsrs	r3, r3, #2
10041198:	33c0      	adds	r3, #192	@ 0xc0
1004119a:	009b      	lsls	r3, r3, #2
1004119c:	589b      	ldr	r3, [r3, r2]
1004119e:	1dfa      	adds	r2, r7, #7
100411a0:	7812      	ldrb	r2, [r2, #0]
100411a2:	0011      	movs	r1, r2
100411a4:	2203      	movs	r2, #3
100411a6:	400a      	ands	r2, r1
100411a8:	00d2      	lsls	r2, r2, #3
100411aa:	21ff      	movs	r1, #255	@ 0xff
100411ac:	4091      	lsls	r1, r2
100411ae:	000a      	movs	r2, r1
100411b0:	43d2      	mvns	r2, r2
100411b2:	401a      	ands	r2, r3
100411b4:	0011      	movs	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
100411b6:	683b      	ldr	r3, [r7, #0]
100411b8:	019b      	lsls	r3, r3, #6
100411ba:	22ff      	movs	r2, #255	@ 0xff
100411bc:	401a      	ands	r2, r3
100411be:	1dfb      	adds	r3, r7, #7
100411c0:	781b      	ldrb	r3, [r3, #0]
100411c2:	0018      	movs	r0, r3
100411c4:	2303      	movs	r3, #3
100411c6:	4003      	ands	r3, r0
100411c8:	00db      	lsls	r3, r3, #3
100411ca:	409a      	lsls	r2, r3
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
100411cc:	481f      	ldr	r0, [pc, #124]	@ (1004124c <__NVIC_SetPriority+0xd4>)
100411ce:	1dfb      	adds	r3, r7, #7
100411d0:	781b      	ldrb	r3, [r3, #0]
100411d2:	b25b      	sxtb	r3, r3
100411d4:	089b      	lsrs	r3, r3, #2
100411d6:	430a      	orrs	r2, r1
100411d8:	33c0      	adds	r3, #192	@ 0xc0
100411da:	009b      	lsls	r3, r3, #2
100411dc:	501a      	str	r2, [r3, r0]
  else
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
}
100411de:	e031      	b.n	10041244 <__NVIC_SetPriority+0xcc>
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
100411e0:	4a1b      	ldr	r2, [pc, #108]	@ (10041250 <__NVIC_SetPriority+0xd8>)
100411e2:	1dfb      	adds	r3, r7, #7
100411e4:	781b      	ldrb	r3, [r3, #0]
100411e6:	0019      	movs	r1, r3
100411e8:	230f      	movs	r3, #15
100411ea:	400b      	ands	r3, r1
100411ec:	3b08      	subs	r3, #8
100411ee:	089b      	lsrs	r3, r3, #2
100411f0:	3306      	adds	r3, #6
100411f2:	009b      	lsls	r3, r3, #2
100411f4:	18d3      	adds	r3, r2, r3
100411f6:	3304      	adds	r3, #4
100411f8:	681b      	ldr	r3, [r3, #0]
100411fa:	1dfa      	adds	r2, r7, #7
100411fc:	7812      	ldrb	r2, [r2, #0]
100411fe:	0011      	movs	r1, r2
10041200:	2203      	movs	r2, #3
10041202:	400a      	ands	r2, r1
10041204:	00d2      	lsls	r2, r2, #3
10041206:	21ff      	movs	r1, #255	@ 0xff
10041208:	4091      	lsls	r1, r2
1004120a:	000a      	movs	r2, r1
1004120c:	43d2      	mvns	r2, r2
1004120e:	401a      	ands	r2, r3
10041210:	0011      	movs	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
10041212:	683b      	ldr	r3, [r7, #0]
10041214:	019b      	lsls	r3, r3, #6
10041216:	22ff      	movs	r2, #255	@ 0xff
10041218:	401a      	ands	r2, r3
1004121a:	1dfb      	adds	r3, r7, #7
1004121c:	781b      	ldrb	r3, [r3, #0]
1004121e:	0018      	movs	r0, r3
10041220:	2303      	movs	r3, #3
10041222:	4003      	ands	r3, r0
10041224:	00db      	lsls	r3, r3, #3
10041226:	409a      	lsls	r2, r3
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
10041228:	4809      	ldr	r0, [pc, #36]	@ (10041250 <__NVIC_SetPriority+0xd8>)
1004122a:	1dfb      	adds	r3, r7, #7
1004122c:	781b      	ldrb	r3, [r3, #0]
1004122e:	001c      	movs	r4, r3
10041230:	230f      	movs	r3, #15
10041232:	4023      	ands	r3, r4
10041234:	3b08      	subs	r3, #8
10041236:	089b      	lsrs	r3, r3, #2
10041238:	430a      	orrs	r2, r1
1004123a:	3306      	adds	r3, #6
1004123c:	009b      	lsls	r3, r3, #2
1004123e:	18c3      	adds	r3, r0, r3
10041240:	3304      	adds	r3, #4
10041242:	601a      	str	r2, [r3, #0]
}
10041244:	46c0      	nop			@ (mov r8, r8)
10041246:	46bd      	mov	sp, r7
10041248:	b003      	add	sp, #12
1004124a:	bd90      	pop	{r4, r7, pc}
1004124c:	e000e100 	.word	0xe000e100
10041250:	e000ed00 	.word	0xe000ed00

10041254 <__NVIC_SystemReset>:
/**
  \brief   System Reset
  \details Initiates a system reset request to reset the MCU.
 */
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
10041254:	b580      	push	{r7, lr}
10041256:	af00      	add	r7, sp, #0
  __ASM volatile ("dsb 0xF":::"memory");
10041258:	f3bf 8f4f 	dsb	sy
}
1004125c:	46c0      	nop			@ (mov r8, r8)
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = ((0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
1004125e:	4b04      	ldr	r3, [pc, #16]	@ (10041270 <__NVIC_SystemReset+0x1c>)
10041260:	4a04      	ldr	r2, [pc, #16]	@ (10041274 <__NVIC_SystemReset+0x20>)
10041262:	60da      	str	r2, [r3, #12]
  __ASM volatile ("dsb 0xF":::"memory");
10041264:	f3bf 8f4f 	dsb	sy
}
10041268:	46c0      	nop			@ (mov r8, r8)
                 SCB_AIRCR_SYSRESETREQ_Msk);
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
1004126a:	46c0      	nop			@ (mov r8, r8)
1004126c:	e7fd      	b.n	1004126a <__NVIC_SystemReset+0x16>
1004126e:	46c0      	nop			@ (mov r8, r8)
10041270:	e000ed00 	.word	0xe000ed00
10041274:	05fa0004 	.word	0x05fa0004

10041278 <SystemInit>:
  * @param  None
  * @retval None
  */

void SystemInit(void)
{
10041278:	b580      	push	{r7, lr}
1004127a:	b086      	sub	sp, #24
1004127c:	af00      	add	r7, sp, #0
  uint32_t mainRegulator, smpsOutVoltage, lsiBw, hsiCalib;
  uint8_t i;
  
  /* If the reset reason is a wakeup from power save restore the context */
  if ((RCC->CSR == 0) && ((PWR->IWUF != 0) || (PWR->WUFA != 0) || (PWR->WUFB != 0)))
1004127e:	4a5e      	ldr	r2, [pc, #376]	@ (100413f8 <SystemInit+0x180>)
10041280:	2394      	movs	r3, #148	@ 0x94
10041282:	58d3      	ldr	r3, [r2, r3]
10041284:	2b00      	cmp	r3, #0
10041286:	d112      	bne.n	100412ae <SystemInit+0x36>
10041288:	4b5c      	ldr	r3, [pc, #368]	@ (100413fc <SystemInit+0x184>)
1004128a:	691b      	ldr	r3, [r3, #16]
1004128c:	2b00      	cmp	r3, #0
1004128e:	d107      	bne.n	100412a0 <SystemInit+0x28>
10041290:	4b5a      	ldr	r3, [pc, #360]	@ (100413fc <SystemInit+0x184>)
10041292:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
10041294:	2b00      	cmp	r3, #0
10041296:	d103      	bne.n	100412a0 <SystemInit+0x28>
10041298:	4b58      	ldr	r3, [pc, #352]	@ (100413fc <SystemInit+0x184>)
1004129a:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
1004129c:	2b00      	cmp	r3, #0
1004129e:	d006      	beq.n	100412ae <SystemInit+0x36>
  {
    RAM_VR.WakeupFromSleepFlag = 1; /* A wakeup from power save occurred */
100412a0:	4b57      	ldr	r3, [pc, #348]	@ (10041400 <SystemInit+0x188>)
100412a2:	2201      	movs	r2, #1
100412a4:	609a      	str	r2, [r3, #8]
    CPUcontextRestore();            /* Restore the context */
100412a6:	f000 f909 	bl	100414bc <CPUcontextRestore>
    /* if the context restore worked properly, we should never return here */
    while(1) { 
      NVIC_SystemReset(); 
100412aa:	f7ff ffd3 	bl	10041254 <__NVIC_SystemReset>

  /* Configure the Vector Table location */
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation */
#else
  SCB->VTOR = (uint32_t) (__vector_table);
100412ae:	4b55      	ldr	r3, [pc, #340]	@ (10041404 <SystemInit+0x18c>)
100412b0:	4a55      	ldr	r2, [pc, #340]	@ (10041408 <SystemInit+0x190>)
100412b2:	609a      	str	r2, [r3, #8]
#endif /* USER_VECT_TAB_ADDRESS */

  /* Store in RAM the AppBase information */
  RAM_VR.AppBase = (uint32_t) SCB->VTOR;
100412b4:	4b53      	ldr	r3, [pc, #332]	@ (10041404 <SystemInit+0x18c>)
100412b6:	689a      	ldr	r2, [r3, #8]
100412b8:	4b51      	ldr	r3, [pc, #324]	@ (10041400 <SystemInit+0x188>)
100412ba:	611a      	str	r2, [r3, #16]

  /* Enable all the RAM banks in retention during power save */
  SET_BIT(PWR->CR2, PWR_CR2_RAMRET1);
100412bc:	4b4f      	ldr	r3, [pc, #316]	@ (100413fc <SystemInit+0x184>)
100412be:	685a      	ldr	r2, [r3, #4]
100412c0:	4b4e      	ldr	r3, [pc, #312]	@ (100413fc <SystemInit+0x184>)
100412c2:	2120      	movs	r1, #32
100412c4:	430a      	orrs	r2, r1
100412c6:	605a      	str	r2, [r3, #4]

  /* Disable the GPIO retention in power save configuration */
  CLEAR_BIT(PWR->CR2, PWR_CR2_GPIORET);
100412c8:	4b4c      	ldr	r3, [pc, #304]	@ (100413fc <SystemInit+0x184>)
100412ca:	685a      	ldr	r2, [r3, #4]
100412cc:	4b4b      	ldr	r3, [pc, #300]	@ (100413fc <SystemInit+0x184>)
100412ce:	494f      	ldr	r1, [pc, #316]	@ (1004140c <SystemInit+0x194>)
100412d0:	400a      	ands	r2, r1
100412d2:	605a      	str	r2, [r3, #4]
   
  /* SMPS setup */
  if ((CFG_HW_SMPS == SMPS_ON) || (CFG_HW_SMPS == SMPS_STATIC_BOF) || (CFG_HW_SMPS == SMPS_DYNAMIC_BOF))
  {
    while(READ_BIT(PWR->SR2, PWR_SR2_SMPSRDY) != PWR_SR2_SMPSRDY); // Wait until SMPS is ready
100412d4:	46c0      	nop			@ (mov r8, r8)
100412d6:	4b49      	ldr	r3, [pc, #292]	@ (100413fc <SystemInit+0x184>)
100412d8:	695b      	ldr	r3, [r3, #20]
100412da:	2204      	movs	r2, #4
100412dc:	4013      	ands	r3, r2
100412de:	2b04      	cmp	r3, #4
100412e0:	d1f9      	bne.n	100412d6 <SystemInit+0x5e>
    MODIFY_REG(PWR->CR5, PWR_CR5_SMPSBOMSEL, (CFG_HW_SMPS_BOM<<PWR_CR5_SMPSBOMSEL_Pos)); // Configure the SMPS BOM
100412e2:	4b46      	ldr	r3, [pc, #280]	@ (100413fc <SystemInit+0x184>)
100412e4:	69db      	ldr	r3, [r3, #28]
100412e6:	2230      	movs	r2, #48	@ 0x30
100412e8:	4393      	bics	r3, r2
100412ea:	001a      	movs	r2, r3
100412ec:	4b43      	ldr	r3, [pc, #268]	@ (100413fc <SystemInit+0x184>)
100412ee:	2120      	movs	r1, #32
100412f0:	430a      	orrs	r2, r1
100412f2:	61da      	str	r2, [r3, #28]
  }
  if ((CFG_HW_SMPS == SMPS_ON) || (CFG_HW_SMPS == SMPS_OFF))
  {
    MODIFY_REG(PWR->CR5, PWR_CR5_NOSMPS, (CFG_HW_SMPS<<PWR_CR5_NOSMPS_Pos)); // SMPS ON/OFF Configuration
100412f4:	4b41      	ldr	r3, [pc, #260]	@ (100413fc <SystemInit+0x184>)
100412f6:	69da      	ldr	r2, [r3, #28]
100412f8:	4b40      	ldr	r3, [pc, #256]	@ (100413fc <SystemInit+0x184>)
100412fa:	4945      	ldr	r1, [pc, #276]	@ (10041410 <SystemInit+0x198>)
100412fc:	400a      	ands	r2, r1
100412fe:	61da      	str	r2, [r3, #28]
    /* The SMPS output voltage level and SMPS BOF tuning are set to 1.4V by default */
    SET_BIT(PWR->CR5, PWR_CR5_NOSMPS_BOF);
    CLEAR_BIT(PWR->CR5, PWR_CR5_SMPS_BOF_STATIC);
    SET_BIT(PWR->CR5, PWR_CR5_SMPS_BOF_DYN);
  }
  MODIFY_REG(PWR->CR5, PWR_CR5_SMPSLPOPEN, (CFG_HW_SMPS_LOW_POWER<<PWR_CR5_SMPSLPOPEN_Pos)); // SMPS configuration during power save
10041300:	4b3e      	ldr	r3, [pc, #248]	@ (100413fc <SystemInit+0x184>)
10041302:	69da      	ldr	r2, [r3, #28]
10041304:	4b3d      	ldr	r3, [pc, #244]	@ (100413fc <SystemInit+0x184>)
10041306:	2180      	movs	r1, #128	@ 0x80
10041308:	0049      	lsls	r1, r1, #1
1004130a:	430a      	orrs	r2, r1
1004130c:	61da      	str	r2, [r3, #28]
  
  /* If Trimming values from engineering in flash locations are not present load default values */
  if (*(volatile uint32_t*)VALIDITY_LOCATION != VALIDITY_TAG)
1004130e:	4b41      	ldr	r3, [pc, #260]	@ (10041414 <SystemInit+0x19c>)
10041310:	681b      	ldr	r3, [r3, #0]
10041312:	4a41      	ldr	r2, [pc, #260]	@ (10041418 <SystemInit+0x1a0>)
10041314:	4293      	cmp	r3, r2
10041316:	d055      	beq.n	100413c4 <SystemInit+0x14c>
  {
    hsiCalib       = 0x21;
10041318:	2321      	movs	r3, #33	@ 0x21
1004131a:	617b      	str	r3, [r7, #20]
    lsiBw          = 8;
1004131c:	2308      	movs	r3, #8
1004131e:	613b      	str	r3, [r7, #16]
    mainRegulator  = 0x03;
10041320:	2303      	movs	r3, #3
10041322:	60fb      	str	r3, [r7, #12]
    smpsOutVoltage = 0x03;
10041324:	2303      	movs	r3, #3
10041326:	60bb      	str	r3, [r7, #8]
    
    /* Set HSI Calibration Trimming value */
    MODIFY_REG(RCC->CSSWCR, RCC_CSSWCR_HSITRIMSW, hsiCalib << RCC_CSSWCR_HSITRIMSW_Pos);
10041328:	4b33      	ldr	r3, [pc, #204]	@ (100413f8 <SystemInit+0x180>)
1004132a:	68db      	ldr	r3, [r3, #12]
1004132c:	4a3b      	ldr	r2, [pc, #236]	@ (1004141c <SystemInit+0x1a4>)
1004132e:	4013      	ands	r3, r2
10041330:	0019      	movs	r1, r3
10041332:	697b      	ldr	r3, [r7, #20]
10041334:	061a      	lsls	r2, r3, #24
10041336:	4b30      	ldr	r3, [pc, #192]	@ (100413f8 <SystemInit+0x180>)
10041338:	430a      	orrs	r2, r1
1004133a:	60da      	str	r2, [r3, #12]
    SET_BIT(RCC->CSSWCR, RCC_CSSWCR_HSISWTRIMEN);
1004133c:	4b2e      	ldr	r3, [pc, #184]	@ (100413f8 <SystemInit+0x180>)
1004133e:	68da      	ldr	r2, [r3, #12]
10041340:	4b2d      	ldr	r3, [pc, #180]	@ (100413f8 <SystemInit+0x180>)
10041342:	2180      	movs	r1, #128	@ 0x80
10041344:	0409      	lsls	r1, r1, #16
10041346:	430a      	orrs	r2, r1
10041348:	60da      	str	r2, [r3, #12]

    /* Low speed internal RC trimming value set by software */
    MODIFY_REG(RCC->CSSWCR, RCC_CSSWCR_LSISWBW, lsiBw << RCC_CSSWCR_LSISWBW_Pos);
1004134a:	4b2b      	ldr	r3, [pc, #172]	@ (100413f8 <SystemInit+0x180>)
1004134c:	68db      	ldr	r3, [r3, #12]
1004134e:	221e      	movs	r2, #30
10041350:	4393      	bics	r3, r2
10041352:	0019      	movs	r1, r3
10041354:	693b      	ldr	r3, [r7, #16]
10041356:	005a      	lsls	r2, r3, #1
10041358:	4b27      	ldr	r3, [pc, #156]	@ (100413f8 <SystemInit+0x180>)
1004135a:	430a      	orrs	r2, r1
1004135c:	60da      	str	r2, [r3, #12]
    SET_BIT(RCC->CSSWCR, RCC_CSSWCR_LSISWTRIMEN);
1004135e:	4b26      	ldr	r3, [pc, #152]	@ (100413f8 <SystemInit+0x180>)
10041360:	68da      	ldr	r2, [r3, #12]
10041362:	4b25      	ldr	r3, [pc, #148]	@ (100413f8 <SystemInit+0x180>)
10041364:	2101      	movs	r1, #1
10041366:	430a      	orrs	r2, r1
10041368:	60da      	str	r2, [r3, #12]
              
    /* Set Main Regulator voltage Trimming value */ 
    MODIFY_REG(PWR->ENGTRIM, PWR_ENGTRIM_TRIM_MR, ((mainRegulator << PWR_ENGTRIM_TRIM_MR_Pos) & PWR_ENGTRIM_TRIM_MR));
1004136a:	4a24      	ldr	r2, [pc, #144]	@ (100413fc <SystemInit+0x184>)
1004136c:	2394      	movs	r3, #148	@ 0x94
1004136e:	58d3      	ldr	r3, [r2, r3]
10041370:	4a2b      	ldr	r2, [pc, #172]	@ (10041420 <SystemInit+0x1a8>)
10041372:	401a      	ands	r2, r3
10041374:	68fb      	ldr	r3, [r7, #12]
10041376:	0199      	lsls	r1, r3, #6
10041378:	23f0      	movs	r3, #240	@ 0xf0
1004137a:	009b      	lsls	r3, r3, #2
1004137c:	400b      	ands	r3, r1
1004137e:	491f      	ldr	r1, [pc, #124]	@ (100413fc <SystemInit+0x184>)
10041380:	4313      	orrs	r3, r2
10041382:	2294      	movs	r2, #148	@ 0x94
10041384:	508b      	str	r3, [r1, r2]
    SET_BIT(PWR->ENGTRIM, PWR_ENGTRIM_TRIMMREN);
10041386:	4a1d      	ldr	r2, [pc, #116]	@ (100413fc <SystemInit+0x184>)
10041388:	2394      	movs	r3, #148	@ 0x94
1004138a:	58d3      	ldr	r3, [r2, r3]
1004138c:	491b      	ldr	r1, [pc, #108]	@ (100413fc <SystemInit+0x184>)
1004138e:	2220      	movs	r2, #32
10041390:	4313      	orrs	r3, r2
10041392:	2294      	movs	r2, #148	@ 0x94
10041394:	508b      	str	r3, [r1, r2]

    /* Set SMPS output voltage Trimming value */
    MODIFY_REG(PWR->ENGTRIM, PWR_ENGTRIM_SMPS_TRIM, ((smpsOutVoltage << PWR_ENGTRIM_SMPS_TRIM_Pos) & PWR_ENGTRIM_SMPS_TRIM));
10041396:	4a19      	ldr	r2, [pc, #100]	@ (100413fc <SystemInit+0x184>)
10041398:	2394      	movs	r3, #148	@ 0x94
1004139a:	58d3      	ldr	r3, [r2, r3]
1004139c:	4a21      	ldr	r2, [pc, #132]	@ (10041424 <SystemInit+0x1ac>)
1004139e:	401a      	ands	r2, r3
100413a0:	68bb      	ldr	r3, [r7, #8]
100413a2:	02d9      	lsls	r1, r3, #11
100413a4:	23e0      	movs	r3, #224	@ 0xe0
100413a6:	019b      	lsls	r3, r3, #6
100413a8:	400b      	ands	r3, r1
100413aa:	4914      	ldr	r1, [pc, #80]	@ (100413fc <SystemInit+0x184>)
100413ac:	4313      	orrs	r3, r2
100413ae:	2294      	movs	r2, #148	@ 0x94
100413b0:	508b      	str	r3, [r1, r2]
    SET_BIT(PWR->ENGTRIM, PWR_ENGTRIM_SMPSTRIMEN);    
100413b2:	4a12      	ldr	r2, [pc, #72]	@ (100413fc <SystemInit+0x184>)
100413b4:	2394      	movs	r3, #148	@ 0x94
100413b6:	58d3      	ldr	r3, [r2, r3]
100413b8:	4910      	ldr	r1, [pc, #64]	@ (100413fc <SystemInit+0x184>)
100413ba:	2280      	movs	r2, #128	@ 0x80
100413bc:	00d2      	lsls	r2, r2, #3
100413be:	4313      	orrs	r3, r2
100413c0:	2294      	movs	r2, #148	@ 0x94
100413c2:	508b      	str	r3, [r1, r2]
  }

  /* Set all the interrupt with low priprity */
  for (i=0; i<32; i++)
100413c4:	1dfb      	adds	r3, r7, #7
100413c6:	2200      	movs	r2, #0
100413c8:	701a      	strb	r2, [r3, #0]
100413ca:	e00b      	b.n	100413e4 <SystemInit+0x16c>
  {
    NVIC_SetPriority((IRQn_Type)i, IRQ_LOW_PRIORITY);
100413cc:	1dfb      	adds	r3, r7, #7
100413ce:	781b      	ldrb	r3, [r3, #0]
100413d0:	b25b      	sxtb	r3, r3
100413d2:	2103      	movs	r1, #3
100413d4:	0018      	movs	r0, r3
100413d6:	f7ff fecf 	bl	10041178 <__NVIC_SetPriority>
  for (i=0; i<32; i++)
100413da:	1dfb      	adds	r3, r7, #7
100413dc:	781a      	ldrb	r2, [r3, #0]
100413de:	1dfb      	adds	r3, r7, #7
100413e0:	3201      	adds	r2, #1
100413e2:	701a      	strb	r2, [r3, #0]
100413e4:	1dfb      	adds	r3, r7, #7
100413e6:	781b      	ldrb	r3, [r3, #0]
100413e8:	2b1f      	cmp	r3, #31
100413ea:	d9ef      	bls.n	100413cc <SystemInit+0x154>
  __ASM volatile ("cpsie i" : : : "memory");
100413ec:	b662      	cpsie	i
}
100413ee:	46c0      	nop			@ (mov r8, r8)
  }
  
  /* Enable all the irqs */
  __enable_irq();
}
100413f0:	46c0      	nop			@ (mov r8, r8)
100413f2:	46bd      	mov	sp, r7
100413f4:	b006      	add	sp, #24
100413f6:	bd80      	pop	{r7, pc}
100413f8:	48400000 	.word	0x48400000
100413fc:	48500000 	.word	0x48500000
10041400:	20000004 	.word	0x20000004
10041404:	e000ed00 	.word	0xe000ed00
10041408:	10040000 	.word	0x10040000
1004140c:	fffffeff 	.word	0xfffffeff
10041410:	fffffbff 	.word	0xfffffbff
10041414:	10001ef8 	.word	0x10001ef8
10041418:	fcbceccc 	.word	0xfcbceccc
1004141c:	c0ffffff 	.word	0xc0ffffff
10041420:	fffffc3f 	.word	0xfffffc3f
10041424:	ffffc7ff 	.word	0xffffc7ff

10041428 <SystemCoreClockUpdate>:
  *
  * @param  None
  * @retval None
  */
void SystemCoreClockUpdate(void)
{
10041428:	b580      	push	{r7, lr}
1004142a:	b082      	sub	sp, #8
1004142c:	af00      	add	r7, sp, #0
  uint8_t directHSE_enabled;
  uint8_t divPrescaler;

  /* Get SYSCLK source HSE or HSI+PLL64MHz */
  directHSE_enabled = (RCC->CFGR & RCC_CFGR_HSESEL) >> RCC_CFGR_HSESEL_Pos;
1004142e:	4b1e      	ldr	r3, [pc, #120]	@ (100414a8 <SystemCoreClockUpdate+0x80>)
10041430:	689b      	ldr	r3, [r3, #8]
10041432:	085b      	lsrs	r3, r3, #1
10041434:	b2da      	uxtb	r2, r3
10041436:	1dfb      	adds	r3, r7, #7
10041438:	2101      	movs	r1, #1
1004143a:	400a      	ands	r2, r1
1004143c:	701a      	strb	r2, [r3, #0]

  /* Get the clock divider */
  divPrescaler = (RCC->CFGR & RCC_CFGR_CLKSYSDIV_STATUS) >> RCC_CFGR_CLKSYSDIV_STATUS_Pos;
1004143e:	4b1a      	ldr	r3, [pc, #104]	@ (100414a8 <SystemCoreClockUpdate+0x80>)
10041440:	689b      	ldr	r3, [r3, #8]
10041442:	0a1b      	lsrs	r3, r3, #8
10041444:	b2da      	uxtb	r2, r3
10041446:	1dbb      	adds	r3, r7, #6
10041448:	2107      	movs	r1, #7
1004144a:	400a      	ands	r2, r1
1004144c:	701a      	strb	r2, [r3, #0]
    
  if (directHSE_enabled)
1004144e:	1dfb      	adds	r3, r7, #7
10041450:	781b      	ldrb	r3, [r3, #0]
10041452:	2b00      	cmp	r3, #0
10041454:	d01d      	beq.n	10041492 <SystemCoreClockUpdate+0x6a>
  {
    switch(divPrescaler)
10041456:	1dbb      	adds	r3, r7, #6
10041458:	781b      	ldrb	r3, [r3, #0]
1004145a:	2b00      	cmp	r3, #0
1004145c:	d002      	beq.n	10041464 <SystemCoreClockUpdate+0x3c>
1004145e:	2b01      	cmp	r3, #1
10041460:	d004      	beq.n	1004146c <SystemCoreClockUpdate+0x44>
10041462:	e007      	b.n	10041474 <SystemCoreClockUpdate+0x4c>
    {
    case 0:
      SystemCoreClock = HSE_VALUE;
10041464:	4b11      	ldr	r3, [pc, #68]	@ (100414ac <SystemCoreClockUpdate+0x84>)
10041466:	4a12      	ldr	r2, [pc, #72]	@ (100414b0 <SystemCoreClockUpdate+0x88>)
10041468:	601a      	str	r2, [r3, #0]
      break;
1004146a:	e019      	b.n	100414a0 <SystemCoreClockUpdate+0x78>
    case 1:
      SystemCoreClock = HSE_VALUE/2;
1004146c:	4b0f      	ldr	r3, [pc, #60]	@ (100414ac <SystemCoreClockUpdate+0x84>)
1004146e:	4a11      	ldr	r2, [pc, #68]	@ (100414b4 <SystemCoreClockUpdate+0x8c>)
10041470:	601a      	str	r2, [r3, #0]
      break;
10041472:	e015      	b.n	100414a0 <SystemCoreClockUpdate+0x78>
    default:
      SystemCoreClock = HSE_VALUE/(3*(1<<(divPrescaler-2)));
10041474:	1dbb      	adds	r3, r7, #6
10041476:	781b      	ldrb	r3, [r3, #0]
10041478:	3b02      	subs	r3, #2
1004147a:	2203      	movs	r2, #3
1004147c:	409a      	lsls	r2, r3
1004147e:	0013      	movs	r3, r2
10041480:	0019      	movs	r1, r3
10041482:	480b      	ldr	r0, [pc, #44]	@ (100414b0 <SystemCoreClockUpdate+0x88>)
10041484:	f7fe fe26 	bl	100400d4 <__udivsi3>
10041488:	0003      	movs	r3, r0
1004148a:	001a      	movs	r2, r3
1004148c:	4b07      	ldr	r3, [pc, #28]	@ (100414ac <SystemCoreClockUpdate+0x84>)
1004148e:	601a      	str	r2, [r3, #0]
      break;
10041490:	e006      	b.n	100414a0 <SystemCoreClockUpdate+0x78>
    }
  }
  else
  {
    SystemCoreClock = HSI_VALUE >> divPrescaler;
10041492:	1dbb      	adds	r3, r7, #6
10041494:	781b      	ldrb	r3, [r3, #0]
10041496:	4a08      	ldr	r2, [pc, #32]	@ (100414b8 <SystemCoreClockUpdate+0x90>)
10041498:	40da      	lsrs	r2, r3
1004149a:	4b04      	ldr	r3, [pc, #16]	@ (100414ac <SystemCoreClockUpdate+0x84>)
1004149c:	601a      	str	r2, [r3, #0]
  }  
}
1004149e:	46c0      	nop			@ (mov r8, r8)
100414a0:	46c0      	nop			@ (mov r8, r8)
100414a2:	46bd      	mov	sp, r7
100414a4:	b002      	add	sp, #8
100414a6:	bd80      	pop	{r7, pc}
100414a8:	48400000 	.word	0x48400000
100414ac:	20000688 	.word	0x20000688
100414b0:	02dc6c00 	.word	0x02dc6c00
100414b4:	016e3600 	.word	0x016e3600
100414b8:	03d09000 	.word	0x03d09000

100414bc <CPUcontextRestore>:
  *         by popping it from the stack 
  * @param  None
  * @retval None
  */
__WEAK void CPUcontextRestore(void)
{
100414bc:	b580      	push	{r7, lr}
100414be:	af00      	add	r7, sp, #0
}
100414c0:	46c0      	nop			@ (mov r8, r8)
100414c2:	46bd      	mov	sp, r7
100414c4:	bd80      	pop	{r7, pc}

100414c6 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
100414c6:	b580      	push	{r7, lr}
100414c8:	b082      	sub	sp, #8
100414ca:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef  status = HAL_OK;
100414cc:	1dfb      	adds	r3, r7, #7
100414ce:	2200      	movs	r2, #0
100414d0:	701a      	strb	r2, [r3, #0]

  /* Use SysTick as time base source and configure 1ms tick (default clock after Reset is MSI) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
100414d2:	2003      	movs	r0, #3
100414d4:	f000 f80e 	bl	100414f4 <HAL_InitTick>
100414d8:	1e03      	subs	r3, r0, #0
100414da:	d003      	beq.n	100414e4 <HAL_Init+0x1e>
  {
    status = HAL_ERROR;
100414dc:	1dfb      	adds	r3, r7, #7
100414de:	2201      	movs	r2, #1
100414e0:	701a      	strb	r2, [r3, #0]
100414e2:	e001      	b.n	100414e8 <HAL_Init+0x22>
  }
  else
  {
    /* Init the low level hardware */
    HAL_MspInit();
100414e4:	f7ff fbee 	bl	10040cc4 <HAL_MspInit>
  }

  /* Return function status */
  return status;
100414e8:	1dfb      	adds	r3, r7, #7
100414ea:	781b      	ldrb	r3, [r3, #0]
}
100414ec:	0018      	movs	r0, r3
100414ee:	46bd      	mov	sp, r7
100414f0:	b002      	add	sp, #8
100414f2:	bd80      	pop	{r7, pc}

100414f4 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
100414f4:	b590      	push	{r4, r7, lr}
100414f6:	b085      	sub	sp, #20
100414f8:	af00      	add	r7, sp, #0
100414fa:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef  status = HAL_OK;
100414fc:	230f      	movs	r3, #15
100414fe:	18fb      	adds	r3, r7, r3
10041500:	2200      	movs	r2, #0
10041502:	701a      	strb	r2, [r3, #0]

  if (uwTickFreq != 0U)
10041504:	4b1d      	ldr	r3, [pc, #116]	@ (1004157c <HAL_InitTick+0x88>)
10041506:	781b      	ldrb	r3, [r3, #0]
10041508:	2b00      	cmp	r3, #0
1004150a:	d02c      	beq.n	10041566 <HAL_InitTick+0x72>
  {
    /*Configure the SysTick to have interrupt in 1ms time basis*/
    if (HAL_SYSTICK_Config(HAL_RCC_GetSysClockFreq() / (1000U / uwTickFreq)) == 0U)
1004150c:	f002 f996 	bl	1004383c <HAL_RCC_GetSysClockFreq>
10041510:	0004      	movs	r4, r0
10041512:	4b1a      	ldr	r3, [pc, #104]	@ (1004157c <HAL_InitTick+0x88>)
10041514:	781b      	ldrb	r3, [r3, #0]
10041516:	0019      	movs	r1, r3
10041518:	23fa      	movs	r3, #250	@ 0xfa
1004151a:	0098      	lsls	r0, r3, #2
1004151c:	f7fe fdda 	bl	100400d4 <__udivsi3>
10041520:	0003      	movs	r3, r0
10041522:	0019      	movs	r1, r3
10041524:	0020      	movs	r0, r4
10041526:	f7fe fdd5 	bl	100400d4 <__udivsi3>
1004152a:	0003      	movs	r3, r0
1004152c:	0018      	movs	r0, r3
1004152e:	f000 f920 	bl	10041772 <HAL_SYSTICK_Config>
10041532:	1e03      	subs	r3, r0, #0
10041534:	d112      	bne.n	1004155c <HAL_InitTick+0x68>
    {
      /* Configure the SysTick IRQ priority */
      if (TickPriority < (1UL << __NVIC_PRIO_BITS))
10041536:	687b      	ldr	r3, [r7, #4]
10041538:	2b03      	cmp	r3, #3
1004153a:	d80a      	bhi.n	10041552 <HAL_InitTick+0x5e>
      {
        HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0);
1004153c:	6879      	ldr	r1, [r7, #4]
1004153e:	2301      	movs	r3, #1
10041540:	425b      	negs	r3, r3
10041542:	2200      	movs	r2, #0
10041544:	0018      	movs	r0, r3
10041546:	f000 f8ef 	bl	10041728 <HAL_NVIC_SetPriority>
        uwTickPrio = TickPriority;
1004154a:	4b0d      	ldr	r3, [pc, #52]	@ (10041580 <HAL_InitTick+0x8c>)
1004154c:	687a      	ldr	r2, [r7, #4]
1004154e:	601a      	str	r2, [r3, #0]
10041550:	e00d      	b.n	1004156e <HAL_InitTick+0x7a>
      }
      else
      {
        status = HAL_ERROR;
10041552:	230f      	movs	r3, #15
10041554:	18fb      	adds	r3, r7, r3
10041556:	2201      	movs	r2, #1
10041558:	701a      	strb	r2, [r3, #0]
1004155a:	e008      	b.n	1004156e <HAL_InitTick+0x7a>
      }
    }
    else
    {
      status = HAL_ERROR;
1004155c:	230f      	movs	r3, #15
1004155e:	18fb      	adds	r3, r7, r3
10041560:	2201      	movs	r2, #1
10041562:	701a      	strb	r2, [r3, #0]
10041564:	e003      	b.n	1004156e <HAL_InitTick+0x7a>
    }
  }
  else
  {
    status = HAL_ERROR;
10041566:	230f      	movs	r3, #15
10041568:	18fb      	adds	r3, r7, r3
1004156a:	2201      	movs	r2, #1
1004156c:	701a      	strb	r2, [r3, #0]
  }

  /* Return function status */
  return status;
1004156e:	230f      	movs	r3, #15
10041570:	18fb      	adds	r3, r7, r3
10041572:	781b      	ldrb	r3, [r3, #0]
}
10041574:	0018      	movs	r0, r3
10041576:	46bd      	mov	sp, r7
10041578:	b005      	add	sp, #20
1004157a:	bd90      	pop	{r4, r7, pc}
1004157c:	20000694 	.word	0x20000694
10041580:	20000690 	.word	0x20000690

10041584 <HAL_IncTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
10041584:	b580      	push	{r7, lr}
10041586:	af00      	add	r7, sp, #0
  uwTick += (uint32_t)uwTickFreq;
10041588:	4b05      	ldr	r3, [pc, #20]	@ (100415a0 <HAL_IncTick+0x1c>)
1004158a:	781b      	ldrb	r3, [r3, #0]
1004158c:	001a      	movs	r2, r3
1004158e:	4b05      	ldr	r3, [pc, #20]	@ (100415a4 <HAL_IncTick+0x20>)
10041590:	681b      	ldr	r3, [r3, #0]
10041592:	18d2      	adds	r2, r2, r3
10041594:	4b03      	ldr	r3, [pc, #12]	@ (100415a4 <HAL_IncTick+0x20>)
10041596:	601a      	str	r2, [r3, #0]
}
10041598:	46c0      	nop			@ (mov r8, r8)
1004159a:	46bd      	mov	sp, r7
1004159c:	bd80      	pop	{r7, pc}
1004159e:	46c0      	nop			@ (mov r8, r8)
100415a0:	20000694 	.word	0x20000694
100415a4:	20000534 	.word	0x20000534

100415a8 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
100415a8:	b580      	push	{r7, lr}
100415aa:	af00      	add	r7, sp, #0
  return uwTick;
100415ac:	4b02      	ldr	r3, [pc, #8]	@ (100415b8 <HAL_GetTick+0x10>)
100415ae:	681b      	ldr	r3, [r3, #0]
}
100415b0:	0018      	movs	r0, r3
100415b2:	46bd      	mov	sp, r7
100415b4:	bd80      	pop	{r7, pc}
100415b6:	46c0      	nop			@ (mov r8, r8)
100415b8:	20000534 	.word	0x20000534

100415bc <HAL_GetTickPrio>:
/**
  * @brief This function returns a tick priority.
  * @retval tick priority
  */
uint32_t HAL_GetTickPrio(void)
{
100415bc:	b580      	push	{r7, lr}
100415be:	af00      	add	r7, sp, #0
  return uwTickPrio;
100415c0:	4b02      	ldr	r3, [pc, #8]	@ (100415cc <HAL_GetTickPrio+0x10>)
100415c2:	681b      	ldr	r3, [r3, #0]
}
100415c4:	0018      	movs	r0, r3
100415c6:	46bd      	mov	sp, r7
100415c8:	bd80      	pop	{r7, pc}
100415ca:	46c0      	nop			@ (mov r8, r8)
100415cc:	20000690 	.word	0x20000690

100415d0 <__NVIC_EnableIRQ>:
{
100415d0:	b580      	push	{r7, lr}
100415d2:	b082      	sub	sp, #8
100415d4:	af00      	add	r7, sp, #0
100415d6:	0002      	movs	r2, r0
100415d8:	1dfb      	adds	r3, r7, #7
100415da:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
100415dc:	1dfb      	adds	r3, r7, #7
100415de:	781b      	ldrb	r3, [r3, #0]
100415e0:	2b7f      	cmp	r3, #127	@ 0x7f
100415e2:	d809      	bhi.n	100415f8 <__NVIC_EnableIRQ+0x28>
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
100415e4:	1dfb      	adds	r3, r7, #7
100415e6:	781b      	ldrb	r3, [r3, #0]
100415e8:	001a      	movs	r2, r3
100415ea:	231f      	movs	r3, #31
100415ec:	401a      	ands	r2, r3
100415ee:	4b04      	ldr	r3, [pc, #16]	@ (10041600 <__NVIC_EnableIRQ+0x30>)
100415f0:	2101      	movs	r1, #1
100415f2:	4091      	lsls	r1, r2
100415f4:	000a      	movs	r2, r1
100415f6:	601a      	str	r2, [r3, #0]
}
100415f8:	46c0      	nop			@ (mov r8, r8)
100415fa:	46bd      	mov	sp, r7
100415fc:	b002      	add	sp, #8
100415fe:	bd80      	pop	{r7, pc}
10041600:	e000e100 	.word	0xe000e100

10041604 <__NVIC_SetPriority>:
{
10041604:	b590      	push	{r4, r7, lr}
10041606:	b083      	sub	sp, #12
10041608:	af00      	add	r7, sp, #0
1004160a:	0002      	movs	r2, r0
1004160c:	6039      	str	r1, [r7, #0]
1004160e:	1dfb      	adds	r3, r7, #7
10041610:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
10041612:	1dfb      	adds	r3, r7, #7
10041614:	781b      	ldrb	r3, [r3, #0]
10041616:	2b7f      	cmp	r3, #127	@ 0x7f
10041618:	d828      	bhi.n	1004166c <__NVIC_SetPriority+0x68>
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
1004161a:	4a2f      	ldr	r2, [pc, #188]	@ (100416d8 <__NVIC_SetPriority+0xd4>)
1004161c:	1dfb      	adds	r3, r7, #7
1004161e:	781b      	ldrb	r3, [r3, #0]
10041620:	b25b      	sxtb	r3, r3
10041622:	089b      	lsrs	r3, r3, #2
10041624:	33c0      	adds	r3, #192	@ 0xc0
10041626:	009b      	lsls	r3, r3, #2
10041628:	589b      	ldr	r3, [r3, r2]
1004162a:	1dfa      	adds	r2, r7, #7
1004162c:	7812      	ldrb	r2, [r2, #0]
1004162e:	0011      	movs	r1, r2
10041630:	2203      	movs	r2, #3
10041632:	400a      	ands	r2, r1
10041634:	00d2      	lsls	r2, r2, #3
10041636:	21ff      	movs	r1, #255	@ 0xff
10041638:	4091      	lsls	r1, r2
1004163a:	000a      	movs	r2, r1
1004163c:	43d2      	mvns	r2, r2
1004163e:	401a      	ands	r2, r3
10041640:	0011      	movs	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
10041642:	683b      	ldr	r3, [r7, #0]
10041644:	019b      	lsls	r3, r3, #6
10041646:	22ff      	movs	r2, #255	@ 0xff
10041648:	401a      	ands	r2, r3
1004164a:	1dfb      	adds	r3, r7, #7
1004164c:	781b      	ldrb	r3, [r3, #0]
1004164e:	0018      	movs	r0, r3
10041650:	2303      	movs	r3, #3
10041652:	4003      	ands	r3, r0
10041654:	00db      	lsls	r3, r3, #3
10041656:	409a      	lsls	r2, r3
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
10041658:	481f      	ldr	r0, [pc, #124]	@ (100416d8 <__NVIC_SetPriority+0xd4>)
1004165a:	1dfb      	adds	r3, r7, #7
1004165c:	781b      	ldrb	r3, [r3, #0]
1004165e:	b25b      	sxtb	r3, r3
10041660:	089b      	lsrs	r3, r3, #2
10041662:	430a      	orrs	r2, r1
10041664:	33c0      	adds	r3, #192	@ 0xc0
10041666:	009b      	lsls	r3, r3, #2
10041668:	501a      	str	r2, [r3, r0]
}
1004166a:	e031      	b.n	100416d0 <__NVIC_SetPriority+0xcc>
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
1004166c:	4a1b      	ldr	r2, [pc, #108]	@ (100416dc <__NVIC_SetPriority+0xd8>)
1004166e:	1dfb      	adds	r3, r7, #7
10041670:	781b      	ldrb	r3, [r3, #0]
10041672:	0019      	movs	r1, r3
10041674:	230f      	movs	r3, #15
10041676:	400b      	ands	r3, r1
10041678:	3b08      	subs	r3, #8
1004167a:	089b      	lsrs	r3, r3, #2
1004167c:	3306      	adds	r3, #6
1004167e:	009b      	lsls	r3, r3, #2
10041680:	18d3      	adds	r3, r2, r3
10041682:	3304      	adds	r3, #4
10041684:	681b      	ldr	r3, [r3, #0]
10041686:	1dfa      	adds	r2, r7, #7
10041688:	7812      	ldrb	r2, [r2, #0]
1004168a:	0011      	movs	r1, r2
1004168c:	2203      	movs	r2, #3
1004168e:	400a      	ands	r2, r1
10041690:	00d2      	lsls	r2, r2, #3
10041692:	21ff      	movs	r1, #255	@ 0xff
10041694:	4091      	lsls	r1, r2
10041696:	000a      	movs	r2, r1
10041698:	43d2      	mvns	r2, r2
1004169a:	401a      	ands	r2, r3
1004169c:	0011      	movs	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
1004169e:	683b      	ldr	r3, [r7, #0]
100416a0:	019b      	lsls	r3, r3, #6
100416a2:	22ff      	movs	r2, #255	@ 0xff
100416a4:	401a      	ands	r2, r3
100416a6:	1dfb      	adds	r3, r7, #7
100416a8:	781b      	ldrb	r3, [r3, #0]
100416aa:	0018      	movs	r0, r3
100416ac:	2303      	movs	r3, #3
100416ae:	4003      	ands	r3, r0
100416b0:	00db      	lsls	r3, r3, #3
100416b2:	409a      	lsls	r2, r3
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
100416b4:	4809      	ldr	r0, [pc, #36]	@ (100416dc <__NVIC_SetPriority+0xd8>)
100416b6:	1dfb      	adds	r3, r7, #7
100416b8:	781b      	ldrb	r3, [r3, #0]
100416ba:	001c      	movs	r4, r3
100416bc:	230f      	movs	r3, #15
100416be:	4023      	ands	r3, r4
100416c0:	3b08      	subs	r3, #8
100416c2:	089b      	lsrs	r3, r3, #2
100416c4:	430a      	orrs	r2, r1
100416c6:	3306      	adds	r3, #6
100416c8:	009b      	lsls	r3, r3, #2
100416ca:	18c3      	adds	r3, r0, r3
100416cc:	3304      	adds	r3, #4
100416ce:	601a      	str	r2, [r3, #0]
}
100416d0:	46c0      	nop			@ (mov r8, r8)
100416d2:	46bd      	mov	sp, r7
100416d4:	b003      	add	sp, #12
100416d6:	bd90      	pop	{r4, r7, pc}
100416d8:	e000e100 	.word	0xe000e100
100416dc:	e000ed00 	.word	0xe000ed00

100416e0 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
100416e0:	b580      	push	{r7, lr}
100416e2:	b082      	sub	sp, #8
100416e4:	af00      	add	r7, sp, #0
100416e6:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
100416e8:	687b      	ldr	r3, [r7, #4]
100416ea:	1e5a      	subs	r2, r3, #1
100416ec:	2380      	movs	r3, #128	@ 0x80
100416ee:	045b      	lsls	r3, r3, #17
100416f0:	429a      	cmp	r2, r3
100416f2:	d301      	bcc.n	100416f8 <SysTick_Config+0x18>
  {
    return (1UL);                                                   /* Reload value impossible */
100416f4:	2301      	movs	r3, #1
100416f6:	e010      	b.n	1004171a <SysTick_Config+0x3a>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
100416f8:	4b0a      	ldr	r3, [pc, #40]	@ (10041724 <SysTick_Config+0x44>)
100416fa:	687a      	ldr	r2, [r7, #4]
100416fc:	3a01      	subs	r2, #1
100416fe:	605a      	str	r2, [r3, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
10041700:	2301      	movs	r3, #1
10041702:	425b      	negs	r3, r3
10041704:	2103      	movs	r1, #3
10041706:	0018      	movs	r0, r3
10041708:	f7ff ff7c 	bl	10041604 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
1004170c:	4b05      	ldr	r3, [pc, #20]	@ (10041724 <SysTick_Config+0x44>)
1004170e:	2200      	movs	r2, #0
10041710:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
10041712:	4b04      	ldr	r3, [pc, #16]	@ (10041724 <SysTick_Config+0x44>)
10041714:	2207      	movs	r2, #7
10041716:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
10041718:	2300      	movs	r3, #0
}
1004171a:	0018      	movs	r0, r3
1004171c:	46bd      	mov	sp, r7
1004171e:	b002      	add	sp, #8
10041720:	bd80      	pop	{r7, pc}
10041722:	46c0      	nop			@ (mov r8, r8)
10041724:	e000e010 	.word	0xe000e010

10041728 <HAL_NVIC_SetPriority>:
  *         with stm32wl3x devices, this parameter is a dummy value and it is ignored, because
  *         no subpriority supported in Cortex M0+ based products.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
10041728:	b580      	push	{r7, lr}
1004172a:	b084      	sub	sp, #16
1004172c:	af00      	add	r7, sp, #0
1004172e:	60b9      	str	r1, [r7, #8]
10041730:	607a      	str	r2, [r7, #4]
10041732:	210f      	movs	r1, #15
10041734:	187b      	adds	r3, r7, r1
10041736:	1c02      	adds	r2, r0, #0
10041738:	701a      	strb	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  NVIC_SetPriority(IRQn, PreemptPriority);
1004173a:	68ba      	ldr	r2, [r7, #8]
1004173c:	187b      	adds	r3, r7, r1
1004173e:	781b      	ldrb	r3, [r3, #0]
10041740:	b25b      	sxtb	r3, r3
10041742:	0011      	movs	r1, r2
10041744:	0018      	movs	r0, r3
10041746:	f7ff ff5d 	bl	10041604 <__NVIC_SetPriority>
}
1004174a:	46c0      	nop			@ (mov r8, r8)
1004174c:	46bd      	mov	sp, r7
1004174e:	b004      	add	sp, #16
10041750:	bd80      	pop	{r7, pc}

10041752 <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file)
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
10041752:	b580      	push	{r7, lr}
10041754:	b082      	sub	sp, #8
10041756:	af00      	add	r7, sp, #0
10041758:	0002      	movs	r2, r0
1004175a:	1dfb      	adds	r3, r7, #7
1004175c:	701a      	strb	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
1004175e:	1dfb      	adds	r3, r7, #7
10041760:	781b      	ldrb	r3, [r3, #0]
10041762:	b25b      	sxtb	r3, r3
10041764:	0018      	movs	r0, r3
10041766:	f7ff ff33 	bl	100415d0 <__NVIC_EnableIRQ>
}
1004176a:	46c0      	nop			@ (mov r8, r8)
1004176c:	46bd      	mov	sp, r7
1004176e:	b002      	add	sp, #8
10041770:	bd80      	pop	{r7, pc}

10041772 <HAL_SYSTICK_Config>:
  * @param TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
10041772:	b580      	push	{r7, lr}
10041774:	b082      	sub	sp, #8
10041776:	af00      	add	r7, sp, #0
10041778:	6078      	str	r0, [r7, #4]
  return SysTick_Config(TicksNumb);
1004177a:	687b      	ldr	r3, [r7, #4]
1004177c:	0018      	movs	r0, r3
1004177e:	f7ff ffaf 	bl	100416e0 <SysTick_Config>
10041782:	0003      	movs	r3, r0
}
10041784:	0018      	movs	r0, r3
10041786:	46bd      	mov	sp, r7
10041788:	b002      	add	sp, #8
1004178a:	bd80      	pop	{r7, pc}

1004178c <HAL_GPIO_Init>:
  * @param GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
1004178c:	b580      	push	{r7, lr}
1004178e:	b086      	sub	sp, #24
10041790:	af00      	add	r7, sp, #0
10041792:	6078      	str	r0, [r7, #4]
10041794:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00u;
10041796:	2300      	movs	r3, #0
10041798:	617b      	str	r3, [r7, #20]
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00u)
1004179a:	e1a0      	b.n	10041ade <HAL_GPIO_Init+0x352>
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1uL << position);
1004179c:	683b      	ldr	r3, [r7, #0]
1004179e:	681b      	ldr	r3, [r3, #0]
100417a0:	2101      	movs	r1, #1
100417a2:	697a      	ldr	r2, [r7, #20]
100417a4:	4091      	lsls	r1, r2
100417a6:	000a      	movs	r2, r1
100417a8:	4013      	ands	r3, r2
100417aa:	60fb      	str	r3, [r7, #12]

    if (iocurrent != 0x00u)
100417ac:	68fb      	ldr	r3, [r7, #12]
100417ae:	2b00      	cmp	r3, #0
100417b0:	d100      	bne.n	100417b4 <HAL_GPIO_Init+0x28>
100417b2:	e191      	b.n	10041ad8 <HAL_GPIO_Init+0x34c>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
100417b4:	683b      	ldr	r3, [r7, #0]
100417b6:	685b      	ldr	r3, [r3, #4]
100417b8:	2203      	movs	r2, #3
100417ba:	4013      	ands	r3, r2
100417bc:	2b01      	cmp	r3, #1
100417be:	d005      	beq.n	100417cc <HAL_GPIO_Init+0x40>
100417c0:	683b      	ldr	r3, [r7, #0]
100417c2:	685b      	ldr	r3, [r3, #4]
100417c4:	2203      	movs	r2, #3
100417c6:	4013      	ands	r3, r2
100417c8:	2b02      	cmp	r3, #2
100417ca:	d130      	bne.n	1004182e <HAL_GPIO_Init+0xa2>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
100417cc:	687b      	ldr	r3, [r7, #4]
100417ce:	689b      	ldr	r3, [r3, #8]
100417d0:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2u));
100417d2:	697b      	ldr	r3, [r7, #20]
100417d4:	005b      	lsls	r3, r3, #1
100417d6:	2203      	movs	r2, #3
100417d8:	409a      	lsls	r2, r3
100417da:	0013      	movs	r3, r2
100417dc:	43da      	mvns	r2, r3
100417de:	693b      	ldr	r3, [r7, #16]
100417e0:	4013      	ands	r3, r2
100417e2:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_Init->Speed << (position * 2u));
100417e4:	683b      	ldr	r3, [r7, #0]
100417e6:	68da      	ldr	r2, [r3, #12]
100417e8:	697b      	ldr	r3, [r7, #20]
100417ea:	005b      	lsls	r3, r3, #1
100417ec:	409a      	lsls	r2, r3
100417ee:	0013      	movs	r3, r2
100417f0:	693a      	ldr	r2, [r7, #16]
100417f2:	4313      	orrs	r3, r2
100417f4:	613b      	str	r3, [r7, #16]
        GPIOx->OSPEEDR = temp;
100417f6:	687b      	ldr	r3, [r7, #4]
100417f8:	693a      	ldr	r2, [r7, #16]
100417fa:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
100417fc:	687b      	ldr	r3, [r7, #4]
100417fe:	685b      	ldr	r3, [r3, #4]
10041800:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
10041802:	2201      	movs	r2, #1
10041804:	697b      	ldr	r3, [r7, #20]
10041806:	409a      	lsls	r2, r3
10041808:	0013      	movs	r3, r2
1004180a:	43da      	mvns	r2, r3
1004180c:	693b      	ldr	r3, [r7, #16]
1004180e:	4013      	ands	r3, r2
10041810:	613b      	str	r3, [r7, #16]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
10041812:	683b      	ldr	r3, [r7, #0]
10041814:	685b      	ldr	r3, [r3, #4]
10041816:	091b      	lsrs	r3, r3, #4
10041818:	2201      	movs	r2, #1
1004181a:	401a      	ands	r2, r3
1004181c:	697b      	ldr	r3, [r7, #20]
1004181e:	409a      	lsls	r2, r3
10041820:	0013      	movs	r3, r2
10041822:	693a      	ldr	r2, [r7, #16]
10041824:	4313      	orrs	r3, r2
10041826:	613b      	str	r3, [r7, #16]
        GPIOx->OTYPER = temp;
10041828:	687b      	ldr	r3, [r7, #4]
1004182a:	693a      	ldr	r2, [r7, #16]
1004182c:	605a      	str	r2, [r3, #4]
      }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      if ((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
1004182e:	683b      	ldr	r3, [r7, #0]
10041830:	685b      	ldr	r3, [r3, #4]
10041832:	2203      	movs	r2, #3
10041834:	4013      	ands	r3, r2
10041836:	2b03      	cmp	r3, #3
10041838:	d018      	beq.n	1004186c <HAL_GPIO_Init+0xe0>
      {
        temp = GPIOx->PUPDR;
1004183a:	687b      	ldr	r3, [r7, #4]
1004183c:	68db      	ldr	r3, [r3, #12]
1004183e:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
10041840:	697b      	ldr	r3, [r7, #20]
10041842:	005b      	lsls	r3, r3, #1
10041844:	2203      	movs	r2, #3
10041846:	409a      	lsls	r2, r3
10041848:	0013      	movs	r3, r2
1004184a:	43da      	mvns	r2, r3
1004184c:	693b      	ldr	r3, [r7, #16]
1004184e:	4013      	ands	r3, r2
10041850:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Pull) << (position * 2U));
10041852:	683b      	ldr	r3, [r7, #0]
10041854:	689a      	ldr	r2, [r3, #8]
10041856:	697b      	ldr	r3, [r7, #20]
10041858:	005b      	lsls	r3, r3, #1
1004185a:	409a      	lsls	r2, r3
1004185c:	0013      	movs	r3, r2
1004185e:	693a      	ldr	r2, [r7, #16]
10041860:	4313      	orrs	r3, r2
10041862:	613b      	str	r3, [r7, #16]
        GPIOx->PUPDR = temp;
10041864:	687b      	ldr	r3, [r7, #4]
10041866:	693a      	ldr	r2, [r7, #16]
10041868:	60da      	str	r2, [r3, #12]
1004186a:	e00e      	b.n	1004188a <HAL_GPIO_Init+0xfe>
      }
      else
      {
        temp = GPIOx->PUPDR;
1004186c:	687b      	ldr	r3, [r7, #4]
1004186e:	68db      	ldr	r3, [r3, #12]
10041870:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
10041872:	697b      	ldr	r3, [r7, #20]
10041874:	005b      	lsls	r3, r3, #1
10041876:	2203      	movs	r2, #3
10041878:	409a      	lsls	r2, r3
1004187a:	0013      	movs	r3, r2
1004187c:	43da      	mvns	r2, r3
1004187e:	693b      	ldr	r3, [r7, #16]
10041880:	4013      	ands	r3, r2
10041882:	613b      	str	r3, [r7, #16]
        GPIOx->PUPDR = temp;
10041884:	687b      	ldr	r3, [r7, #4]
10041886:	693a      	ldr	r2, [r7, #16]
10041888:	60da      	str	r2, [r3, #12]
      }

      /* In case of Alternate function mode selection */
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
1004188a:	683b      	ldr	r3, [r7, #0]
1004188c:	685b      	ldr	r3, [r3, #4]
1004188e:	2203      	movs	r2, #3
10041890:	4013      	ands	r3, r2
10041892:	2b02      	cmp	r3, #2
10041894:	d123      	bne.n	100418de <HAL_GPIO_Init+0x152>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3u];
10041896:	697b      	ldr	r3, [r7, #20]
10041898:	08da      	lsrs	r2, r3, #3
1004189a:	687b      	ldr	r3, [r7, #4]
1004189c:	3208      	adds	r2, #8
1004189e:	0092      	lsls	r2, r2, #2
100418a0:	58d3      	ldr	r3, [r2, r3]
100418a2:	613b      	str	r3, [r7, #16]
        temp &= ~(0xFu << ((position & 0x07u) * 4u));
100418a4:	697b      	ldr	r3, [r7, #20]
100418a6:	2207      	movs	r2, #7
100418a8:	4013      	ands	r3, r2
100418aa:	009b      	lsls	r3, r3, #2
100418ac:	220f      	movs	r2, #15
100418ae:	409a      	lsls	r2, r3
100418b0:	0013      	movs	r3, r2
100418b2:	43da      	mvns	r2, r3
100418b4:	693b      	ldr	r3, [r7, #16]
100418b6:	4013      	ands	r3, r2
100418b8:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07u) * 4u));
100418ba:	683b      	ldr	r3, [r7, #0]
100418bc:	691a      	ldr	r2, [r3, #16]
100418be:	697b      	ldr	r3, [r7, #20]
100418c0:	2107      	movs	r1, #7
100418c2:	400b      	ands	r3, r1
100418c4:	009b      	lsls	r3, r3, #2
100418c6:	409a      	lsls	r2, r3
100418c8:	0013      	movs	r3, r2
100418ca:	693a      	ldr	r2, [r7, #16]
100418cc:	4313      	orrs	r3, r2
100418ce:	613b      	str	r3, [r7, #16]
        GPIOx->AFR[position >> 3u] = temp;
100418d0:	697b      	ldr	r3, [r7, #20]
100418d2:	08da      	lsrs	r2, r3, #3
100418d4:	687b      	ldr	r3, [r7, #4]
100418d6:	3208      	adds	r2, #8
100418d8:	0092      	lsls	r2, r2, #2
100418da:	6939      	ldr	r1, [r7, #16]
100418dc:	50d1      	str	r1, [r2, r3]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
100418de:	687b      	ldr	r3, [r7, #4]
100418e0:	681b      	ldr	r3, [r3, #0]
100418e2:	613b      	str	r3, [r7, #16]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2u));
100418e4:	697b      	ldr	r3, [r7, #20]
100418e6:	005b      	lsls	r3, r3, #1
100418e8:	2203      	movs	r2, #3
100418ea:	409a      	lsls	r2, r3
100418ec:	0013      	movs	r3, r2
100418ee:	43da      	mvns	r2, r3
100418f0:	693b      	ldr	r3, [r7, #16]
100418f2:	4013      	ands	r3, r2
100418f4:	613b      	str	r3, [r7, #16]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2u));
100418f6:	683b      	ldr	r3, [r7, #0]
100418f8:	685b      	ldr	r3, [r3, #4]
100418fa:	2203      	movs	r2, #3
100418fc:	401a      	ands	r2, r3
100418fe:	697b      	ldr	r3, [r7, #20]
10041900:	005b      	lsls	r3, r3, #1
10041902:	409a      	lsls	r2, r3
10041904:	0013      	movs	r3, r2
10041906:	693a      	ldr	r2, [r7, #16]
10041908:	4313      	orrs	r3, r2
1004190a:	613b      	str	r3, [r7, #16]
      GPIOx->MODER = temp;
1004190c:	687b      	ldr	r3, [r7, #4]
1004190e:	693a      	ldr	r2, [r7, #16]
10041910:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
10041912:	683b      	ldr	r3, [r7, #0]
10041914:	685a      	ldr	r2, [r3, #4]
10041916:	23c0      	movs	r3, #192	@ 0xc0
10041918:	029b      	lsls	r3, r3, #10
1004191a:	4013      	ands	r3, r2
1004191c:	d100      	bne.n	10041920 <HAL_GPIO_Init+0x194>
1004191e:	e0db      	b.n	10041ad8 <HAL_GPIO_Init+0x34c>
      {

        /* Edge/Level line configuration */
        if ((GPIO_Init->Mode & DETECTION_TYPE) != 0x00u)
10041920:	683b      	ldr	r3, [r7, #0]
10041922:	685a      	ldr	r2, [r3, #4]
10041924:	2380      	movs	r3, #128	@ 0x80
10041926:	02db      	lsls	r3, r3, #11
10041928:	4013      	ands	r3, r2
1004192a:	d030      	beq.n	1004198e <HAL_GPIO_Init+0x202>
        {
          temp = SYSCFG->IO_DTR;
1004192c:	2380      	movs	r3, #128	@ 0x80
1004192e:	05db      	lsls	r3, r3, #23
10041930:	68db      	ldr	r3, [r3, #12]
10041932:	613b      	str	r3, [r7, #16]
          if (GPIOx == GPIOA)
10041934:	687a      	ldr	r2, [r7, #4]
10041936:	2390      	movs	r3, #144	@ 0x90
10041938:	05db      	lsls	r3, r3, #23
1004193a:	429a      	cmp	r2, r3
1004193c:	d111      	bne.n	10041962 <HAL_GPIO_Init+0x1d6>
          {
            temp &= ~(1 << position);
1004193e:	2201      	movs	r2, #1
10041940:	697b      	ldr	r3, [r7, #20]
10041942:	409a      	lsls	r2, r3
10041944:	0013      	movs	r3, r2
10041946:	43db      	mvns	r3, r3
10041948:	001a      	movs	r2, r3
1004194a:	693b      	ldr	r3, [r7, #16]
1004194c:	4013      	ands	r3, r2
1004194e:	613b      	str	r3, [r7, #16]
            temp |= (1 << position);
10041950:	2201      	movs	r2, #1
10041952:	697b      	ldr	r3, [r7, #20]
10041954:	409a      	lsls	r2, r3
10041956:	0013      	movs	r3, r2
10041958:	001a      	movs	r2, r3
1004195a:	693b      	ldr	r3, [r7, #16]
1004195c:	4313      	orrs	r3, r2
1004195e:	613b      	str	r3, [r7, #16]
10041960:	e011      	b.n	10041986 <HAL_GPIO_Init+0x1fa>
          }
          else
          {
            temp &= ~((1 << position) << 16);
10041962:	2201      	movs	r2, #1
10041964:	697b      	ldr	r3, [r7, #20]
10041966:	409a      	lsls	r2, r3
10041968:	0013      	movs	r3, r2
1004196a:	041b      	lsls	r3, r3, #16
1004196c:	43db      	mvns	r3, r3
1004196e:	001a      	movs	r2, r3
10041970:	693b      	ldr	r3, [r7, #16]
10041972:	4013      	ands	r3, r2
10041974:	613b      	str	r3, [r7, #16]
            temp |= ((1 << position) << 16);
10041976:	2201      	movs	r2, #1
10041978:	697b      	ldr	r3, [r7, #20]
1004197a:	409a      	lsls	r2, r3
1004197c:	0013      	movs	r3, r2
1004197e:	041b      	lsls	r3, r3, #16
10041980:	693a      	ldr	r2, [r7, #16]
10041982:	4313      	orrs	r3, r2
10041984:	613b      	str	r3, [r7, #16]
          }
          SYSCFG->IO_DTR = temp;
10041986:	2380      	movs	r3, #128	@ 0x80
10041988:	05db      	lsls	r3, r3, #23
1004198a:	693a      	ldr	r2, [r7, #16]
1004198c:	60da      	str	r2, [r3, #12]
        }

		/* Edge selection configuration */
		if ((GPIO_Init->Mode & EDGE_SELECTION) != 0x00u)
1004198e:	683b      	ldr	r3, [r7, #0]
10041990:	685a      	ldr	r2, [r3, #4]
10041992:	2380      	movs	r3, #128	@ 0x80
10041994:	035b      	lsls	r3, r3, #13
10041996:	4013      	ands	r3, r2
10041998:	d030      	beq.n	100419fc <HAL_GPIO_Init+0x270>
        {
          temp = SYSCFG->IO_IBER;
1004199a:	2380      	movs	r3, #128	@ 0x80
1004199c:	05db      	lsls	r3, r3, #23
1004199e:	691b      	ldr	r3, [r3, #16]
100419a0:	613b      	str	r3, [r7, #16]

          if (GPIOx == GPIOA)
100419a2:	687a      	ldr	r2, [r7, #4]
100419a4:	2390      	movs	r3, #144	@ 0x90
100419a6:	05db      	lsls	r3, r3, #23
100419a8:	429a      	cmp	r2, r3
100419aa:	d111      	bne.n	100419d0 <HAL_GPIO_Init+0x244>
          {
            temp &= ~(1 << position);
100419ac:	2201      	movs	r2, #1
100419ae:	697b      	ldr	r3, [r7, #20]
100419b0:	409a      	lsls	r2, r3
100419b2:	0013      	movs	r3, r2
100419b4:	43db      	mvns	r3, r3
100419b6:	001a      	movs	r2, r3
100419b8:	693b      	ldr	r3, [r7, #16]
100419ba:	4013      	ands	r3, r2
100419bc:	613b      	str	r3, [r7, #16]
            temp |= (1 << position);
100419be:	2201      	movs	r2, #1
100419c0:	697b      	ldr	r3, [r7, #20]
100419c2:	409a      	lsls	r2, r3
100419c4:	0013      	movs	r3, r2
100419c6:	001a      	movs	r2, r3
100419c8:	693b      	ldr	r3, [r7, #16]
100419ca:	4313      	orrs	r3, r2
100419cc:	613b      	str	r3, [r7, #16]
100419ce:	e011      	b.n	100419f4 <HAL_GPIO_Init+0x268>
          }
          else
          {
            temp &= ~((1 << position) << 16);
100419d0:	2201      	movs	r2, #1
100419d2:	697b      	ldr	r3, [r7, #20]
100419d4:	409a      	lsls	r2, r3
100419d6:	0013      	movs	r3, r2
100419d8:	041b      	lsls	r3, r3, #16
100419da:	43db      	mvns	r3, r3
100419dc:	001a      	movs	r2, r3
100419de:	693b      	ldr	r3, [r7, #16]
100419e0:	4013      	ands	r3, r2
100419e2:	613b      	str	r3, [r7, #16]
            temp |= ((1 << position) << 16);
100419e4:	2201      	movs	r2, #1
100419e6:	697b      	ldr	r3, [r7, #20]
100419e8:	409a      	lsls	r2, r3
100419ea:	0013      	movs	r3, r2
100419ec:	041b      	lsls	r3, r3, #16
100419ee:	693a      	ldr	r2, [r7, #16]
100419f0:	4313      	orrs	r3, r2
100419f2:	613b      	str	r3, [r7, #16]
          }
          SYSCFG->IO_IBER= temp;
100419f4:	2380      	movs	r3, #128	@ 0x80
100419f6:	05db      	lsls	r3, r3, #23
100419f8:	693a      	ldr	r2, [r7, #16]
100419fa:	611a      	str	r2, [r3, #16]
        }

        /* Trigger mode configuration */
		if ((GPIO_Init->Mode & TRIGGER_MODE) != 0x00u)
100419fc:	683b      	ldr	r3, [r7, #0]
100419fe:	685a      	ldr	r2, [r3, #4]
10041a00:	2380      	movs	r3, #128	@ 0x80
10041a02:	03db      	lsls	r3, r3, #15
10041a04:	4013      	ands	r3, r2
10041a06:	d030      	beq.n	10041a6a <HAL_GPIO_Init+0x2de>
        {
          temp = SYSCFG->IO_IEVR;
10041a08:	2380      	movs	r3, #128	@ 0x80
10041a0a:	05db      	lsls	r3, r3, #23
10041a0c:	695b      	ldr	r3, [r3, #20]
10041a0e:	613b      	str	r3, [r7, #16]

          if (GPIOx == GPIOA)
10041a10:	687a      	ldr	r2, [r7, #4]
10041a12:	2390      	movs	r3, #144	@ 0x90
10041a14:	05db      	lsls	r3, r3, #23
10041a16:	429a      	cmp	r2, r3
10041a18:	d111      	bne.n	10041a3e <HAL_GPIO_Init+0x2b2>
          {
            temp &= ~(1 << position);
10041a1a:	2201      	movs	r2, #1
10041a1c:	697b      	ldr	r3, [r7, #20]
10041a1e:	409a      	lsls	r2, r3
10041a20:	0013      	movs	r3, r2
10041a22:	43db      	mvns	r3, r3
10041a24:	001a      	movs	r2, r3
10041a26:	693b      	ldr	r3, [r7, #16]
10041a28:	4013      	ands	r3, r2
10041a2a:	613b      	str	r3, [r7, #16]
            temp |= (1 << position);
10041a2c:	2201      	movs	r2, #1
10041a2e:	697b      	ldr	r3, [r7, #20]
10041a30:	409a      	lsls	r2, r3
10041a32:	0013      	movs	r3, r2
10041a34:	001a      	movs	r2, r3
10041a36:	693b      	ldr	r3, [r7, #16]
10041a38:	4313      	orrs	r3, r2
10041a3a:	613b      	str	r3, [r7, #16]
10041a3c:	e011      	b.n	10041a62 <HAL_GPIO_Init+0x2d6>
          }
          else
          {
            temp &= ~((1 << position) << 16);
10041a3e:	2201      	movs	r2, #1
10041a40:	697b      	ldr	r3, [r7, #20]
10041a42:	409a      	lsls	r2, r3
10041a44:	0013      	movs	r3, r2
10041a46:	041b      	lsls	r3, r3, #16
10041a48:	43db      	mvns	r3, r3
10041a4a:	001a      	movs	r2, r3
10041a4c:	693b      	ldr	r3, [r7, #16]
10041a4e:	4013      	ands	r3, r2
10041a50:	613b      	str	r3, [r7, #16]
            temp |= ((1 << position) << 16);
10041a52:	2201      	movs	r2, #1
10041a54:	697b      	ldr	r3, [r7, #20]
10041a56:	409a      	lsls	r2, r3
10041a58:	0013      	movs	r3, r2
10041a5a:	041b      	lsls	r3, r3, #16
10041a5c:	693a      	ldr	r2, [r7, #16]
10041a5e:	4313      	orrs	r3, r2
10041a60:	613b      	str	r3, [r7, #16]
          }
          SYSCFG->IO_IEVR= temp;
10041a62:	2380      	movs	r3, #128	@ 0x80
10041a64:	05db      	lsls	r3, r3, #23
10041a66:	693a      	ldr	r2, [r7, #16]
10041a68:	615a      	str	r2, [r3, #20]
        }

        /* Enable the specified EXTI interrupt line */
        if ((GPIO_Init->Mode & EXTI_IT) == EXTI_IT)
10041a6a:	683b      	ldr	r3, [r7, #0]
10041a6c:	685a      	ldr	r2, [r3, #4]
10041a6e:	2380      	movs	r3, #128	@ 0x80
10041a70:	025b      	lsls	r3, r3, #9
10041a72:	4013      	ands	r3, r2
10041a74:	d030      	beq.n	10041ad8 <HAL_GPIO_Init+0x34c>
        {
          temp = SYSCFG->IO_IER;
10041a76:	2380      	movs	r3, #128	@ 0x80
10041a78:	05db      	lsls	r3, r3, #23
10041a7a:	699b      	ldr	r3, [r3, #24]
10041a7c:	613b      	str	r3, [r7, #16]

          if (GPIOx == GPIOA)
10041a7e:	687a      	ldr	r2, [r7, #4]
10041a80:	2390      	movs	r3, #144	@ 0x90
10041a82:	05db      	lsls	r3, r3, #23
10041a84:	429a      	cmp	r2, r3
10041a86:	d111      	bne.n	10041aac <HAL_GPIO_Init+0x320>
          {
            temp &= ~(1 << position);
10041a88:	2201      	movs	r2, #1
10041a8a:	697b      	ldr	r3, [r7, #20]
10041a8c:	409a      	lsls	r2, r3
10041a8e:	0013      	movs	r3, r2
10041a90:	43db      	mvns	r3, r3
10041a92:	001a      	movs	r2, r3
10041a94:	693b      	ldr	r3, [r7, #16]
10041a96:	4013      	ands	r3, r2
10041a98:	613b      	str	r3, [r7, #16]
            temp |= (1 << position);
10041a9a:	2201      	movs	r2, #1
10041a9c:	697b      	ldr	r3, [r7, #20]
10041a9e:	409a      	lsls	r2, r3
10041aa0:	0013      	movs	r3, r2
10041aa2:	001a      	movs	r2, r3
10041aa4:	693b      	ldr	r3, [r7, #16]
10041aa6:	4313      	orrs	r3, r2
10041aa8:	613b      	str	r3, [r7, #16]
10041aaa:	e011      	b.n	10041ad0 <HAL_GPIO_Init+0x344>
          }
          else
          {
            temp &= ~((1 << position) << 16);
10041aac:	2201      	movs	r2, #1
10041aae:	697b      	ldr	r3, [r7, #20]
10041ab0:	409a      	lsls	r2, r3
10041ab2:	0013      	movs	r3, r2
10041ab4:	041b      	lsls	r3, r3, #16
10041ab6:	43db      	mvns	r3, r3
10041ab8:	001a      	movs	r2, r3
10041aba:	693b      	ldr	r3, [r7, #16]
10041abc:	4013      	ands	r3, r2
10041abe:	613b      	str	r3, [r7, #16]
            temp |= ((1 << position) << 16);
10041ac0:	2201      	movs	r2, #1
10041ac2:	697b      	ldr	r3, [r7, #20]
10041ac4:	409a      	lsls	r2, r3
10041ac6:	0013      	movs	r3, r2
10041ac8:	041b      	lsls	r3, r3, #16
10041aca:	693a      	ldr	r2, [r7, #16]
10041acc:	4313      	orrs	r3, r2
10041ace:	613b      	str	r3, [r7, #16]
          }
          SYSCFG->IO_IER= temp;
10041ad0:	2380      	movs	r3, #128	@ 0x80
10041ad2:	05db      	lsls	r3, r3, #23
10041ad4:	693a      	ldr	r2, [r7, #16]
10041ad6:	619a      	str	r2, [r3, #24]
        }
      }
    }

    position++;
10041ad8:	697b      	ldr	r3, [r7, #20]
10041ada:	3301      	adds	r3, #1
10041adc:	617b      	str	r3, [r7, #20]
  while (((GPIO_Init->Pin) >> position) != 0x00u)
10041ade:	683b      	ldr	r3, [r7, #0]
10041ae0:	681a      	ldr	r2, [r3, #0]
10041ae2:	697b      	ldr	r3, [r7, #20]
10041ae4:	40da      	lsrs	r2, r3
10041ae6:	1e13      	subs	r3, r2, #0
10041ae8:	d000      	beq.n	10041aec <HAL_GPIO_Init+0x360>
10041aea:	e657      	b.n	1004179c <HAL_GPIO_Init+0x10>
  }
}
10041aec:	46c0      	nop			@ (mov r8, r8)
10041aee:	46c0      	nop			@ (mov r8, r8)
10041af0:	46bd      	mov	sp, r7
10041af2:	b006      	add	sp, #24
10041af4:	bd80      	pop	{r7, pc}
	...

10041af8 <LL_MRSubG_SetPAMode>:
{
10041af8:	b580      	push	{r7, lr}
10041afa:	b082      	sub	sp, #8
10041afc:	af00      	add	r7, sp, #0
10041afe:	0002      	movs	r2, r0
10041b00:	1dfb      	adds	r3, r7, #7
10041b02:	701a      	strb	r2, [r3, #0]
  MODIFY_REG_FIELD(MR_SUBG_GLOB_STATIC->PA_CONFIG, MR_SUBG_GLOB_STATIC_PA_CONFIG_PA_MODE, paMode);
10041b04:	4b08      	ldr	r3, [pc, #32]	@ (10041b28 <LL_MRSubG_SetPAMode+0x30>)
10041b06:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
10041b08:	4a08      	ldr	r2, [pc, #32]	@ (10041b2c <LL_MRSubG_SetPAMode+0x34>)
10041b0a:	4013      	ands	r3, r2
10041b0c:	0019      	movs	r1, r3
10041b0e:	1dfb      	adds	r3, r7, #7
10041b10:	781b      	ldrb	r3, [r3, #0]
10041b12:	029a      	lsls	r2, r3, #10
10041b14:	23c0      	movs	r3, #192	@ 0xc0
10041b16:	011b      	lsls	r3, r3, #4
10041b18:	401a      	ands	r2, r3
10041b1a:	4b03      	ldr	r3, [pc, #12]	@ (10041b28 <LL_MRSubG_SetPAMode+0x30>)
10041b1c:	430a      	orrs	r2, r1
10041b1e:	629a      	str	r2, [r3, #40]	@ 0x28
}
10041b20:	46c0      	nop			@ (mov r8, r8)
10041b22:	46bd      	mov	sp, r7
10041b24:	b002      	add	sp, #8
10041b26:	bd80      	pop	{r7, pc}
10041b28:	49000400 	.word	0x49000400
10041b2c:	fffff3ff 	.word	0xfffff3ff

10041b30 <LL_MRSubG_SetPADriveMode>:
{
10041b30:	b580      	push	{r7, lr}
10041b32:	b082      	sub	sp, #8
10041b34:	af00      	add	r7, sp, #0
10041b36:	0002      	movs	r2, r0
10041b38:	1dfb      	adds	r3, r7, #7
10041b3a:	701a      	strb	r2, [r3, #0]
  MODIFY_REG_FIELD(MR_SUBG_GLOB_STATIC->PA_CONFIG, MR_SUBG_GLOB_STATIC_PA_CONFIG_PA_DRV_MODE, paDrvMode);
10041b3c:	4b08      	ldr	r3, [pc, #32]	@ (10041b60 <LL_MRSubG_SetPADriveMode+0x30>)
10041b3e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
10041b40:	4a08      	ldr	r2, [pc, #32]	@ (10041b64 <LL_MRSubG_SetPADriveMode+0x34>)
10041b42:	4013      	ands	r3, r2
10041b44:	0019      	movs	r1, r3
10041b46:	1dfb      	adds	r3, r7, #7
10041b48:	781b      	ldrb	r3, [r3, #0]
10041b4a:	021a      	lsls	r2, r3, #8
10041b4c:	23c0      	movs	r3, #192	@ 0xc0
10041b4e:	009b      	lsls	r3, r3, #2
10041b50:	401a      	ands	r2, r3
10041b52:	4b03      	ldr	r3, [pc, #12]	@ (10041b60 <LL_MRSubG_SetPADriveMode+0x30>)
10041b54:	430a      	orrs	r2, r1
10041b56:	629a      	str	r2, [r3, #40]	@ 0x28
}
10041b58:	46c0      	nop			@ (mov r8, r8)
10041b5a:	46bd      	mov	sp, r7
10041b5c:	b002      	add	sp, #8
10041b5e:	bd80      	pop	{r7, pc}
10041b60:	49000400 	.word	0x49000400
10041b64:	fffffcff 	.word	0xfffffcff

10041b68 <LL_MRSubG_SetPADegen>:
  *         which introduces a pre-distortion to linearize the power control curve.
  * @param  xNewState enable (ENABLE) to enable or disable (DISABLE) the degeneration.
  * @retval None.
  */
__STATIC_INLINE void LL_MRSubG_SetPADegen(FunctionalState xNewState)
{
10041b68:	b580      	push	{r7, lr}
10041b6a:	b082      	sub	sp, #8
10041b6c:	af00      	add	r7, sp, #0
10041b6e:	0002      	movs	r2, r0
10041b70:	1dfb      	adds	r3, r7, #7
10041b72:	701a      	strb	r2, [r3, #0]
  if (xNewState == ENABLE)
10041b74:	1dfb      	adds	r3, r7, #7
10041b76:	781b      	ldrb	r3, [r3, #0]
10041b78:	2b01      	cmp	r3, #1
10041b7a:	d10a      	bne.n	10041b92 <LL_MRSubG_SetPADegen+0x2a>
  {
    SET_BIT(MR_SUBG_RADIO->PA_REG, MR_SUBG_RADIO_PA_REG_PA_DEGEN_ON);
10041b7c:	2392      	movs	r3, #146	@ 0x92
10041b7e:	05db      	lsls	r3, r3, #23
10041b80:	22a8      	movs	r2, #168	@ 0xa8
10041b82:	589a      	ldr	r2, [r3, r2]
10041b84:	2392      	movs	r3, #146	@ 0x92
10041b86:	05db      	lsls	r3, r3, #23
10041b88:	2108      	movs	r1, #8
10041b8a:	430a      	orrs	r2, r1
10041b8c:	21a8      	movs	r1, #168	@ 0xa8
10041b8e:	505a      	str	r2, [r3, r1]
  }
  else
  {
    CLEAR_BIT(MR_SUBG_RADIO->PA_REG, MR_SUBG_RADIO_PA_REG_PA_DEGEN_ON);
  }
}
10041b90:	e009      	b.n	10041ba6 <LL_MRSubG_SetPADegen+0x3e>
    CLEAR_BIT(MR_SUBG_RADIO->PA_REG, MR_SUBG_RADIO_PA_REG_PA_DEGEN_ON);
10041b92:	2392      	movs	r3, #146	@ 0x92
10041b94:	05db      	lsls	r3, r3, #23
10041b96:	22a8      	movs	r2, #168	@ 0xa8
10041b98:	589a      	ldr	r2, [r3, r2]
10041b9a:	2392      	movs	r3, #146	@ 0x92
10041b9c:	05db      	lsls	r3, r3, #23
10041b9e:	2108      	movs	r1, #8
10041ba0:	438a      	bics	r2, r1
10041ba2:	21a8      	movs	r1, #168	@ 0xa8
10041ba4:	505a      	str	r2, [r3, r1]
}
10041ba6:	46c0      	nop			@ (mov r8, r8)
10041ba8:	46bd      	mov	sp, r7
10041baa:	b002      	add	sp, #8
10041bac:	bd80      	pop	{r7, pc}
	...

10041bb0 <LL_MRSubG_SetPreambleLength>:
  * @brief  Set the PREAMBLE field Length.
  * @param  cPreambleLength length of PREAMBLE field in pairs of bits (0 to 2046 bits).
  * @retval None.
  */
__STATIC_INLINE void LL_MRSubG_SetPreambleLength(uint16_t cPreambleLength)
{
10041bb0:	b580      	push	{r7, lr}
10041bb2:	b082      	sub	sp, #8
10041bb4:	af00      	add	r7, sp, #0
10041bb6:	0002      	movs	r2, r0
10041bb8:	1dbb      	adds	r3, r7, #6
10041bba:	801a      	strh	r2, [r3, #0]
  MODIFY_REG_FIELD(MR_SUBG_GLOB_STATIC->PCKT_CONFIG, MR_SUBG_GLOB_STATIC_PCKT_CONFIG_PREAMBLE_LENGTH, cPreambleLength);
10041bbc:	4b08      	ldr	r3, [pc, #32]	@ (10041be0 <LL_MRSubG_SetPreambleLength+0x30>)
10041bbe:	681b      	ldr	r3, [r3, #0]
10041bc0:	4a08      	ldr	r2, [pc, #32]	@ (10041be4 <LL_MRSubG_SetPreambleLength+0x34>)
10041bc2:	4013      	ands	r3, r2
10041bc4:	0019      	movs	r1, r3
10041bc6:	1dbb      	adds	r3, r7, #6
10041bc8:	881b      	ldrh	r3, [r3, #0]
10041bca:	031b      	lsls	r3, r3, #12
10041bcc:	4a06      	ldr	r2, [pc, #24]	@ (10041be8 <LL_MRSubG_SetPreambleLength+0x38>)
10041bce:	401a      	ands	r2, r3
10041bd0:	4b03      	ldr	r3, [pc, #12]	@ (10041be0 <LL_MRSubG_SetPreambleLength+0x30>)
10041bd2:	430a      	orrs	r2, r1
10041bd4:	601a      	str	r2, [r3, #0]
}
10041bd6:	46c0      	nop			@ (mov r8, r8)
10041bd8:	46bd      	mov	sp, r7
10041bda:	b002      	add	sp, #8
10041bdc:	bd80      	pop	{r7, pc}
10041bde:	46c0      	nop			@ (mov r8, r8)
10041be0:	49000400 	.word	0x49000400
10041be4:	ffc00fff 	.word	0xffc00fff
10041be8:	003ff000 	.word	0x003ff000

10041bec <LL_MRSubG_SetPreambleSeq>:
  * @brief  Set the PREAMBLE pattern to be applied.
  * @param  cPreambleSeq the pattern to apply
  * @retval None.
  */
__STATIC_INLINE void LL_MRSubG_SetPreambleSeq(MRSubG_PreambleSeq cPreambleSeq)
{
10041bec:	b580      	push	{r7, lr}
10041bee:	b082      	sub	sp, #8
10041bf0:	af00      	add	r7, sp, #0
10041bf2:	0002      	movs	r2, r0
10041bf4:	1dfb      	adds	r3, r7, #7
10041bf6:	701a      	strb	r2, [r3, #0]
  MODIFY_REG_FIELD(
10041bf8:	4b08      	ldr	r3, [pc, #32]	@ (10041c1c <LL_MRSubG_SetPreambleSeq+0x30>)
10041bfa:	681b      	ldr	r3, [r3, #0]
10041bfc:	4a08      	ldr	r2, [pc, #32]	@ (10041c20 <LL_MRSubG_SetPreambleSeq+0x34>)
10041bfe:	4013      	ands	r3, r2
10041c00:	0019      	movs	r1, r3
10041c02:	1dfb      	adds	r3, r7, #7
10041c04:	781b      	ldrb	r3, [r3, #0]
10041c06:	059a      	lsls	r2, r3, #22
10041c08:	23c0      	movs	r3, #192	@ 0xc0
10041c0a:	041b      	lsls	r3, r3, #16
10041c0c:	401a      	ands	r2, r3
10041c0e:	4b03      	ldr	r3, [pc, #12]	@ (10041c1c <LL_MRSubG_SetPreambleSeq+0x30>)
10041c10:	430a      	orrs	r2, r1
10041c12:	601a      	str	r2, [r3, #0]
    MR_SUBG_GLOB_STATIC->PCKT_CONFIG,
    MR_SUBG_GLOB_STATIC_PCKT_CONFIG_PREAMBLE_SEQ,
    (uint8_t)cPreambleSeq
  );
}
10041c14:	46c0      	nop			@ (mov r8, r8)
10041c16:	46bd      	mov	sp, r7
10041c18:	b002      	add	sp, #8
10041c1a:	bd80      	pop	{r7, pc}
10041c1c:	49000400 	.word	0x49000400
10041c20:	ff3fffff 	.word	0xff3fffff

10041c24 <LL_MRSubG_SetPostambleLength>:
  * @brief  Set the POSTAMBLE field Length.
  * @param  cPostambleLength length of POSTAMBLE field in pairs of bits (0 to 126 bits).
  * @retval None.
  */
__STATIC_INLINE void LL_MRSubG_SetPostambleLength(uint16_t cPostambleLength)
{
10041c24:	b580      	push	{r7, lr}
10041c26:	b082      	sub	sp, #8
10041c28:	af00      	add	r7, sp, #0
10041c2a:	0002      	movs	r2, r0
10041c2c:	1dbb      	adds	r3, r7, #6
10041c2e:	801a      	strh	r2, [r3, #0]
  MODIFY_REG_FIELD(
10041c30:	4b08      	ldr	r3, [pc, #32]	@ (10041c54 <LL_MRSubG_SetPostambleLength+0x30>)
10041c32:	681b      	ldr	r3, [r3, #0]
10041c34:	4a08      	ldr	r2, [pc, #32]	@ (10041c58 <LL_MRSubG_SetPostambleLength+0x34>)
10041c36:	4013      	ands	r3, r2
10041c38:	0019      	movs	r1, r3
10041c3a:	1dbb      	adds	r3, r7, #6
10041c3c:	881b      	ldrh	r3, [r3, #0]
10041c3e:	061a      	lsls	r2, r3, #24
10041c40:	23fc      	movs	r3, #252	@ 0xfc
10041c42:	059b      	lsls	r3, r3, #22
10041c44:	401a      	ands	r2, r3
10041c46:	4b03      	ldr	r3, [pc, #12]	@ (10041c54 <LL_MRSubG_SetPostambleLength+0x30>)
10041c48:	430a      	orrs	r2, r1
10041c4a:	601a      	str	r2, [r3, #0]
    MR_SUBG_GLOB_STATIC->PCKT_CONFIG,
    MR_SUBG_GLOB_STATIC_PCKT_CONFIG_POSTAMBLE_LENGTH,
    cPostambleLength
  );
}
10041c4c:	46c0      	nop			@ (mov r8, r8)
10041c4e:	46bd      	mov	sp, r7
10041c50:	b002      	add	sp, #8
10041c52:	bd80      	pop	{r7, pc}
10041c54:	49000400 	.word	0x49000400
10041c58:	c0ffffff 	.word	0xc0ffffff

10041c5c <LL_MRSubG_SetPostamblSeq>:
  * @brief  Set the POSTAMBLE pattern to be applied.
  * @param  cPostambleSeq the pattern to apply
  * @retval None.
  */
__STATIC_INLINE void LL_MRSubG_SetPostamblSeq(MRSubG_PostambleSeq cPostambleSeq)
{
10041c5c:	b580      	push	{r7, lr}
10041c5e:	b082      	sub	sp, #8
10041c60:	af00      	add	r7, sp, #0
10041c62:	0002      	movs	r2, r0
10041c64:	1dfb      	adds	r3, r7, #7
10041c66:	701a      	strb	r2, [r3, #0]
  MODIFY_REG_FIELD(MR_SUBG_GLOB_STATIC->PCKT_CONFIG, MR_SUBG_GLOB_STATIC_PCKT_CONFIG_POSTAMBLE_SEQ,
10041c68:	4b06      	ldr	r3, [pc, #24]	@ (10041c84 <LL_MRSubG_SetPostamblSeq+0x28>)
10041c6a:	681b      	ldr	r3, [r3, #0]
10041c6c:	009b      	lsls	r3, r3, #2
10041c6e:	0899      	lsrs	r1, r3, #2
10041c70:	1dfb      	adds	r3, r7, #7
10041c72:	781b      	ldrb	r3, [r3, #0]
10041c74:	079a      	lsls	r2, r3, #30
10041c76:	4b03      	ldr	r3, [pc, #12]	@ (10041c84 <LL_MRSubG_SetPostamblSeq+0x28>)
10041c78:	430a      	orrs	r2, r1
10041c7a:	601a      	str	r2, [r3, #0]
                   (uint8_t)cPostambleSeq);
}
10041c7c:	46c0      	nop			@ (mov r8, r8)
10041c7e:	46bd      	mov	sp, r7
10041c80:	b002      	add	sp, #8
10041c82:	bd80      	pop	{r7, pc}
10041c84:	49000400 	.word	0x49000400

10041c88 <LL_MRSubG_SetSyncPresent>:
  * @brief  Set the SYNC_PRESENT bit.
  * @param  cSyncPresent the enable/disable value for the bit
  * @retval None.
  */
__STATIC_INLINE void LL_MRSubG_SetSyncPresent(FunctionalState cSyncPresent)
{
10041c88:	b580      	push	{r7, lr}
10041c8a:	b082      	sub	sp, #8
10041c8c:	af00      	add	r7, sp, #0
10041c8e:	0002      	movs	r2, r0
10041c90:	1dfb      	adds	r3, r7, #7
10041c92:	701a      	strb	r2, [r3, #0]
  MODIFY_REG_FIELD(MR_SUBG_GLOB_STATIC->PCKT_CONFIG, MR_SUBG_GLOB_STATIC_PCKT_CONFIG_SYNC_PRESENT, cSyncPresent);
10041c94:	4b08      	ldr	r3, [pc, #32]	@ (10041cb8 <LL_MRSubG_SetSyncPresent+0x30>)
10041c96:	681b      	ldr	r3, [r3, #0]
10041c98:	4a08      	ldr	r2, [pc, #32]	@ (10041cbc <LL_MRSubG_SetSyncPresent+0x34>)
10041c9a:	4013      	ands	r3, r2
10041c9c:	0019      	movs	r1, r3
10041c9e:	1dfb      	adds	r3, r7, #7
10041ca0:	781b      	ldrb	r3, [r3, #0]
10041ca2:	025a      	lsls	r2, r3, #9
10041ca4:	2380      	movs	r3, #128	@ 0x80
10041ca6:	009b      	lsls	r3, r3, #2
10041ca8:	401a      	ands	r2, r3
10041caa:	4b03      	ldr	r3, [pc, #12]	@ (10041cb8 <LL_MRSubG_SetSyncPresent+0x30>)
10041cac:	430a      	orrs	r2, r1
10041cae:	601a      	str	r2, [r3, #0]
}
10041cb0:	46c0      	nop			@ (mov r8, r8)
10041cb2:	46bd      	mov	sp, r7
10041cb4:	b002      	add	sp, #8
10041cb6:	bd80      	pop	{r7, pc}
10041cb8:	49000400 	.word	0x49000400
10041cbc:	fffffdff 	.word	0xfffffdff

10041cc0 <LL_MRSubG_SetSecondarySync>:
         In RX mode: it enables the detection of SEC_SYNC in parallel of SYNC word.
  * @param  cSecondarySync the enable/disable value for the bit
  * @retval None.
  */
__STATIC_INLINE void LL_MRSubG_SetSecondarySync(FunctionalState cSecondarySync)
{
10041cc0:	b580      	push	{r7, lr}
10041cc2:	b082      	sub	sp, #8
10041cc4:	af00      	add	r7, sp, #0
10041cc6:	0002      	movs	r2, r0
10041cc8:	1dfb      	adds	r3, r7, #7
10041cca:	701a      	strb	r2, [r3, #0]
  MODIFY_REG_FIELD(
10041ccc:	4b08      	ldr	r3, [pc, #32]	@ (10041cf0 <LL_MRSubG_SetSecondarySync+0x30>)
10041cce:	681b      	ldr	r3, [r3, #0]
10041cd0:	2208      	movs	r2, #8
10041cd2:	4393      	bics	r3, r2
10041cd4:	0019      	movs	r1, r3
10041cd6:	1dfb      	adds	r3, r7, #7
10041cd8:	781b      	ldrb	r3, [r3, #0]
10041cda:	00db      	lsls	r3, r3, #3
10041cdc:	2208      	movs	r2, #8
10041cde:	401a      	ands	r2, r3
10041ce0:	4b03      	ldr	r3, [pc, #12]	@ (10041cf0 <LL_MRSubG_SetSecondarySync+0x30>)
10041ce2:	430a      	orrs	r2, r1
10041ce4:	601a      	str	r2, [r3, #0]
    MR_SUBG_GLOB_STATIC->PCKT_CONFIG,
    MR_SUBG_GLOB_STATIC_PCKT_CONFIG_SECONDARY_SYNC_SEL,
    cSecondarySync
  );
}
10041ce6:	46c0      	nop			@ (mov r8, r8)
10041ce8:	46bd      	mov	sp, r7
10041cea:	b002      	add	sp, #8
10041cec:	bd80      	pop	{r7, pc}
10041cee:	46c0      	nop			@ (mov r8, r8)
10041cf0:	49000400 	.word	0x49000400

10041cf4 <LL_MRSubG_SetSyncLength>:
  * @brief  Set the SYNC field Length.
  * @param  cSyncLength length of SYNC field in bits.
  * @retval None.
  */
__STATIC_INLINE void LL_MRSubG_SetSyncLength(uint8_t cSyncLength)
{
10041cf4:	b580      	push	{r7, lr}
10041cf6:	b082      	sub	sp, #8
10041cf8:	af00      	add	r7, sp, #0
10041cfa:	0002      	movs	r2, r0
10041cfc:	1dfb      	adds	r3, r7, #7
10041cfe:	701a      	strb	r2, [r3, #0]
  MODIFY_REG_FIELD(MR_SUBG_GLOB_STATIC->PCKT_CONFIG, MR_SUBG_GLOB_STATIC_PCKT_CONFIG_SYNC_LEN, cSyncLength);
10041d00:	4b08      	ldr	r3, [pc, #32]	@ (10041d24 <LL_MRSubG_SetSyncLength+0x30>)
10041d02:	681b      	ldr	r3, [r3, #0]
10041d04:	4a08      	ldr	r2, [pc, #32]	@ (10041d28 <LL_MRSubG_SetSyncLength+0x34>)
10041d06:	4013      	ands	r3, r2
10041d08:	0019      	movs	r1, r3
10041d0a:	1dfb      	adds	r3, r7, #7
10041d0c:	781b      	ldrb	r3, [r3, #0]
10041d0e:	011a      	lsls	r2, r3, #4
10041d10:	23f8      	movs	r3, #248	@ 0xf8
10041d12:	005b      	lsls	r3, r3, #1
10041d14:	401a      	ands	r2, r3
10041d16:	4b03      	ldr	r3, [pc, #12]	@ (10041d24 <LL_MRSubG_SetSyncLength+0x30>)
10041d18:	430a      	orrs	r2, r1
10041d1a:	601a      	str	r2, [r3, #0]
}
10041d1c:	46c0      	nop			@ (mov r8, r8)
10041d1e:	46bd      	mov	sp, r7
10041d20:	b002      	add	sp, #8
10041d22:	bd80      	pop	{r7, pc}
10041d24:	49000400 	.word	0x49000400
10041d28:	fffffe0f 	.word	0xfffffe0f

10041d2c <LL_MRSubG_SetSyncWord>:
  * @brief  Set the SYNC word.
  * @param  lSyncWord SYNC word given as a 32 bits aligned word.
  * @retval None.
  */
__STATIC_INLINE void LL_MRSubG_SetSyncWord(uint32_t lSyncWord)
{
10041d2c:	b580      	push	{r7, lr}
10041d2e:	b082      	sub	sp, #8
10041d30:	af00      	add	r7, sp, #0
10041d32:	6078      	str	r0, [r7, #4]
  WRITE_REG(MR_SUBG_GLOB_STATIC->SYNC, lSyncWord);
10041d34:	4b03      	ldr	r3, [pc, #12]	@ (10041d44 <LL_MRSubG_SetSyncWord+0x18>)
10041d36:	687a      	ldr	r2, [r7, #4]
10041d38:	605a      	str	r2, [r3, #4]
}
10041d3a:	46c0      	nop			@ (mov r8, r8)
10041d3c:	46bd      	mov	sp, r7
10041d3e:	b002      	add	sp, #8
10041d40:	bd80      	pop	{r7, pc}
10041d42:	46c0      	nop			@ (mov r8, r8)
10041d44:	49000400 	.word	0x49000400

10041d48 <LL_MRSubG_PacketHandlerWhitening>:
  * @param  xNewState new state for WHITENING mode.
  *         This parameter can be S_ENABLE or S_DISABLE.
  * @retval None.
  */
__STATIC_INLINE void LL_MRSubG_PacketHandlerWhitening(FunctionalState xNewState)
{
10041d48:	b580      	push	{r7, lr}
10041d4a:	b082      	sub	sp, #8
10041d4c:	af00      	add	r7, sp, #0
10041d4e:	0002      	movs	r2, r0
10041d50:	1dfb      	adds	r3, r7, #7
10041d52:	701a      	strb	r2, [r3, #0]
  if (xNewState == ENABLE)
10041d54:	1dfb      	adds	r3, r7, #7
10041d56:	781b      	ldrb	r3, [r3, #0]
10041d58:	2b01      	cmp	r3, #1
10041d5a:	d107      	bne.n	10041d6c <LL_MRSubG_PacketHandlerWhitening+0x24>
  {
    SET_BIT(MR_SUBG_GLOB_STATIC->PCKT_CTRL, MR_SUBG_GLOB_STATIC_PCKT_CTRL_WHIT_EN);
10041d5c:	4b08      	ldr	r3, [pc, #32]	@ (10041d80 <LL_MRSubG_PacketHandlerWhitening+0x38>)
10041d5e:	691a      	ldr	r2, [r3, #16]
10041d60:	4b07      	ldr	r3, [pc, #28]	@ (10041d80 <LL_MRSubG_PacketHandlerWhitening+0x38>)
10041d62:	2180      	movs	r1, #128	@ 0x80
10041d64:	0109      	lsls	r1, r1, #4
10041d66:	430a      	orrs	r2, r1
10041d68:	611a      	str	r2, [r3, #16]
  }
  else
    CLEAR_BIT(MR_SUBG_GLOB_STATIC->PCKT_CTRL, MR_SUBG_GLOB_STATIC_PCKT_CTRL_WHIT_EN);
}
10041d6a:	e005      	b.n	10041d78 <LL_MRSubG_PacketHandlerWhitening+0x30>
    CLEAR_BIT(MR_SUBG_GLOB_STATIC->PCKT_CTRL, MR_SUBG_GLOB_STATIC_PCKT_CTRL_WHIT_EN);
10041d6c:	4b04      	ldr	r3, [pc, #16]	@ (10041d80 <LL_MRSubG_PacketHandlerWhitening+0x38>)
10041d6e:	691a      	ldr	r2, [r3, #16]
10041d70:	4b03      	ldr	r3, [pc, #12]	@ (10041d80 <LL_MRSubG_PacketHandlerWhitening+0x38>)
10041d72:	4904      	ldr	r1, [pc, #16]	@ (10041d84 <LL_MRSubG_PacketHandlerWhitening+0x3c>)
10041d74:	400a      	ands	r2, r1
10041d76:	611a      	str	r2, [r3, #16]
}
10041d78:	46c0      	nop			@ (mov r8, r8)
10041d7a:	46bd      	mov	sp, r7
10041d7c:	b002      	add	sp, #8
10041d7e:	bd80      	pop	{r7, pc}
10041d80:	49000400 	.word	0x49000400
10041d84:	fffff7ff 	.word	0xfffff7ff

10041d88 <LL_MRSubG_PacketHandlerSetWhiteningInit>:
  * @param  whit_init Whitening initialization value.
  *         In 802.15.4 standard, this initialization seed must be programmed to 0x1FF.
  * @retval None.
  */
__STATIC_INLINE void LL_MRSubG_PacketHandlerSetWhiteningInit(uint16_t whit_init)
{
10041d88:	b580      	push	{r7, lr}
10041d8a:	b082      	sub	sp, #8
10041d8c:	af00      	add	r7, sp, #0
10041d8e:	0002      	movs	r2, r0
10041d90:	1dbb      	adds	r3, r7, #6
10041d92:	801a      	strh	r2, [r3, #0]
  MODIFY_REG_FIELD(MR_SUBG_GLOB_STATIC->PCKT_CTRL, MR_SUBG_GLOB_STATIC_PCKT_CTRL_WHIT_INIT, whit_init);
10041d94:	4b08      	ldr	r3, [pc, #32]	@ (10041db8 <LL_MRSubG_PacketHandlerSetWhiteningInit+0x30>)
10041d96:	691b      	ldr	r3, [r3, #16]
10041d98:	4a08      	ldr	r2, [pc, #32]	@ (10041dbc <LL_MRSubG_PacketHandlerSetWhiteningInit+0x34>)
10041d9a:	4013      	ands	r3, r2
10041d9c:	0019      	movs	r1, r3
10041d9e:	1dbb      	adds	r3, r7, #6
10041da0:	881b      	ldrh	r3, [r3, #0]
10041da2:	031b      	lsls	r3, r3, #12
10041da4:	4a06      	ldr	r2, [pc, #24]	@ (10041dc0 <LL_MRSubG_PacketHandlerSetWhiteningInit+0x38>)
10041da6:	401a      	ands	r2, r3
10041da8:	4b03      	ldr	r3, [pc, #12]	@ (10041db8 <LL_MRSubG_PacketHandlerSetWhiteningInit+0x30>)
10041daa:	430a      	orrs	r2, r1
10041dac:	611a      	str	r2, [r3, #16]
}
10041dae:	46c0      	nop			@ (mov r8, r8)
10041db0:	46bd      	mov	sp, r7
10041db2:	b002      	add	sp, #8
10041db4:	bd80      	pop	{r7, pc}
10041db6:	46c0      	nop			@ (mov r8, r8)
10041db8:	49000400 	.word	0x49000400
10041dbc:	ffe00fff 	.word	0xffe00fff
10041dc0:	001ff000 	.word	0x001ff000

10041dc4 <LL_MRSubG_PacketHandlerCoding>:
  * @brief  Set the type of coding and decoding for the packets.
  * @param  cCoding coding/decoding selection.
  * @retval None.
  */
__STATIC_INLINE void LL_MRSubG_PacketHandlerCoding(MRSubG_PcktCoding cCoding)
{
10041dc4:	b580      	push	{r7, lr}
10041dc6:	b082      	sub	sp, #8
10041dc8:	af00      	add	r7, sp, #0
10041dca:	0002      	movs	r2, r0
10041dcc:	1dfb      	adds	r3, r7, #7
10041dce:	701a      	strb	r2, [r3, #0]
  MODIFY_REG_FIELD(MR_SUBG_GLOB_STATIC->PCKT_CTRL, MR_SUBG_GLOB_STATIC_PCKT_CTRL_CODING_SEL, cCoding);
10041dd0:	4b08      	ldr	r3, [pc, #32]	@ (10041df4 <LL_MRSubG_PacketHandlerCoding+0x30>)
10041dd2:	691b      	ldr	r3, [r3, #16]
10041dd4:	4a08      	ldr	r2, [pc, #32]	@ (10041df8 <LL_MRSubG_PacketHandlerCoding+0x34>)
10041dd6:	4013      	ands	r3, r2
10041dd8:	0019      	movs	r1, r3
10041dda:	1dfb      	adds	r3, r7, #7
10041ddc:	781b      	ldrb	r3, [r3, #0]
10041dde:	055a      	lsls	r2, r3, #21
10041de0:	23c0      	movs	r3, #192	@ 0xc0
10041de2:	03db      	lsls	r3, r3, #15
10041de4:	401a      	ands	r2, r3
10041de6:	4b03      	ldr	r3, [pc, #12]	@ (10041df4 <LL_MRSubG_PacketHandlerCoding+0x30>)
10041de8:	430a      	orrs	r2, r1
10041dea:	611a      	str	r2, [r3, #16]
}
10041dec:	46c0      	nop			@ (mov r8, r8)
10041dee:	46bd      	mov	sp, r7
10041df0:	b002      	add	sp, #8
10041df2:	bd80      	pop	{r7, pc}
10041df4:	49000400 	.word	0x49000400
10041df8:	ff9fffff 	.word	0xff9fffff

10041dfc <LL_MRSubG_PacketHandlerSetCrcMode>:
  * @brief  Set the CRC mode.
  * @param  xPktCrcMode This parameter can be one among the @ref MRSubG_PcktCrcMode .
  * @retval None.
  */
__STATIC_INLINE void LL_MRSubG_PacketHandlerSetCrcMode(MRSubG_PcktCrcMode xPktCrcMode)
{
10041dfc:	b580      	push	{r7, lr}
10041dfe:	b082      	sub	sp, #8
10041e00:	af00      	add	r7, sp, #0
10041e02:	0002      	movs	r2, r0
10041e04:	1dfb      	adds	r3, r7, #7
10041e06:	701a      	strb	r2, [r3, #0]
  MODIFY_REG_FIELD(MR_SUBG_GLOB_STATIC->PCKT_CONFIG, MR_SUBG_GLOB_STATIC_PCKT_CONFIG_CRC_MODE, xPktCrcMode);
10041e08:	4b07      	ldr	r3, [pc, #28]	@ (10041e28 <LL_MRSubG_PacketHandlerSetCrcMode+0x2c>)
10041e0a:	681b      	ldr	r3, [r3, #0]
10041e0c:	2207      	movs	r2, #7
10041e0e:	4393      	bics	r3, r2
10041e10:	0019      	movs	r1, r3
10041e12:	1dfb      	adds	r3, r7, #7
10041e14:	781b      	ldrb	r3, [r3, #0]
10041e16:	2207      	movs	r2, #7
10041e18:	401a      	ands	r2, r3
10041e1a:	4b03      	ldr	r3, [pc, #12]	@ (10041e28 <LL_MRSubG_PacketHandlerSetCrcMode+0x2c>)
10041e1c:	430a      	orrs	r2, r1
10041e1e:	601a      	str	r2, [r3, #0]
}
10041e20:	46c0      	nop			@ (mov r8, r8)
10041e22:	46bd      	mov	sp, r7
10041e24:	b002      	add	sp, #8
10041e26:	bd80      	pop	{r7, pc}
10041e28:	49000400 	.word	0x49000400

10041e2c <LL_MRSUBG_SetPacketLength>:
  * @brief  Set the PCKTLEN field of the PCKTLEN_CONFIG register.
  * @param  nPacketLen payload length in bytes.
  * @retval None.
  */
__STATIC_INLINE void LL_MRSUBG_SetPacketLength(uint16_t nPacketLen)
{
10041e2c:	b580      	push	{r7, lr}
10041e2e:	b082      	sub	sp, #8
10041e30:	af00      	add	r7, sp, #0
10041e32:	0002      	movs	r2, r0
10041e34:	1dbb      	adds	r3, r7, #6
10041e36:	801a      	strh	r2, [r3, #0]
  MODIFY_REG_FIELD(MR_SUBG_GLOB_DYNAMIC->PCKTLEN_CONFIG, MR_SUBG_GLOB_DYNAMIC_PCKTLEN_CONFIG_PCKTLEN, nPacketLen);
10041e38:	4b06      	ldr	r3, [pc, #24]	@ (10041e54 <LL_MRSUBG_SetPacketLength+0x28>)
10041e3a:	681b      	ldr	r3, [r3, #0]
10041e3c:	0c1b      	lsrs	r3, r3, #16
10041e3e:	0419      	lsls	r1, r3, #16
10041e40:	1dbb      	adds	r3, r7, #6
10041e42:	881a      	ldrh	r2, [r3, #0]
10041e44:	4b03      	ldr	r3, [pc, #12]	@ (10041e54 <LL_MRSUBG_SetPacketLength+0x28>)
10041e46:	430a      	orrs	r2, r1
10041e48:	601a      	str	r2, [r3, #0]
}
10041e4a:	46c0      	nop			@ (mov r8, r8)
10041e4c:	46bd      	mov	sp, r7
10041e4e:	b002      	add	sp, #8
10041e50:	bd80      	pop	{r7, pc}
10041e52:	46c0      	nop			@ (mov r8, r8)
10041e54:	49000500 	.word	0x49000500

10041e58 <LL_MRSUBG_SetFixedVariableLength>:
  *    0: FIXED length mode (no LENGTH field added in the frame in TX and no decode in RX)
  *    1: VARIABLE length mode (LENGTH field put in the frame in TX and decoded in RX)
  * @retval None.
  */
__STATIC_INLINE void LL_MRSUBG_SetFixedVariableLength(MRSubG_LengthMode lenType)
{
10041e58:	b580      	push	{r7, lr}
10041e5a:	b082      	sub	sp, #8
10041e5c:	af00      	add	r7, sp, #0
10041e5e:	0002      	movs	r2, r0
10041e60:	1dfb      	adds	r3, r7, #7
10041e62:	701a      	strb	r2, [r3, #0]
  MODIFY_REG_FIELD(MR_SUBG_GLOB_STATIC->PCKT_CONFIG, MR_SUBG_GLOB_STATIC_PCKT_CONFIG_FIX_VAR_LEN, lenType);
10041e64:	4b08      	ldr	r3, [pc, #32]	@ (10041e88 <LL_MRSUBG_SetFixedVariableLength+0x30>)
10041e66:	681b      	ldr	r3, [r3, #0]
10041e68:	4a08      	ldr	r2, [pc, #32]	@ (10041e8c <LL_MRSUBG_SetFixedVariableLength+0x34>)
10041e6a:	4013      	ands	r3, r2
10041e6c:	0019      	movs	r1, r3
10041e6e:	1dfb      	adds	r3, r7, #7
10041e70:	781b      	ldrb	r3, [r3, #0]
10041e72:	02da      	lsls	r2, r3, #11
10041e74:	2380      	movs	r3, #128	@ 0x80
10041e76:	011b      	lsls	r3, r3, #4
10041e78:	401a      	ands	r2, r3
10041e7a:	4b03      	ldr	r3, [pc, #12]	@ (10041e88 <LL_MRSUBG_SetFixedVariableLength+0x30>)
10041e7c:	430a      	orrs	r2, r1
10041e7e:	601a      	str	r2, [r3, #0]
}
10041e80:	46c0      	nop			@ (mov r8, r8)
10041e82:	46bd      	mov	sp, r7
10041e84:	b002      	add	sp, #8
10041e86:	bd80      	pop	{r7, pc}
10041e88:	49000400 	.word	0x49000400
10041e8c:	fffff7ff 	.word	0xfffff7ff

10041e90 <LL_MRSubG_SetLenWidth>:
  * @brief  Indicates if the LENGTH field is defined on 1 byte or 2 bytes.
  * @param  lenWidth the length field to set.
  * @retval None.
  */
__STATIC_INLINE void LL_MRSubG_SetLenWidth(MRSubG_LenWidthhMode lenWidth)
{
10041e90:	b580      	push	{r7, lr}
10041e92:	b082      	sub	sp, #8
10041e94:	af00      	add	r7, sp, #0
10041e96:	0002      	movs	r2, r0
10041e98:	1dfb      	adds	r3, r7, #7
10041e9a:	701a      	strb	r2, [r3, #0]
  MODIFY_REG_FIELD(MR_SUBG_GLOB_STATIC->PCKT_CONFIG, MR_SUBG_GLOB_STATIC_PCKT_CONFIG_LEN_WIDTH, lenWidth);
10041e9c:	4b08      	ldr	r3, [pc, #32]	@ (10041ec0 <LL_MRSubG_SetLenWidth+0x30>)
10041e9e:	681b      	ldr	r3, [r3, #0]
10041ea0:	4a08      	ldr	r2, [pc, #32]	@ (10041ec4 <LL_MRSubG_SetLenWidth+0x34>)
10041ea2:	4013      	ands	r3, r2
10041ea4:	0019      	movs	r1, r3
10041ea6:	1dfb      	adds	r3, r7, #7
10041ea8:	781b      	ldrb	r3, [r3, #0]
10041eaa:	029a      	lsls	r2, r3, #10
10041eac:	2380      	movs	r3, #128	@ 0x80
10041eae:	00db      	lsls	r3, r3, #3
10041eb0:	401a      	ands	r2, r3
10041eb2:	4b03      	ldr	r3, [pc, #12]	@ (10041ec0 <LL_MRSubG_SetLenWidth+0x30>)
10041eb4:	430a      	orrs	r2, r1
10041eb6:	601a      	str	r2, [r3, #0]
}
10041eb8:	46c0      	nop			@ (mov r8, r8)
10041eba:	46bd      	mov	sp, r7
10041ebc:	b002      	add	sp, #8
10041ebe:	bd80      	pop	{r7, pc}
10041ec0:	49000400 	.word	0x49000400
10041ec4:	fffffbff 	.word	0xfffffbff

10041ec8 <MRSubG_ComputeSynthWord>:
  * @param  synth_frac pointer to the fract part of the synth word
  * @param  band pointer to the high/low band selector
  * @retval None.
  */
static void MRSubG_ComputeSynthWord(uint32_t frequency, uint8_t *synth_int, uint32_t *synth_frac, uint8_t *band)
{
10041ec8:	b5f0      	push	{r4, r5, r6, r7, lr}
10041eca:	b08b      	sub	sp, #44	@ 0x2c
10041ecc:	af00      	add	r7, sp, #0
10041ece:	6278      	str	r0, [r7, #36]	@ 0x24
10041ed0:	6239      	str	r1, [r7, #32]
10041ed2:	61fa      	str	r2, [r7, #28]
10041ed4:	61bb      	str	r3, [r7, #24]
  if (IS_FREQUENCY_BAND_HIGH(frequency))
10041ed6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10041ed8:	4a25      	ldr	r2, [pc, #148]	@ (10041f70 <MRSubG_ComputeSynthWord+0xa8>)
10041eda:	4293      	cmp	r3, r2
10041edc:	d907      	bls.n	10041eee <MRSubG_ComputeSynthWord+0x26>
10041ede:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10041ee0:	4a24      	ldr	r2, [pc, #144]	@ (10041f74 <MRSubG_ComputeSynthWord+0xac>)
10041ee2:	4293      	cmp	r3, r2
10041ee4:	d803      	bhi.n	10041eee <MRSubG_ComputeSynthWord+0x26>
  {
    *band = HIGH_BAND_FACTOR;
10041ee6:	69bb      	ldr	r3, [r7, #24]
10041ee8:	2204      	movs	r2, #4
10041eea:	701a      	strb	r2, [r3, #0]
10041eec:	e002      	b.n	10041ef4 <MRSubG_ComputeSynthWord+0x2c>
    *band = LOW_LOW_BAND_FACTOR;
  }
#endif /* STM32WL3RX */
  else
  {
    *band = LOW_BAND_FACTOR;
10041eee:	69bb      	ldr	r3, [r7, #24]
10041ef0:	2208      	movs	r2, #8
10041ef2:	701a      	strb	r2, [r3, #0]
  }

  *synth_int = (uint32_t)(*band * frequency / LL_GetXTALFreq());
10041ef4:	69bb      	ldr	r3, [r7, #24]
10041ef6:	781b      	ldrb	r3, [r3, #0]
10041ef8:	001a      	movs	r2, r3
10041efa:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10041efc:	4353      	muls	r3, r2
10041efe:	001e      	movs	r6, r3
10041f00:	f002 fade 	bl	100444c0 <LL_GetXTALFreq>
10041f04:	0003      	movs	r3, r0
10041f06:	0019      	movs	r1, r3
10041f08:	0030      	movs	r0, r6
10041f0a:	f7fe f8e3 	bl	100400d4 <__udivsi3>
10041f0e:	0003      	movs	r3, r0
10041f10:	b2da      	uxtb	r2, r3
10041f12:	6a3b      	ldr	r3, [r7, #32]
10041f14:	701a      	strb	r2, [r3, #0]

  *synth_frac = (uint32_t)(((*band * (uint64_t)frequency * (1 << 20)) / LL_GetXTALFreq()) - (*synth_int * (1 << 20)));
10041f16:	69bb      	ldr	r3, [r7, #24]
10041f18:	781b      	ldrb	r3, [r3, #0]
10041f1a:	613b      	str	r3, [r7, #16]
10041f1c:	2300      	movs	r3, #0
10041f1e:	617b      	str	r3, [r7, #20]
10041f20:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10041f22:	60bb      	str	r3, [r7, #8]
10041f24:	2300      	movs	r3, #0
10041f26:	60fb      	str	r3, [r7, #12]
10041f28:	68ba      	ldr	r2, [r7, #8]
10041f2a:	68fb      	ldr	r3, [r7, #12]
10041f2c:	6938      	ldr	r0, [r7, #16]
10041f2e:	6979      	ldr	r1, [r7, #20]
10041f30:	f7fe fa66 	bl	10040400 <__aeabi_lmul>
10041f34:	0002      	movs	r2, r0
10041f36:	000b      	movs	r3, r1
10041f38:	0b11      	lsrs	r1, r2, #12
10041f3a:	051d      	lsls	r5, r3, #20
10041f3c:	430d      	orrs	r5, r1
10041f3e:	0514      	lsls	r4, r2, #20
10041f40:	f002 fabe 	bl	100444c0 <LL_GetXTALFreq>
10041f44:	0003      	movs	r3, r0
10041f46:	603b      	str	r3, [r7, #0]
10041f48:	2300      	movs	r3, #0
10041f4a:	607b      	str	r3, [r7, #4]
10041f4c:	683a      	ldr	r2, [r7, #0]
10041f4e:	687b      	ldr	r3, [r7, #4]
10041f50:	0020      	movs	r0, r4
10041f52:	0029      	movs	r1, r5
10041f54:	f7fe fa34 	bl	100403c0 <__aeabi_uldivmod>
10041f58:	0002      	movs	r2, r0
10041f5a:	000b      	movs	r3, r1
10041f5c:	6a3b      	ldr	r3, [r7, #32]
10041f5e:	781b      	ldrb	r3, [r3, #0]
10041f60:	051b      	lsls	r3, r3, #20
10041f62:	1ad2      	subs	r2, r2, r3
10041f64:	69fb      	ldr	r3, [r7, #28]
10041f66:	601a      	str	r2, [r3, #0]
}
10041f68:	46c0      	nop			@ (mov r8, r8)
10041f6a:	46bd      	mov	sp, r7
10041f6c:	b00b      	add	sp, #44	@ 0x2c
10041f6e:	bdf0      	pop	{r4, r5, r6, r7, pc}
10041f70:	313bc27f 	.word	0x313bc27f
10041f74:	3919eb80 	.word	0x3919eb80

10041f78 <MRSubG_ComputeDatarate>:
  * @param  cM the mantissa value.
  * @param  cE the exponent value.
  * @retval The datarate.
  */
static uint32_t MRSubG_ComputeDatarate(uint16_t cM, uint8_t cE)
{
10041f78:	b5f0      	push	{r4, r5, r6, r7, lr}
10041f7a:	b093      	sub	sp, #76	@ 0x4c
10041f7c:	af00      	add	r7, sp, #0
10041f7e:	0003      	movs	r3, r0
10041f80:	2236      	movs	r2, #54	@ 0x36
10041f82:	18ba      	adds	r2, r7, r2
10041f84:	8013      	strh	r3, [r2, #0]
10041f86:	2635      	movs	r6, #53	@ 0x35
10041f88:	19ba      	adds	r2, r7, r6
10041f8a:	1c0b      	adds	r3, r1, #0
10041f8c:	7013      	strb	r3, [r2, #0]
  uint32_t f_sys = LL_GetXTALFreq() / 3; /* 16 MHz nominal */
10041f8e:	f002 fa97 	bl	100444c0 <LL_GetXTALFreq>
10041f92:	0003      	movs	r3, r0
10041f94:	2103      	movs	r1, #3
10041f96:	0018      	movs	r0, r3
10041f98:	f7fe f89c 	bl	100400d4 <__udivsi3>
10041f9c:	0003      	movs	r3, r0
10041f9e:	647b      	str	r3, [r7, #68]	@ 0x44
  uint64_t dr;

  if (cE == 0)
10041fa0:	19bb      	adds	r3, r7, r6
10041fa2:	781b      	ldrb	r3, [r3, #0]
10041fa4:	2b00      	cmp	r3, #0
10041fa6:	d11b      	bne.n	10041fe0 <MRSubG_ComputeDatarate+0x68>
  {
    dr = ((uint64_t)f_sys * cM);
10041fa8:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
10041faa:	62bb      	str	r3, [r7, #40]	@ 0x28
10041fac:	2300      	movs	r3, #0
10041fae:	62fb      	str	r3, [r7, #44]	@ 0x2c
10041fb0:	2336      	movs	r3, #54	@ 0x36
10041fb2:	18fb      	adds	r3, r7, r3
10041fb4:	881b      	ldrh	r3, [r3, #0]
10041fb6:	b29b      	uxth	r3, r3
10041fb8:	623b      	str	r3, [r7, #32]
10041fba:	2300      	movs	r3, #0
10041fbc:	627b      	str	r3, [r7, #36]	@ 0x24
10041fbe:	6a3a      	ldr	r2, [r7, #32]
10041fc0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10041fc2:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
10041fc4:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
10041fc6:	f7fe fa1b 	bl	10040400 <__aeabi_lmul>
10041fca:	0002      	movs	r2, r0
10041fcc:	000b      	movs	r3, r1
10041fce:	63ba      	str	r2, [r7, #56]	@ 0x38
10041fd0:	63fb      	str	r3, [r7, #60]	@ 0x3c
    return (uint32_t)(dr >> 32);
10041fd2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
10041fd4:	001b      	movs	r3, r3
10041fd6:	61bb      	str	r3, [r7, #24]
10041fd8:	2300      	movs	r3, #0
10041fda:	61fb      	str	r3, [r7, #28]
10041fdc:	69bb      	ldr	r3, [r7, #24]
10041fde:	e045      	b.n	1004206c <MRSubG_ComputeDatarate+0xf4>
  }
  else if (cE == 15)
10041fe0:	2335      	movs	r3, #53	@ 0x35
10041fe2:	18fb      	adds	r3, r7, r3
10041fe4:	781b      	ldrb	r3, [r3, #0]
10041fe6:	2b0f      	cmp	r3, #15
10041fe8:	d10a      	bne.n	10042000 <MRSubG_ComputeDatarate+0x88>
  {
    return ((uint64_t)f_sys * (8 * cM));
10041fea:	2336      	movs	r3, #54	@ 0x36
10041fec:	18fb      	adds	r3, r7, r3
10041fee:	881b      	ldrh	r3, [r3, #0]
10041ff0:	00db      	lsls	r3, r3, #3
10041ff2:	613b      	str	r3, [r7, #16]
10041ff4:	17db      	asrs	r3, r3, #31
10041ff6:	617b      	str	r3, [r7, #20]
10041ff8:	693a      	ldr	r2, [r7, #16]
10041ffa:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
10041ffc:	4353      	muls	r3, r2
10041ffe:	e035      	b.n	1004206c <MRSubG_ComputeDatarate+0xf4>
  }
  else
  {
    dr = ((uint64_t)f_sys) * ((uint64_t)cM + 65536);
10042000:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
10042002:	60bb      	str	r3, [r7, #8]
10042004:	2300      	movs	r3, #0
10042006:	60fb      	str	r3, [r7, #12]
10042008:	2336      	movs	r3, #54	@ 0x36
1004200a:	18fb      	adds	r3, r7, r3
1004200c:	881b      	ldrh	r3, [r3, #0]
1004200e:	b29b      	uxth	r3, r3
10042010:	603b      	str	r3, [r7, #0]
10042012:	2300      	movs	r3, #0
10042014:	607b      	str	r3, [r7, #4]
10042016:	2280      	movs	r2, #128	@ 0x80
10042018:	0252      	lsls	r2, r2, #9
1004201a:	2300      	movs	r3, #0
1004201c:	6838      	ldr	r0, [r7, #0]
1004201e:	6879      	ldr	r1, [r7, #4]
10042020:	1880      	adds	r0, r0, r2
10042022:	4159      	adcs	r1, r3
10042024:	0002      	movs	r2, r0
10042026:	000b      	movs	r3, r1
10042028:	68b8      	ldr	r0, [r7, #8]
1004202a:	68f9      	ldr	r1, [r7, #12]
1004202c:	f7fe f9e8 	bl	10040400 <__aeabi_lmul>
10042030:	0002      	movs	r2, r0
10042032:	000b      	movs	r3, r1
10042034:	63ba      	str	r2, [r7, #56]	@ 0x38
10042036:	63fb      	str	r3, [r7, #60]	@ 0x3c
    return (uint32_t)(dr >> (33 - cE));
10042038:	2335      	movs	r3, #53	@ 0x35
1004203a:	18fb      	adds	r3, r7, r3
1004203c:	781b      	ldrb	r3, [r3, #0]
1004203e:	2221      	movs	r2, #33	@ 0x21
10042040:	1ad3      	subs	r3, r2, r3
10042042:	001a      	movs	r2, r3
10042044:	3a20      	subs	r2, #32
10042046:	2a00      	cmp	r2, #0
10042048:	db03      	blt.n	10042052 <MRSubG_ComputeDatarate+0xda>
1004204a:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
1004204c:	40d1      	lsrs	r1, r2
1004204e:	000c      	movs	r4, r1
10042050:	e008      	b.n	10042064 <MRSubG_ComputeDatarate+0xec>
10042052:	2220      	movs	r2, #32
10042054:	1ad2      	subs	r2, r2, r3
10042056:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
10042058:	4091      	lsls	r1, r2
1004205a:	000a      	movs	r2, r1
1004205c:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
1004205e:	40d9      	lsrs	r1, r3
10042060:	000c      	movs	r4, r1
10042062:	4314      	orrs	r4, r2
10042064:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
10042066:	40da      	lsrs	r2, r3
10042068:	0015      	movs	r5, r2
1004206a:	0023      	movs	r3, r4
  }
}
1004206c:	0018      	movs	r0, r3
1004206e:	46bd      	mov	sp, r7
10042070:	b013      	add	sp, #76	@ 0x4c
10042072:	bdf0      	pop	{r4, r5, r6, r7, pc}

10042074 <MRSubG_SearchDatarateME>:

static void MRSubG_SearchDatarateME(uint32_t lDatarate, uint16_t *pcM, uint8_t *pcE)
{
10042074:	b5f0      	push	{r4, r5, r6, r7, lr}
10042076:	b0a5      	sub	sp, #148	@ 0x94
10042078:	af00      	add	r7, sp, #0
1004207a:	6678      	str	r0, [r7, #100]	@ 0x64
1004207c:	6639      	str	r1, [r7, #96]	@ 0x60
1004207e:	65fa      	str	r2, [r7, #92]	@ 0x5c
  uint32_t lDatarateTmp;
  uint32_t f_sys = LL_GetXTALFreq() / 3;
10042080:	f002 fa1e 	bl	100444c0 <LL_GetXTALFreq>
10042084:	0003      	movs	r3, r0
10042086:	2103      	movs	r1, #3
10042088:	0018      	movs	r0, r3
1004208a:	f7fe f823 	bl	100400d4 <__udivsi3>
1004208e:	0003      	movs	r3, r0
10042090:	66fb      	str	r3, [r7, #108]	@ 0x6c
  uint64_t tgt1;
  uint64_t tgt2;
  uint64_t tgt;

  /* Search the exponent value */
  for (uDrE = 0; uDrE < 16; uDrE++)
10042092:	2337      	movs	r3, #55	@ 0x37
10042094:	2258      	movs	r2, #88	@ 0x58
10042096:	189b      	adds	r3, r3, r2
10042098:	19da      	adds	r2, r3, r7
1004209a:	2300      	movs	r3, #0
1004209c:	7013      	strb	r3, [r2, #0]
1004209e:	e017      	b.n	100420d0 <MRSubG_SearchDatarateME+0x5c>
  {
    lDatarateTmp = MRSubG_ComputeDatarate(0xFFFF, uDrE);
100420a0:	2637      	movs	r6, #55	@ 0x37
100420a2:	2258      	movs	r2, #88	@ 0x58
100420a4:	18b3      	adds	r3, r6, r2
100420a6:	19db      	adds	r3, r3, r7
100420a8:	781b      	ldrb	r3, [r3, #0]
100420aa:	4a75      	ldr	r2, [pc, #468]	@ (10042280 <MRSubG_SearchDatarateME+0x20c>)
100420ac:	0019      	movs	r1, r3
100420ae:	0010      	movs	r0, r2
100420b0:	f7ff ff62 	bl	10041f78 <MRSubG_ComputeDatarate>
100420b4:	0003      	movs	r3, r0
100420b6:	66bb      	str	r3, [r7, #104]	@ 0x68
    if (lDatarate <= lDatarateTmp)
100420b8:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
100420ba:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
100420bc:	429a      	cmp	r2, r3
100420be:	d90f      	bls.n	100420e0 <MRSubG_SearchDatarateME+0x6c>
  for (uDrE = 0; uDrE < 16; uDrE++)
100420c0:	2258      	movs	r2, #88	@ 0x58
100420c2:	18b3      	adds	r3, r6, r2
100420c4:	19db      	adds	r3, r3, r7
100420c6:	781b      	ldrb	r3, [r3, #0]
100420c8:	18b2      	adds	r2, r6, r2
100420ca:	19d2      	adds	r2, r2, r7
100420cc:	3301      	adds	r3, #1
100420ce:	7013      	strb	r3, [r2, #0]
100420d0:	2337      	movs	r3, #55	@ 0x37
100420d2:	2258      	movs	r2, #88	@ 0x58
100420d4:	189b      	adds	r3, r3, r2
100420d6:	19db      	adds	r3, r3, r7
100420d8:	781b      	ldrb	r3, [r3, #0]
100420da:	2b0f      	cmp	r3, #15
100420dc:	d9e0      	bls.n	100420a0 <MRSubG_SearchDatarateME+0x2c>
100420de:	e000      	b.n	100420e2 <MRSubG_SearchDatarateME+0x6e>
    {
      break;
100420e0:	46c0      	nop			@ (mov r8, r8)
    }
  }
  (*pcE) = (uint8_t)uDrE;
100420e2:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
100420e4:	2137      	movs	r1, #55	@ 0x37
100420e6:	2058      	movs	r0, #88	@ 0x58
100420e8:	180b      	adds	r3, r1, r0
100420ea:	19db      	adds	r3, r3, r7
100420ec:	781b      	ldrb	r3, [r3, #0]
100420ee:	7013      	strb	r3, [r2, #0]

  if (uDrE == 0)
100420f0:	180b      	adds	r3, r1, r0
100420f2:	19db      	adds	r3, r3, r7
100420f4:	781b      	ldrb	r3, [r3, #0]
100420f6:	2b00      	cmp	r3, #0
100420f8:	d141      	bne.n	1004217e <MRSubG_SearchDatarateME+0x10a>
  {
    tgt = ((uint64_t)lDatarate) << 32;
100420fa:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
100420fc:	653b      	str	r3, [r7, #80]	@ 0x50
100420fe:	2300      	movs	r3, #0
10042100:	657b      	str	r3, [r7, #84]	@ 0x54
10042102:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
10042104:	001b      	movs	r3, r3
10042106:	677b      	str	r3, [r7, #116]	@ 0x74
10042108:	2300      	movs	r3, #0
1004210a:	673b      	str	r3, [r7, #112]	@ 0x70
    (*pcM) = (uint16_t)(tgt / f_sys);
1004210c:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
1004210e:	64bb      	str	r3, [r7, #72]	@ 0x48
10042110:	2300      	movs	r3, #0
10042112:	64fb      	str	r3, [r7, #76]	@ 0x4c
10042114:	6cba      	ldr	r2, [r7, #72]	@ 0x48
10042116:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
10042118:	6f38      	ldr	r0, [r7, #112]	@ 0x70
1004211a:	6f79      	ldr	r1, [r7, #116]	@ 0x74
1004211c:	f7fe f950 	bl	100403c0 <__aeabi_uldivmod>
10042120:	0002      	movs	r2, r0
10042122:	000b      	movs	r3, r1
10042124:	b292      	uxth	r2, r2
10042126:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
10042128:	801a      	strh	r2, [r3, #0]
    tgt1 = (uint64_t)f_sys * (*pcM);
1004212a:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
1004212c:	643b      	str	r3, [r7, #64]	@ 0x40
1004212e:	2300      	movs	r3, #0
10042130:	647b      	str	r3, [r7, #68]	@ 0x44
10042132:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
10042134:	881b      	ldrh	r3, [r3, #0]
10042136:	63bb      	str	r3, [r7, #56]	@ 0x38
10042138:	2300      	movs	r3, #0
1004213a:	63fb      	str	r3, [r7, #60]	@ 0x3c
1004213c:	6bba      	ldr	r2, [r7, #56]	@ 0x38
1004213e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
10042140:	6c38      	ldr	r0, [r7, #64]	@ 0x40
10042142:	6c79      	ldr	r1, [r7, #68]	@ 0x44
10042144:	f7fe f95c 	bl	10040400 <__aeabi_lmul>
10042148:	0002      	movs	r2, r0
1004214a:	000b      	movs	r3, r1
1004214c:	2180      	movs	r1, #128	@ 0x80
1004214e:	1879      	adds	r1, r7, r1
10042150:	600a      	str	r2, [r1, #0]
10042152:	604b      	str	r3, [r1, #4]
    tgt2 = (uint64_t)f_sys * ((*pcM) + 1);
10042154:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
10042156:	633b      	str	r3, [r7, #48]	@ 0x30
10042158:	2300      	movs	r3, #0
1004215a:	637b      	str	r3, [r7, #52]	@ 0x34
1004215c:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
1004215e:	881b      	ldrh	r3, [r3, #0]
10042160:	3301      	adds	r3, #1
10042162:	62bb      	str	r3, [r7, #40]	@ 0x28
10042164:	17db      	asrs	r3, r3, #31
10042166:	62fb      	str	r3, [r7, #44]	@ 0x2c
10042168:	6aba      	ldr	r2, [r7, #40]	@ 0x28
1004216a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
1004216c:	6b38      	ldr	r0, [r7, #48]	@ 0x30
1004216e:	6b79      	ldr	r1, [r7, #52]	@ 0x34
10042170:	f7fe f946 	bl	10040400 <__aeabi_lmul>
10042174:	0002      	movs	r2, r0
10042176:	000b      	movs	r3, r1
10042178:	67ba      	str	r2, [r7, #120]	@ 0x78
1004217a:	67fb      	str	r3, [r7, #124]	@ 0x7c
1004217c:	e05c      	b.n	10042238 <MRSubG_SearchDatarateME+0x1c4>
  }
  else
  {
    tgt = ((uint64_t)lDatarate) << (33 - uDrE);
1004217e:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
10042180:	001c      	movs	r4, r3
10042182:	2300      	movs	r3, #0
10042184:	001d      	movs	r5, r3
10042186:	2337      	movs	r3, #55	@ 0x37
10042188:	2258      	movs	r2, #88	@ 0x58
1004218a:	189b      	adds	r3, r3, r2
1004218c:	19db      	adds	r3, r3, r7
1004218e:	781a      	ldrb	r2, [r3, #0]
10042190:	2321      	movs	r3, #33	@ 0x21
10042192:	1a99      	subs	r1, r3, r2
10042194:	000b      	movs	r3, r1
10042196:	3b20      	subs	r3, #32
10042198:	2b00      	cmp	r3, #0
1004219a:	db04      	blt.n	100421a6 <MRSubG_SearchDatarateME+0x132>
1004219c:	0022      	movs	r2, r4
1004219e:	409a      	lsls	r2, r3
100421a0:	0013      	movs	r3, r2
100421a2:	677b      	str	r3, [r7, #116]	@ 0x74
100421a4:	e007      	b.n	100421b6 <MRSubG_SearchDatarateME+0x142>
100421a6:	2320      	movs	r3, #32
100421a8:	1a5b      	subs	r3, r3, r1
100421aa:	0022      	movs	r2, r4
100421ac:	40da      	lsrs	r2, r3
100421ae:	002b      	movs	r3, r5
100421b0:	408b      	lsls	r3, r1
100421b2:	4313      	orrs	r3, r2
100421b4:	677b      	str	r3, [r7, #116]	@ 0x74
100421b6:	0023      	movs	r3, r4
100421b8:	408b      	lsls	r3, r1
100421ba:	673b      	str	r3, [r7, #112]	@ 0x70
    (*pcM) = (uint16_t)((tgt / f_sys) - 65536);
100421bc:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
100421be:	623b      	str	r3, [r7, #32]
100421c0:	2300      	movs	r3, #0
100421c2:	627b      	str	r3, [r7, #36]	@ 0x24
100421c4:	6a3a      	ldr	r2, [r7, #32]
100421c6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
100421c8:	6f38      	ldr	r0, [r7, #112]	@ 0x70
100421ca:	6f79      	ldr	r1, [r7, #116]	@ 0x74
100421cc:	f7fe f8f8 	bl	100403c0 <__aeabi_uldivmod>
100421d0:	0002      	movs	r2, r0
100421d2:	000b      	movs	r3, r1
100421d4:	b292      	uxth	r2, r2
100421d6:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
100421d8:	801a      	strh	r2, [r3, #0]
    tgt1 = (uint64_t)f_sys * ((*pcM) + 65536);
100421da:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
100421dc:	61bb      	str	r3, [r7, #24]
100421de:	2300      	movs	r3, #0
100421e0:	61fb      	str	r3, [r7, #28]
100421e2:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
100421e4:	881b      	ldrh	r3, [r3, #0]
100421e6:	2280      	movs	r2, #128	@ 0x80
100421e8:	0252      	lsls	r2, r2, #9
100421ea:	4694      	mov	ip, r2
100421ec:	4463      	add	r3, ip
100421ee:	613b      	str	r3, [r7, #16]
100421f0:	17db      	asrs	r3, r3, #31
100421f2:	617b      	str	r3, [r7, #20]
100421f4:	693a      	ldr	r2, [r7, #16]
100421f6:	697b      	ldr	r3, [r7, #20]
100421f8:	69b8      	ldr	r0, [r7, #24]
100421fa:	69f9      	ldr	r1, [r7, #28]
100421fc:	f7fe f900 	bl	10040400 <__aeabi_lmul>
10042200:	0002      	movs	r2, r0
10042202:	000b      	movs	r3, r1
10042204:	2180      	movs	r1, #128	@ 0x80
10042206:	1879      	adds	r1, r7, r1
10042208:	600a      	str	r2, [r1, #0]
1004220a:	604b      	str	r3, [r1, #4]
    tgt2 = (uint64_t)f_sys * ((*pcM) + 1 + 65536);
1004220c:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
1004220e:	60bb      	str	r3, [r7, #8]
10042210:	2300      	movs	r3, #0
10042212:	60fb      	str	r3, [r7, #12]
10042214:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
10042216:	881b      	ldrh	r3, [r3, #0]
10042218:	4a1a      	ldr	r2, [pc, #104]	@ (10042284 <MRSubG_SearchDatarateME+0x210>)
1004221a:	4694      	mov	ip, r2
1004221c:	4463      	add	r3, ip
1004221e:	603b      	str	r3, [r7, #0]
10042220:	17db      	asrs	r3, r3, #31
10042222:	607b      	str	r3, [r7, #4]
10042224:	683a      	ldr	r2, [r7, #0]
10042226:	687b      	ldr	r3, [r7, #4]
10042228:	68b8      	ldr	r0, [r7, #8]
1004222a:	68f9      	ldr	r1, [r7, #12]
1004222c:	f7fe f8e8 	bl	10040400 <__aeabi_lmul>
10042230:	0002      	movs	r2, r0
10042232:	000b      	movs	r3, r1
10042234:	67ba      	str	r2, [r7, #120]	@ 0x78
10042236:	67fb      	str	r3, [r7, #124]	@ 0x7c
  }

  (*pcM) = ((tgt2 - tgt) < (tgt - tgt1)) ? ((*pcM) + 1) : (*pcM);
10042238:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
1004223a:	6ff9      	ldr	r1, [r7, #124]	@ 0x7c
1004223c:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
1004223e:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
10042240:	1a80      	subs	r0, r0, r2
10042242:	4199      	sbcs	r1, r3
10042244:	0002      	movs	r2, r0
10042246:	000b      	movs	r3, r1
10042248:	6f3c      	ldr	r4, [r7, #112]	@ 0x70
1004224a:	6f7d      	ldr	r5, [r7, #116]	@ 0x74
1004224c:	2180      	movs	r1, #128	@ 0x80
1004224e:	1879      	adds	r1, r7, r1
10042250:	6808      	ldr	r0, [r1, #0]
10042252:	6849      	ldr	r1, [r1, #4]
10042254:	1a24      	subs	r4, r4, r0
10042256:	418d      	sbcs	r5, r1
10042258:	0020      	movs	r0, r4
1004225a:	0029      	movs	r1, r5
1004225c:	4299      	cmp	r1, r3
1004225e:	d802      	bhi.n	10042266 <MRSubG_SearchDatarateME+0x1f2>
10042260:	d106      	bne.n	10042270 <MRSubG_SearchDatarateME+0x1fc>
10042262:	4290      	cmp	r0, r2
10042264:	d904      	bls.n	10042270 <MRSubG_SearchDatarateME+0x1fc>
10042266:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
10042268:	881b      	ldrh	r3, [r3, #0]
1004226a:	3301      	adds	r3, #1
1004226c:	b29b      	uxth	r3, r3
1004226e:	e001      	b.n	10042274 <MRSubG_SearchDatarateME+0x200>
10042270:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
10042272:	881b      	ldrh	r3, [r3, #0]
10042274:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
10042276:	8013      	strh	r3, [r2, #0]
}
10042278:	46c0      	nop			@ (mov r8, r8)
1004227a:	46bd      	mov	sp, r7
1004227c:	b025      	add	sp, #148	@ 0x94
1004227e:	bdf0      	pop	{r4, r5, r6, r7, pc}
10042280:	0000ffff 	.word	0x0000ffff
10042284:	00010001 	.word	0x00010001

10042288 <MRSubG_ComputeFreqDeviation>:
  * @param  cE the exponent value.
  * @param  bs the band value.
  * @retval The frequency deviation.
  */
static uint32_t MRSubG_ComputeFreqDeviation(uint8_t cM, uint8_t cE, uint8_t bs)
{
10042288:	b5f0      	push	{r4, r5, r6, r7, lr}
1004228a:	b08f      	sub	sp, #60	@ 0x3c
1004228c:	af00      	add	r7, sp, #0
1004228e:	0003      	movs	r3, r0
10042290:	0010      	movs	r0, r2
10042292:	222f      	movs	r2, #47	@ 0x2f
10042294:	18ba      	adds	r2, r7, r2
10042296:	7013      	strb	r3, [r2, #0]
10042298:	232e      	movs	r3, #46	@ 0x2e
1004229a:	18fa      	adds	r2, r7, r3
1004229c:	1c0b      	adds	r3, r1, #0
1004229e:	7013      	strb	r3, [r2, #0]
100422a0:	262d      	movs	r6, #45	@ 0x2d
100422a2:	19ba      	adds	r2, r7, r6
100422a4:	1c03      	adds	r3, r0, #0
100422a6:	7013      	strb	r3, [r2, #0]
  uint32_t f_xo = LL_GetXTALFreq();
100422a8:	f002 f90a 	bl	100444c0 <LL_GetXTALFreq>
100422ac:	0003      	movs	r3, r0
100422ae:	637b      	str	r3, [r7, #52]	@ 0x34

  if (cE == 0)
100422b0:	232e      	movs	r3, #46	@ 0x2e
100422b2:	18fb      	adds	r3, r7, r3
100422b4:	781b      	ldrb	r3, [r3, #0]
100422b6:	2b00      	cmp	r3, #0
100422b8:	d129      	bne.n	1004230e <MRSubG_ComputeFreqDeviation+0x86>
  {
    return (uint32_t)((uint64_t)f_xo * (cM * bs / 8) / (bs * (1 << 19)));
100422ba:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
100422bc:	623b      	str	r3, [r7, #32]
100422be:	2300      	movs	r3, #0
100422c0:	627b      	str	r3, [r7, #36]	@ 0x24
100422c2:	232f      	movs	r3, #47	@ 0x2f
100422c4:	18fb      	adds	r3, r7, r3
100422c6:	781b      	ldrb	r3, [r3, #0]
100422c8:	19ba      	adds	r2, r7, r6
100422ca:	7812      	ldrb	r2, [r2, #0]
100422cc:	4353      	muls	r3, r2
100422ce:	2b00      	cmp	r3, #0
100422d0:	da00      	bge.n	100422d4 <MRSubG_ComputeFreqDeviation+0x4c>
100422d2:	3307      	adds	r3, #7
100422d4:	10db      	asrs	r3, r3, #3
100422d6:	61bb      	str	r3, [r7, #24]
100422d8:	17db      	asrs	r3, r3, #31
100422da:	61fb      	str	r3, [r7, #28]
100422dc:	69ba      	ldr	r2, [r7, #24]
100422de:	69fb      	ldr	r3, [r7, #28]
100422e0:	6a38      	ldr	r0, [r7, #32]
100422e2:	6a79      	ldr	r1, [r7, #36]	@ 0x24
100422e4:	f7fe f88c 	bl	10040400 <__aeabi_lmul>
100422e8:	0002      	movs	r2, r0
100422ea:	000b      	movs	r3, r1
100422ec:	0010      	movs	r0, r2
100422ee:	0019      	movs	r1, r3
100422f0:	232d      	movs	r3, #45	@ 0x2d
100422f2:	18fb      	adds	r3, r7, r3
100422f4:	781b      	ldrb	r3, [r3, #0]
100422f6:	04db      	lsls	r3, r3, #19
100422f8:	613b      	str	r3, [r7, #16]
100422fa:	17db      	asrs	r3, r3, #31
100422fc:	617b      	str	r3, [r7, #20]
100422fe:	693a      	ldr	r2, [r7, #16]
10042300:	697b      	ldr	r3, [r7, #20]
10042302:	f7fe f85d 	bl	100403c0 <__aeabi_uldivmod>
10042306:	0002      	movs	r2, r0
10042308:	000b      	movs	r3, r1
1004230a:	0013      	movs	r3, r2
1004230c:	e031      	b.n	10042372 <MRSubG_ComputeFreqDeviation+0xea>
  }

  return (uint32_t)((uint64_t)f_xo * ((256 + cM) * (1 << (cE - 1)) * bs / 8) / (bs * (1 << 19)));;
1004230e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
10042310:	60bb      	str	r3, [r7, #8]
10042312:	2300      	movs	r3, #0
10042314:	60fb      	str	r3, [r7, #12]
10042316:	232f      	movs	r3, #47	@ 0x2f
10042318:	18fb      	adds	r3, r7, r3
1004231a:	781b      	ldrb	r3, [r3, #0]
1004231c:	1c5a      	adds	r2, r3, #1
1004231e:	32ff      	adds	r2, #255	@ 0xff
10042320:	232e      	movs	r3, #46	@ 0x2e
10042322:	18fb      	adds	r3, r7, r3
10042324:	781b      	ldrb	r3, [r3, #0]
10042326:	3b01      	subs	r3, #1
10042328:	409a      	lsls	r2, r3
1004232a:	0013      	movs	r3, r2
1004232c:	222d      	movs	r2, #45	@ 0x2d
1004232e:	18ba      	adds	r2, r7, r2
10042330:	7812      	ldrb	r2, [r2, #0]
10042332:	4353      	muls	r3, r2
10042334:	2b00      	cmp	r3, #0
10042336:	da00      	bge.n	1004233a <MRSubG_ComputeFreqDeviation+0xb2>
10042338:	3307      	adds	r3, #7
1004233a:	10db      	asrs	r3, r3, #3
1004233c:	603b      	str	r3, [r7, #0]
1004233e:	17db      	asrs	r3, r3, #31
10042340:	607b      	str	r3, [r7, #4]
10042342:	683a      	ldr	r2, [r7, #0]
10042344:	687b      	ldr	r3, [r7, #4]
10042346:	68b8      	ldr	r0, [r7, #8]
10042348:	68f9      	ldr	r1, [r7, #12]
1004234a:	f7fe f859 	bl	10040400 <__aeabi_lmul>
1004234e:	0002      	movs	r2, r0
10042350:	000b      	movs	r3, r1
10042352:	0010      	movs	r0, r2
10042354:	0019      	movs	r1, r3
10042356:	232d      	movs	r3, #45	@ 0x2d
10042358:	18fb      	adds	r3, r7, r3
1004235a:	781b      	ldrb	r3, [r3, #0]
1004235c:	04db      	lsls	r3, r3, #19
1004235e:	001c      	movs	r4, r3
10042360:	17db      	asrs	r3, r3, #31
10042362:	001d      	movs	r5, r3
10042364:	0022      	movs	r2, r4
10042366:	002b      	movs	r3, r5
10042368:	f7fe f82a 	bl	100403c0 <__aeabi_uldivmod>
1004236c:	0002      	movs	r2, r0
1004236e:	000b      	movs	r3, r1
10042370:	0013      	movs	r3, r2
}
10042372:	0018      	movs	r0, r3
10042374:	46bd      	mov	sp, r7
10042376:	b00f      	add	sp, #60	@ 0x3c
10042378:	bdf0      	pop	{r4, r5, r6, r7, pc}

1004237a <MRSubG_SearchFreqDevME>:
  * @param  pcE pointer to the returned exponent value.
  * @param  bs the high/low band selector
  * @retval None.
  */
static void MRSubG_SearchFreqDevME(uint32_t lFDev, uint8_t *pcM, uint8_t *pcE, uint8_t bs)
{
1004237a:	b5f0      	push	{r4, r5, r6, r7, lr}
1004237c:	b0a5      	sub	sp, #148	@ 0x94
1004237e:	af00      	add	r7, sp, #0
10042380:	6678      	str	r0, [r7, #100]	@ 0x64
10042382:	6639      	str	r1, [r7, #96]	@ 0x60
10042384:	65fa      	str	r2, [r7, #92]	@ 0x5c
10042386:	225b      	movs	r2, #91	@ 0x5b
10042388:	18ba      	adds	r2, r7, r2
1004238a:	7013      	strb	r3, [r2, #0]
  uint64_t tgt1;
  uint64_t tgt2;
  uint64_t tgt;

  /* Search the exponent of the frequency deviation value */
  for (uFDevE = 0; uFDevE != 12; uFDevE++)
1004238c:	2337      	movs	r3, #55	@ 0x37
1004238e:	2258      	movs	r2, #88	@ 0x58
10042390:	189b      	adds	r3, r3, r2
10042392:	19da      	adds	r2, r3, r7
10042394:	2300      	movs	r3, #0
10042396:	7013      	strb	r3, [r2, #0]
10042398:	e019      	b.n	100423ce <MRSubG_SearchFreqDevME+0x54>
  {
    lFDevTmp = MRSubG_ComputeFreqDeviation(255, uFDevE, bs);
1004239a:	235b      	movs	r3, #91	@ 0x5b
1004239c:	18fb      	adds	r3, r7, r3
1004239e:	781a      	ldrb	r2, [r3, #0]
100423a0:	2637      	movs	r6, #55	@ 0x37
100423a2:	2358      	movs	r3, #88	@ 0x58
100423a4:	18f1      	adds	r1, r6, r3
100423a6:	19cb      	adds	r3, r1, r7
100423a8:	781b      	ldrb	r3, [r3, #0]
100423aa:	0019      	movs	r1, r3
100423ac:	20ff      	movs	r0, #255	@ 0xff
100423ae:	f7ff ff6b 	bl	10042288 <MRSubG_ComputeFreqDeviation>
100423b2:	0003      	movs	r3, r0
100423b4:	66fb      	str	r3, [r7, #108]	@ 0x6c
    if (lFDev < lFDevTmp)
100423b6:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
100423b8:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
100423ba:	429a      	cmp	r2, r3
100423bc:	d30f      	bcc.n	100423de <MRSubG_SearchFreqDevME+0x64>
  for (uFDevE = 0; uFDevE != 12; uFDevE++)
100423be:	2258      	movs	r2, #88	@ 0x58
100423c0:	18b3      	adds	r3, r6, r2
100423c2:	19db      	adds	r3, r3, r7
100423c4:	781b      	ldrb	r3, [r3, #0]
100423c6:	18b2      	adds	r2, r6, r2
100423c8:	19d2      	adds	r2, r2, r7
100423ca:	3301      	adds	r3, #1
100423cc:	7013      	strb	r3, [r2, #0]
100423ce:	2337      	movs	r3, #55	@ 0x37
100423d0:	2258      	movs	r2, #88	@ 0x58
100423d2:	189b      	adds	r3, r3, r2
100423d4:	19db      	adds	r3, r3, r7
100423d6:	781b      	ldrb	r3, [r3, #0]
100423d8:	2b0c      	cmp	r3, #12
100423da:	d1de      	bne.n	1004239a <MRSubG_SearchFreqDevME+0x20>
100423dc:	e000      	b.n	100423e0 <MRSubG_SearchFreqDevME+0x66>
    {
      break;
100423de:	46c0      	nop			@ (mov r8, r8)
    }
  }
  (*pcE) = (uint8_t)uFDevE;
100423e0:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
100423e2:	2137      	movs	r1, #55	@ 0x37
100423e4:	2058      	movs	r0, #88	@ 0x58
100423e6:	180b      	adds	r3, r1, r0
100423e8:	19db      	adds	r3, r3, r7
100423ea:	781b      	ldrb	r3, [r3, #0]
100423ec:	7013      	strb	r3, [r2, #0]

  if (uFDevE == 0)
100423ee:	180b      	adds	r3, r1, r0
100423f0:	19db      	adds	r3, r3, r7
100423f2:	781b      	ldrb	r3, [r3, #0]
100423f4:	2b00      	cmp	r3, #0
100423f6:	d14d      	bne.n	10042494 <MRSubG_SearchFreqDevME+0x11a>
  {
    tgt = ((uint64_t)lFDev) << 22;
100423f8:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
100423fa:	653b      	str	r3, [r7, #80]	@ 0x50
100423fc:	2300      	movs	r3, #0
100423fe:	657b      	str	r3, [r7, #84]	@ 0x54
10042400:	6d38      	ldr	r0, [r7, #80]	@ 0x50
10042402:	6d79      	ldr	r1, [r7, #84]	@ 0x54
10042404:	0003      	movs	r3, r0
10042406:	0a9a      	lsrs	r2, r3, #10
10042408:	000b      	movs	r3, r1
1004240a:	059b      	lsls	r3, r3, #22
1004240c:	4313      	orrs	r3, r2
1004240e:	677b      	str	r3, [r7, #116]	@ 0x74
10042410:	0003      	movs	r3, r0
10042412:	059b      	lsls	r3, r3, #22
10042414:	673b      	str	r3, [r7, #112]	@ 0x70
    (*pcM) = (uint32_t)(tgt / LL_GetXTALFreq());
10042416:	f002 f853 	bl	100444c0 <LL_GetXTALFreq>
1004241a:	0003      	movs	r3, r0
1004241c:	64bb      	str	r3, [r7, #72]	@ 0x48
1004241e:	2300      	movs	r3, #0
10042420:	64fb      	str	r3, [r7, #76]	@ 0x4c
10042422:	6cba      	ldr	r2, [r7, #72]	@ 0x48
10042424:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
10042426:	6f38      	ldr	r0, [r7, #112]	@ 0x70
10042428:	6f79      	ldr	r1, [r7, #116]	@ 0x74
1004242a:	f7fd ffc9 	bl	100403c0 <__aeabi_uldivmod>
1004242e:	0002      	movs	r2, r0
10042430:	000b      	movs	r3, r1
10042432:	b2d2      	uxtb	r2, r2
10042434:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
10042436:	701a      	strb	r2, [r3, #0]
    tgt1 = (uint64_t)LL_GetXTALFreq() * (*pcM);
10042438:	f002 f842 	bl	100444c0 <LL_GetXTALFreq>
1004243c:	0003      	movs	r3, r0
1004243e:	643b      	str	r3, [r7, #64]	@ 0x40
10042440:	2300      	movs	r3, #0
10042442:	647b      	str	r3, [r7, #68]	@ 0x44
10042444:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
10042446:	781b      	ldrb	r3, [r3, #0]
10042448:	63bb      	str	r3, [r7, #56]	@ 0x38
1004244a:	2300      	movs	r3, #0
1004244c:	63fb      	str	r3, [r7, #60]	@ 0x3c
1004244e:	6bba      	ldr	r2, [r7, #56]	@ 0x38
10042450:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
10042452:	6c38      	ldr	r0, [r7, #64]	@ 0x40
10042454:	6c79      	ldr	r1, [r7, #68]	@ 0x44
10042456:	f7fd ffd3 	bl	10040400 <__aeabi_lmul>
1004245a:	0002      	movs	r2, r0
1004245c:	000b      	movs	r3, r1
1004245e:	2180      	movs	r1, #128	@ 0x80
10042460:	1879      	adds	r1, r7, r1
10042462:	600a      	str	r2, [r1, #0]
10042464:	604b      	str	r3, [r1, #4]
    tgt2 = (uint64_t)LL_GetXTALFreq() * ((*pcM) + 1);
10042466:	f002 f82b 	bl	100444c0 <LL_GetXTALFreq>
1004246a:	0003      	movs	r3, r0
1004246c:	633b      	str	r3, [r7, #48]	@ 0x30
1004246e:	2300      	movs	r3, #0
10042470:	637b      	str	r3, [r7, #52]	@ 0x34
10042472:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
10042474:	781b      	ldrb	r3, [r3, #0]
10042476:	3301      	adds	r3, #1
10042478:	62bb      	str	r3, [r7, #40]	@ 0x28
1004247a:	17db      	asrs	r3, r3, #31
1004247c:	62fb      	str	r3, [r7, #44]	@ 0x2c
1004247e:	6aba      	ldr	r2, [r7, #40]	@ 0x28
10042480:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
10042482:	6b38      	ldr	r0, [r7, #48]	@ 0x30
10042484:	6b79      	ldr	r1, [r7, #52]	@ 0x34
10042486:	f7fd ffbb 	bl	10040400 <__aeabi_lmul>
1004248a:	0002      	movs	r2, r0
1004248c:	000b      	movs	r3, r1
1004248e:	67ba      	str	r2, [r7, #120]	@ 0x78
10042490:	67fb      	str	r3, [r7, #124]	@ 0x7c
10042492:	e05f      	b.n	10042554 <MRSubG_SearchFreqDevME+0x1da>
  }
  else
  {
    tgt = ((uint64_t)lFDev) << (23 - uFDevE);
10042494:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
10042496:	001c      	movs	r4, r3
10042498:	2300      	movs	r3, #0
1004249a:	001d      	movs	r5, r3
1004249c:	2337      	movs	r3, #55	@ 0x37
1004249e:	2258      	movs	r2, #88	@ 0x58
100424a0:	189b      	adds	r3, r3, r2
100424a2:	19db      	adds	r3, r3, r7
100424a4:	781a      	ldrb	r2, [r3, #0]
100424a6:	2317      	movs	r3, #23
100424a8:	1a99      	subs	r1, r3, r2
100424aa:	000b      	movs	r3, r1
100424ac:	3b20      	subs	r3, #32
100424ae:	2b00      	cmp	r3, #0
100424b0:	db04      	blt.n	100424bc <MRSubG_SearchFreqDevME+0x142>
100424b2:	0022      	movs	r2, r4
100424b4:	409a      	lsls	r2, r3
100424b6:	0013      	movs	r3, r2
100424b8:	677b      	str	r3, [r7, #116]	@ 0x74
100424ba:	e007      	b.n	100424cc <MRSubG_SearchFreqDevME+0x152>
100424bc:	2320      	movs	r3, #32
100424be:	1a5b      	subs	r3, r3, r1
100424c0:	0022      	movs	r2, r4
100424c2:	40da      	lsrs	r2, r3
100424c4:	002b      	movs	r3, r5
100424c6:	408b      	lsls	r3, r1
100424c8:	4313      	orrs	r3, r2
100424ca:	677b      	str	r3, [r7, #116]	@ 0x74
100424cc:	0023      	movs	r3, r4
100424ce:	408b      	lsls	r3, r1
100424d0:	673b      	str	r3, [r7, #112]	@ 0x70
    (*pcM) = (uint32_t)(tgt / LL_GetXTALFreq()) - 256;
100424d2:	f001 fff5 	bl	100444c0 <LL_GetXTALFreq>
100424d6:	0003      	movs	r3, r0
100424d8:	623b      	str	r3, [r7, #32]
100424da:	2300      	movs	r3, #0
100424dc:	627b      	str	r3, [r7, #36]	@ 0x24
100424de:	6a3a      	ldr	r2, [r7, #32]
100424e0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
100424e2:	6f38      	ldr	r0, [r7, #112]	@ 0x70
100424e4:	6f79      	ldr	r1, [r7, #116]	@ 0x74
100424e6:	f7fd ff6b 	bl	100403c0 <__aeabi_uldivmod>
100424ea:	0002      	movs	r2, r0
100424ec:	000b      	movs	r3, r1
100424ee:	b2d2      	uxtb	r2, r2
100424f0:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
100424f2:	701a      	strb	r2, [r3, #0]
    tgt1 = (uint64_t)LL_GetXTALFreq() * ((*pcM) + 256);
100424f4:	f001 ffe4 	bl	100444c0 <LL_GetXTALFreq>
100424f8:	0003      	movs	r3, r0
100424fa:	61bb      	str	r3, [r7, #24]
100424fc:	2300      	movs	r3, #0
100424fe:	61fb      	str	r3, [r7, #28]
10042500:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
10042502:	781b      	ldrb	r3, [r3, #0]
10042504:	3301      	adds	r3, #1
10042506:	33ff      	adds	r3, #255	@ 0xff
10042508:	613b      	str	r3, [r7, #16]
1004250a:	17db      	asrs	r3, r3, #31
1004250c:	617b      	str	r3, [r7, #20]
1004250e:	693a      	ldr	r2, [r7, #16]
10042510:	697b      	ldr	r3, [r7, #20]
10042512:	69b8      	ldr	r0, [r7, #24]
10042514:	69f9      	ldr	r1, [r7, #28]
10042516:	f7fd ff73 	bl	10040400 <__aeabi_lmul>
1004251a:	0002      	movs	r2, r0
1004251c:	000b      	movs	r3, r1
1004251e:	2180      	movs	r1, #128	@ 0x80
10042520:	1879      	adds	r1, r7, r1
10042522:	600a      	str	r2, [r1, #0]
10042524:	604b      	str	r3, [r1, #4]
    tgt2 = (uint64_t)LL_GetXTALFreq() * ((*pcM) + 1 + 256);
10042526:	f001 ffcb 	bl	100444c0 <LL_GetXTALFreq>
1004252a:	0003      	movs	r3, r0
1004252c:	60bb      	str	r3, [r7, #8]
1004252e:	2300      	movs	r3, #0
10042530:	60fb      	str	r3, [r7, #12]
10042532:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
10042534:	781b      	ldrb	r3, [r3, #0]
10042536:	3302      	adds	r3, #2
10042538:	33ff      	adds	r3, #255	@ 0xff
1004253a:	603b      	str	r3, [r7, #0]
1004253c:	17db      	asrs	r3, r3, #31
1004253e:	607b      	str	r3, [r7, #4]
10042540:	683a      	ldr	r2, [r7, #0]
10042542:	687b      	ldr	r3, [r7, #4]
10042544:	68b8      	ldr	r0, [r7, #8]
10042546:	68f9      	ldr	r1, [r7, #12]
10042548:	f7fd ff5a 	bl	10040400 <__aeabi_lmul>
1004254c:	0002      	movs	r2, r0
1004254e:	000b      	movs	r3, r1
10042550:	67ba      	str	r2, [r7, #120]	@ 0x78
10042552:	67fb      	str	r3, [r7, #124]	@ 0x7c
  }

  (*pcM) = ((tgt2 - tgt) < (tgt - tgt1)) ? ((*pcM) + 1) : (*pcM);
10042554:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
10042556:	6ff9      	ldr	r1, [r7, #124]	@ 0x7c
10042558:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
1004255a:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
1004255c:	1a80      	subs	r0, r0, r2
1004255e:	4199      	sbcs	r1, r3
10042560:	0002      	movs	r2, r0
10042562:	000b      	movs	r3, r1
10042564:	6f3c      	ldr	r4, [r7, #112]	@ 0x70
10042566:	6f7d      	ldr	r5, [r7, #116]	@ 0x74
10042568:	2180      	movs	r1, #128	@ 0x80
1004256a:	1879      	adds	r1, r7, r1
1004256c:	6808      	ldr	r0, [r1, #0]
1004256e:	6849      	ldr	r1, [r1, #4]
10042570:	1a24      	subs	r4, r4, r0
10042572:	418d      	sbcs	r5, r1
10042574:	0020      	movs	r0, r4
10042576:	0029      	movs	r1, r5
10042578:	4299      	cmp	r1, r3
1004257a:	d802      	bhi.n	10042582 <MRSubG_SearchFreqDevME+0x208>
1004257c:	d106      	bne.n	1004258c <MRSubG_SearchFreqDevME+0x212>
1004257e:	4290      	cmp	r0, r2
10042580:	d904      	bls.n	1004258c <MRSubG_SearchFreqDevME+0x212>
10042582:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
10042584:	781b      	ldrb	r3, [r3, #0]
10042586:	3301      	adds	r3, #1
10042588:	b2db      	uxtb	r3, r3
1004258a:	e001      	b.n	10042590 <MRSubG_SearchFreqDevME+0x216>
1004258c:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
1004258e:	781b      	ldrb	r3, [r3, #0]
10042590:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
10042592:	7013      	strb	r3, [r2, #0]
}
10042594:	46c0      	nop			@ (mov r8, r8)
10042596:	46bd      	mov	sp, r7
10042598:	b025      	add	sp, #148	@ 0x94
1004259a:	bdf0      	pop	{r4, r5, r6, r7, pc}

1004259c <MRSubG_SearchChannelBwME>:
  * @param  pcM pointer to the returned mantissa value.
  * @param  pcE pointer to the returned exponent value.
  * @retval None.
  */
static void MRSubG_SearchChannelBwME(uint32_t lBandwidth, uint8_t *pcM, uint8_t *pcE)
{
1004259c:	b5f0      	push	{r4, r5, r6, r7, lr}
1004259e:	b093      	sub	sp, #76	@ 0x4c
100425a0:	af00      	add	r7, sp, #0
100425a2:	6278      	str	r0, [r7, #36]	@ 0x24
100425a4:	6239      	str	r1, [r7, #32]
100425a6:	61fa      	str	r2, [r7, #28]
  uint32_t f_dig;
  int32_t chfltCalculation[3];
  uint8_t j;
  uint32_t chfltDelta;

  f_dig = LL_GetXTALFreq() / 3;
100425a8:	f001 ff8a 	bl	100444c0 <LL_GetXTALFreq>
100425ac:	0003      	movs	r3, r0
100425ae:	2103      	movs	r1, #3
100425b0:	0018      	movs	r0, r3
100425b2:	f7fd fd8f 	bl	100400d4 <__udivsi3>
100425b6:	0003      	movs	r3, r0
100425b8:	63fb      	str	r3, [r7, #60]	@ 0x3c

  /* Search the channel filter bandwidth table index */
  for (i = 0; i < 99 &&
100425ba:	232f      	movs	r3, #47	@ 0x2f
100425bc:	2218      	movs	r2, #24
100425be:	189b      	adds	r3, r3, r2
100425c0:	19db      	adds	r3, r3, r7
100425c2:	2200      	movs	r2, #0
100425c4:	701a      	strb	r2, [r3, #0]
100425c6:	e00b      	b.n	100425e0 <MRSubG_SearchChannelBwME+0x44>
       (lBandwidth < (uint32_t)(((uint64_t)s_Channel_Filter_Bandwidth[i] * f_dig) / 16000000));
       i++)
100425c8:	212f      	movs	r1, #47	@ 0x2f
100425ca:	2018      	movs	r0, #24
100425cc:	180b      	adds	r3, r1, r0
100425ce:	19db      	adds	r3, r3, r7
100425d0:	781b      	ldrb	r3, [r3, #0]
100425d2:	b25b      	sxtb	r3, r3
100425d4:	b2db      	uxtb	r3, r3
100425d6:	3301      	adds	r3, #1
100425d8:	b2da      	uxtb	r2, r3
100425da:	180b      	adds	r3, r1, r0
100425dc:	19db      	adds	r3, r3, r7
100425de:	701a      	strb	r2, [r3, #0]
  for (i = 0; i < 99 &&
100425e0:	222f      	movs	r2, #47	@ 0x2f
100425e2:	2118      	movs	r1, #24
100425e4:	1853      	adds	r3, r2, r1
100425e6:	19db      	adds	r3, r3, r7
100425e8:	781b      	ldrb	r3, [r3, #0]
100425ea:	b25b      	sxtb	r3, r3
100425ec:	2b62      	cmp	r3, #98	@ 0x62
100425ee:	dc20      	bgt.n	10042632 <MRSubG_SearchChannelBwME+0x96>
       (lBandwidth < (uint32_t)(((uint64_t)s_Channel_Filter_Bandwidth[i] * f_dig) / 16000000));
100425f0:	1853      	adds	r3, r2, r1
100425f2:	19db      	adds	r3, r3, r7
100425f4:	2200      	movs	r2, #0
100425f6:	569a      	ldrsb	r2, [r3, r2]
100425f8:	4b7d      	ldr	r3, [pc, #500]	@ (100427f0 <MRSubG_SearchChannelBwME+0x254>)
100425fa:	0092      	lsls	r2, r2, #2
100425fc:	58d3      	ldr	r3, [r2, r3]
100425fe:	613b      	str	r3, [r7, #16]
10042600:	2300      	movs	r3, #0
10042602:	617b      	str	r3, [r7, #20]
10042604:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
10042606:	60bb      	str	r3, [r7, #8]
10042608:	2300      	movs	r3, #0
1004260a:	60fb      	str	r3, [r7, #12]
1004260c:	68ba      	ldr	r2, [r7, #8]
1004260e:	68fb      	ldr	r3, [r7, #12]
10042610:	6938      	ldr	r0, [r7, #16]
10042612:	6979      	ldr	r1, [r7, #20]
10042614:	f7fd fef4 	bl	10040400 <__aeabi_lmul>
10042618:	0002      	movs	r2, r0
1004261a:	000b      	movs	r3, r1
1004261c:	0010      	movs	r0, r2
1004261e:	0019      	movs	r1, r3
10042620:	4a74      	ldr	r2, [pc, #464]	@ (100427f4 <MRSubG_SearchChannelBwME+0x258>)
10042622:	2300      	movs	r3, #0
10042624:	f7fd fecc 	bl	100403c0 <__aeabi_uldivmod>
10042628:	0002      	movs	r2, r0
1004262a:	000b      	movs	r3, r1
  for (i = 0; i < 99 &&
1004262c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
1004262e:	4293      	cmp	r3, r2
10042630:	d3ca      	bcc.n	100425c8 <MRSubG_SearchChannelBwME+0x2c>
    ;

  if (i != 0)
10042632:	222f      	movs	r2, #47	@ 0x2f
10042634:	2118      	movs	r1, #24
10042636:	1853      	adds	r3, r2, r1
10042638:	19db      	adds	r3, r3, r7
1004263a:	781b      	ldrb	r3, [r3, #0]
1004263c:	b25b      	sxtb	r3, r3
1004263e:	2b00      	cmp	r3, #0
10042640:	d100      	bne.n	10042644 <MRSubG_SearchChannelBwME+0xa8>
10042642:	e0b5      	b.n	100427b0 <MRSubG_SearchChannelBwME+0x214>
  {
    /* Finds the index value with best approximation in i-1, i and i+1 elements */
    i_tmp = i;
10042644:	2323      	movs	r3, #35	@ 0x23
10042646:	185b      	adds	r3, r3, r1
10042648:	19db      	adds	r3, r3, r7
1004264a:	1852      	adds	r2, r2, r1
1004264c:	19d2      	adds	r2, r2, r7
1004264e:	7812      	ldrb	r2, [r2, #0]
10042650:	701a      	strb	r2, [r3, #0]

    for (j = 0; j < 3; j++)
10042652:	232e      	movs	r3, #46	@ 0x2e
10042654:	185b      	adds	r3, r3, r1
10042656:	19db      	adds	r3, r3, r7
10042658:	2200      	movs	r2, #0
1004265a:	701a      	strb	r2, [r3, #0]
1004265c:	e05d      	b.n	1004271a <MRSubG_SearchChannelBwME+0x17e>
    {
      if (((i_tmp + j - 1) >= 0) && ((i_tmp + j - 1) <= 98))
1004265e:	2023      	movs	r0, #35	@ 0x23
10042660:	2618      	movs	r6, #24
10042662:	1983      	adds	r3, r0, r6
10042664:	19db      	adds	r3, r3, r7
10042666:	2200      	movs	r2, #0
10042668:	569a      	ldrsb	r2, [r3, r2]
1004266a:	212e      	movs	r1, #46	@ 0x2e
1004266c:	198b      	adds	r3, r1, r6
1004266e:	19db      	adds	r3, r3, r7
10042670:	781b      	ldrb	r3, [r3, #0]
10042672:	18d3      	adds	r3, r2, r3
10042674:	2b00      	cmp	r3, #0
10042676:	dd3c      	ble.n	100426f2 <MRSubG_SearchChannelBwME+0x156>
10042678:	1983      	adds	r3, r0, r6
1004267a:	19db      	adds	r3, r3, r7
1004267c:	2200      	movs	r2, #0
1004267e:	569a      	ldrsb	r2, [r3, r2]
10042680:	198b      	adds	r3, r1, r6
10042682:	19db      	adds	r3, r3, r7
10042684:	781b      	ldrb	r3, [r3, #0]
10042686:	18d3      	adds	r3, r2, r3
10042688:	2b63      	cmp	r3, #99	@ 0x63
1004268a:	dc32      	bgt.n	100426f2 <MRSubG_SearchChannelBwME+0x156>
      {
        chfltCalculation[j] = (int32_t)lBandwidth -
1004268c:	6a7e      	ldr	r6, [r7, #36]	@ 0x24
                              (int32_t)(((uint64_t)s_Channel_Filter_Bandwidth[i_tmp + j - 1] * f_dig) / 16000000);
1004268e:	2318      	movs	r3, #24
10042690:	18c2      	adds	r2, r0, r3
10042692:	19d3      	adds	r3, r2, r7
10042694:	2200      	movs	r2, #0
10042696:	569a      	ldrsb	r2, [r3, r2]
10042698:	2018      	movs	r0, #24
1004269a:	180b      	adds	r3, r1, r0
1004269c:	19db      	adds	r3, r3, r7
1004269e:	781b      	ldrb	r3, [r3, #0]
100426a0:	18d3      	adds	r3, r2, r3
100426a2:	1e5a      	subs	r2, r3, #1
100426a4:	4b52      	ldr	r3, [pc, #328]	@ (100427f0 <MRSubG_SearchChannelBwME+0x254>)
100426a6:	0092      	lsls	r2, r2, #2
100426a8:	58d3      	ldr	r3, [r2, r3]
100426aa:	001c      	movs	r4, r3
100426ac:	2300      	movs	r3, #0
100426ae:	001d      	movs	r5, r3
100426b0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
100426b2:	603b      	str	r3, [r7, #0]
100426b4:	2300      	movs	r3, #0
100426b6:	607b      	str	r3, [r7, #4]
100426b8:	683a      	ldr	r2, [r7, #0]
100426ba:	687b      	ldr	r3, [r7, #4]
100426bc:	0020      	movs	r0, r4
100426be:	0029      	movs	r1, r5
100426c0:	f7fd fe9e 	bl	10040400 <__aeabi_lmul>
100426c4:	0002      	movs	r2, r0
100426c6:	000b      	movs	r3, r1
100426c8:	0010      	movs	r0, r2
100426ca:	0019      	movs	r1, r3
100426cc:	4a49      	ldr	r2, [pc, #292]	@ (100427f4 <MRSubG_SearchChannelBwME+0x258>)
100426ce:	2300      	movs	r3, #0
100426d0:	f7fd fe76 	bl	100403c0 <__aeabi_uldivmod>
100426d4:	0002      	movs	r2, r0
100426d6:	000b      	movs	r3, r1
100426d8:	0011      	movs	r1, r2
        chfltCalculation[j] = (int32_t)lBandwidth -
100426da:	232e      	movs	r3, #46	@ 0x2e
100426dc:	2018      	movs	r0, #24
100426de:	181b      	adds	r3, r3, r0
100426e0:	19db      	adds	r3, r3, r7
100426e2:	781a      	ldrb	r2, [r3, #0]
100426e4:	1a71      	subs	r1, r6, r1
100426e6:	2314      	movs	r3, #20
100426e8:	181b      	adds	r3, r3, r0
100426ea:	19db      	adds	r3, r3, r7
100426ec:	0092      	lsls	r2, r2, #2
100426ee:	50d1      	str	r1, [r2, r3]
100426f0:	e00a      	b.n	10042708 <MRSubG_SearchChannelBwME+0x16c>
      }
      else
      {
        chfltCalculation[j] = 0x7FFFFFFF;
100426f2:	232e      	movs	r3, #46	@ 0x2e
100426f4:	2118      	movs	r1, #24
100426f6:	185b      	adds	r3, r3, r1
100426f8:	19db      	adds	r3, r3, r7
100426fa:	781a      	ldrb	r2, [r3, #0]
100426fc:	2314      	movs	r3, #20
100426fe:	185b      	adds	r3, r3, r1
10042700:	19db      	adds	r3, r3, r7
10042702:	0092      	lsls	r2, r2, #2
10042704:	493c      	ldr	r1, [pc, #240]	@ (100427f8 <MRSubG_SearchChannelBwME+0x25c>)
10042706:	50d1      	str	r1, [r2, r3]
    for (j = 0; j < 3; j++)
10042708:	212e      	movs	r1, #46	@ 0x2e
1004270a:	2018      	movs	r0, #24
1004270c:	180b      	adds	r3, r1, r0
1004270e:	19db      	adds	r3, r3, r7
10042710:	781a      	ldrb	r2, [r3, #0]
10042712:	180b      	adds	r3, r1, r0
10042714:	19db      	adds	r3, r3, r7
10042716:	3201      	adds	r2, #1
10042718:	701a      	strb	r2, [r3, #0]
1004271a:	222e      	movs	r2, #46	@ 0x2e
1004271c:	2118      	movs	r1, #24
1004271e:	1853      	adds	r3, r2, r1
10042720:	19db      	adds	r3, r3, r7
10042722:	781b      	ldrb	r3, [r3, #0]
10042724:	2b02      	cmp	r3, #2
10042726:	d99a      	bls.n	1004265e <MRSubG_SearchChannelBwME+0xc2>
      }
    }

    chfltDelta = 0xFFFFFFFF;
10042728:	2301      	movs	r3, #1
1004272a:	425b      	negs	r3, r3
1004272c:	643b      	str	r3, [r7, #64]	@ 0x40

    for (j = 0; j < 3; j++)
1004272e:	1853      	adds	r3, r2, r1
10042730:	19db      	adds	r3, r3, r7
10042732:	2200      	movs	r2, #0
10042734:	701a      	strb	r2, [r3, #0]
10042736:	e034      	b.n	100427a2 <MRSubG_SearchChannelBwME+0x206>
    {
      if (S_ABS(chfltCalculation[j]) < chfltDelta)
10042738:	212e      	movs	r1, #46	@ 0x2e
1004273a:	2418      	movs	r4, #24
1004273c:	190b      	adds	r3, r1, r4
1004273e:	19db      	adds	r3, r3, r7
10042740:	781a      	ldrb	r2, [r3, #0]
10042742:	2014      	movs	r0, #20
10042744:	1903      	adds	r3, r0, r4
10042746:	19db      	adds	r3, r3, r7
10042748:	0092      	lsls	r2, r2, #2
1004274a:	58d3      	ldr	r3, [r2, r3]
1004274c:	17da      	asrs	r2, r3, #31
1004274e:	189b      	adds	r3, r3, r2
10042750:	4053      	eors	r3, r2
10042752:	001a      	movs	r2, r3
10042754:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
10042756:	4293      	cmp	r3, r2
10042758:	d91a      	bls.n	10042790 <MRSubG_SearchChannelBwME+0x1f4>
      {
        chfltDelta = S_ABS(chfltCalculation[j]);
1004275a:	190b      	adds	r3, r1, r4
1004275c:	19db      	adds	r3, r3, r7
1004275e:	781a      	ldrb	r2, [r3, #0]
10042760:	1903      	adds	r3, r0, r4
10042762:	19db      	adds	r3, r3, r7
10042764:	0092      	lsls	r2, r2, #2
10042766:	58d3      	ldr	r3, [r2, r3]
10042768:	17da      	asrs	r2, r3, #31
1004276a:	189b      	adds	r3, r3, r2
1004276c:	4053      	eors	r3, r2
1004276e:	643b      	str	r3, [r7, #64]	@ 0x40
        i = i_tmp + j - 1;
10042770:	2323      	movs	r3, #35	@ 0x23
10042772:	191b      	adds	r3, r3, r4
10042774:	19db      	adds	r3, r3, r7
10042776:	781a      	ldrb	r2, [r3, #0]
10042778:	0020      	movs	r0, r4
1004277a:	190b      	adds	r3, r1, r4
1004277c:	19db      	adds	r3, r3, r7
1004277e:	781b      	ldrb	r3, [r3, #0]
10042780:	18d3      	adds	r3, r2, r3
10042782:	b2db      	uxtb	r3, r3
10042784:	3b01      	subs	r3, #1
10042786:	b2da      	uxtb	r2, r3
10042788:	232f      	movs	r3, #47	@ 0x2f
1004278a:	181b      	adds	r3, r3, r0
1004278c:	19db      	adds	r3, r3, r7
1004278e:	701a      	strb	r2, [r3, #0]
    for (j = 0; j < 3; j++)
10042790:	212e      	movs	r1, #46	@ 0x2e
10042792:	2018      	movs	r0, #24
10042794:	180b      	adds	r3, r1, r0
10042796:	19db      	adds	r3, r3, r7
10042798:	781a      	ldrb	r2, [r3, #0]
1004279a:	180b      	adds	r3, r1, r0
1004279c:	19db      	adds	r3, r3, r7
1004279e:	3201      	adds	r2, #1
100427a0:	701a      	strb	r2, [r3, #0]
100427a2:	232e      	movs	r3, #46	@ 0x2e
100427a4:	2218      	movs	r2, #24
100427a6:	189b      	adds	r3, r3, r2
100427a8:	19db      	adds	r3, r3, r7
100427aa:	781b      	ldrb	r3, [r3, #0]
100427ac:	2b02      	cmp	r3, #2
100427ae:	d9c3      	bls.n	10042738 <MRSubG_SearchChannelBwME+0x19c>
      }
    }
  }

  (*pcE) = (uint8_t)(i / 9);
100427b0:	242f      	movs	r4, #47	@ 0x2f
100427b2:	2518      	movs	r5, #24
100427b4:	1963      	adds	r3, r4, r5
100427b6:	19db      	adds	r3, r3, r7
100427b8:	781b      	ldrb	r3, [r3, #0]
100427ba:	b25b      	sxtb	r3, r3
100427bc:	2109      	movs	r1, #9
100427be:	0018      	movs	r0, r3
100427c0:	f7fd fd12 	bl	100401e8 <__divsi3>
100427c4:	0003      	movs	r3, r0
100427c6:	b25b      	sxtb	r3, r3
100427c8:	b2da      	uxtb	r2, r3
100427ca:	69fb      	ldr	r3, [r7, #28]
100427cc:	701a      	strb	r2, [r3, #0]
  (*pcM) = (uint8_t)(i % 9);
100427ce:	1963      	adds	r3, r4, r5
100427d0:	19db      	adds	r3, r3, r7
100427d2:	781b      	ldrb	r3, [r3, #0]
100427d4:	b25b      	sxtb	r3, r3
100427d6:	2109      	movs	r1, #9
100427d8:	0018      	movs	r0, r3
100427da:	f7fd fdeb 	bl	100403b4 <__aeabi_idivmod>
100427de:	000b      	movs	r3, r1
100427e0:	b25b      	sxtb	r3, r3
100427e2:	b2da      	uxtb	r2, r3
100427e4:	6a3b      	ldr	r3, [r7, #32]
100427e6:	701a      	strb	r2, [r3, #0]
}
100427e8:	46c0      	nop			@ (mov r8, r8)
100427ea:	46bd      	mov	sp, r7
100427ec:	b013      	add	sp, #76	@ 0x4c
100427ee:	bdf0      	pop	{r4, r5, r6, r7, pc}
100427f0:	10045580 	.word	0x10045580
100427f4:	00f42400 	.word	0x00f42400
100427f8:	7fffffff 	.word	0x7fffffff

100427fc <MRSubG_GetAllowedMaxOutputPower>:
  * @brief  Returns the maximum allowed output power supported by the specific configuration
  * @param  paDrvMode the configuration type.
  * @retval The maximum output power.
  */
static uint8_t MRSubG_GetAllowedMaxOutputPower(MRSubG_PA_DRVMode paDrvMode)
{
100427fc:	b580      	push	{r7, lr}
100427fe:	b084      	sub	sp, #16
10042800:	af00      	add	r7, sp, #0
10042802:	0002      	movs	r2, r0
10042804:	1dfb      	adds	r3, r7, #7
10042806:	701a      	strb	r2, [r3, #0]
  uint8_t retPwr = 20;
10042808:	230f      	movs	r3, #15
1004280a:	18fb      	adds	r3, r7, r3
1004280c:	2214      	movs	r2, #20
1004280e:	701a      	strb	r2, [r3, #0]

  switch (paDrvMode)
10042810:	1dfb      	adds	r3, r7, #7
10042812:	781b      	ldrb	r3, [r3, #0]
10042814:	2b03      	cmp	r3, #3
10042816:	d00f      	beq.n	10042838 <MRSubG_GetAllowedMaxOutputPower+0x3c>
10042818:	dc13      	bgt.n	10042842 <MRSubG_GetAllowedMaxOutputPower+0x46>
1004281a:	2b01      	cmp	r3, #1
1004281c:	d002      	beq.n	10042824 <MRSubG_GetAllowedMaxOutputPower+0x28>
1004281e:	2b02      	cmp	r3, #2
10042820:	d005      	beq.n	1004282e <MRSubG_GetAllowedMaxOutputPower+0x32>
10042822:	e00e      	b.n	10042842 <MRSubG_GetAllowedMaxOutputPower+0x46>
  {
    case PA_DRV_TX:
      retPwr = 10;
10042824:	230f      	movs	r3, #15
10042826:	18fb      	adds	r3, r7, r3
10042828:	220a      	movs	r2, #10
1004282a:	701a      	strb	r2, [r3, #0]
      break;
1004282c:	e009      	b.n	10042842 <MRSubG_GetAllowedMaxOutputPower+0x46>
    case PA_DRV_TX_HP:
      retPwr = 16;
1004282e:	230f      	movs	r3, #15
10042830:	18fb      	adds	r3, r7, r3
10042832:	2210      	movs	r2, #16
10042834:	701a      	strb	r2, [r3, #0]
      break;
10042836:	e004      	b.n	10042842 <MRSubG_GetAllowedMaxOutputPower+0x46>
    case PA_DRV_TX_TX_HP:
      retPwr = 18; /* Max allowed power without PA_DEGEN_ON */
10042838:	230f      	movs	r3, #15
1004283a:	18fb      	adds	r3, r7, r3
1004283c:	2212      	movs	r2, #18
1004283e:	701a      	strb	r2, [r3, #0]
      break;
10042840:	46c0      	nop			@ (mov r8, r8)
  }

  return retPwr;
10042842:	230f      	movs	r3, #15
10042844:	18fb      	adds	r3, r7, r3
10042846:	781b      	ldrb	r3, [r3, #0]
}
10042848:	0018      	movs	r0, r3
1004284a:	46bd      	mov	sp, r7
1004284c:	b004      	add	sp, #16
1004284e:	bd80      	pop	{r7, pc}

10042850 <MRSUBG_EvaluateDSSS>:
  * @param  xModulation the modulation type.
  * @param  dsssExponent the DSSS exponent.
  * @retval None.
  */
static void MRSUBG_EvaluateDSSS(MRSubGModSelect xModulation, uint8_t dsssExponent)
{
10042850:	b580      	push	{r7, lr}
10042852:	b084      	sub	sp, #16
10042854:	af00      	add	r7, sp, #0
10042856:	0002      	movs	r2, r0
10042858:	1dfb      	adds	r3, r7, #7
1004285a:	701a      	strb	r2, [r3, #0]
1004285c:	1dbb      	adds	r3, r7, #6
1004285e:	1c0a      	adds	r2, r1, #0
10042860:	701a      	strb	r2, [r3, #0]
  /* Disable DSSS for modulations different from 2(G)FSK */
  if (xModulation != MOD_2GFSK05 && xModulation != MOD_2GFSK1)
10042862:	1dfb      	adds	r3, r7, #7
10042864:	781b      	ldrb	r3, [r3, #0]
10042866:	2b12      	cmp	r3, #18
10042868:	d006      	beq.n	10042878 <MRSUBG_EvaluateDSSS+0x28>
1004286a:	1dfb      	adds	r3, r7, #7
1004286c:	781b      	ldrb	r3, [r3, #0]
1004286e:	2b02      	cmp	r3, #2
10042870:	d002      	beq.n	10042878 <MRSUBG_EvaluateDSSS+0x28>
  {
    dsssExponent = 0;
10042872:	1dbb      	adds	r3, r7, #6
10042874:	2200      	movs	r2, #0
10042876:	701a      	strb	r2, [r3, #0]
  }

  uint8_t dsss_en = (dsssExponent > 0);
10042878:	1dbb      	adds	r3, r7, #6
1004287a:	781b      	ldrb	r3, [r3, #0]
1004287c:	1e5a      	subs	r2, r3, #1
1004287e:	4193      	sbcs	r3, r2
10042880:	b2da      	uxtb	r2, r3
10042882:	230e      	movs	r3, #14
10042884:	18fb      	adds	r3, r7, r3
10042886:	701a      	strb	r2, [r3, #0]
  uint8_t dsss_sf = (1 << dsssExponent); /* Spread Factor = 2^dssExponent */
10042888:	1dbb      	adds	r3, r7, #6
1004288a:	781b      	ldrb	r3, [r3, #0]
1004288c:	2201      	movs	r2, #1
1004288e:	409a      	lsls	r2, r3
10042890:	210d      	movs	r1, #13
10042892:	187b      	adds	r3, r7, r1
10042894:	701a      	strb	r2, [r3, #0]
  uint8_t dsss_acq_thr = (dsss_sf - 1);
10042896:	200f      	movs	r0, #15
10042898:	183b      	adds	r3, r7, r0
1004289a:	187a      	adds	r2, r7, r1
1004289c:	7812      	ldrb	r2, [r2, #0]
1004289e:	3a01      	subs	r2, #1
100428a0:	701a      	strb	r2, [r3, #0]

  if (dsssExponent > 3)
100428a2:	1dbb      	adds	r3, r7, #6
100428a4:	781b      	ldrb	r3, [r3, #0]
100428a6:	2b03      	cmp	r3, #3
100428a8:	d904      	bls.n	100428b4 <MRSUBG_EvaluateDSSS+0x64>
  {
    dsss_acq_thr = dsss_sf / 2;
100428aa:	183b      	adds	r3, r7, r0
100428ac:	187a      	adds	r2, r7, r1
100428ae:	7812      	ldrb	r2, [r2, #0]
100428b0:	0852      	lsrs	r2, r2, #1
100428b2:	701a      	strb	r2, [r3, #0]
  }

  MODIFY_REG_FIELD(MR_SUBG_GLOB_STATIC->DSSS_CTRL,  MR_SUBG_GLOB_STATIC_DSSS_CTRL_DSSS_EN, dsss_en);
100428b4:	4b16      	ldr	r3, [pc, #88]	@ (10042910 <MRSUBG_EvaluateDSSS+0xc0>)
100428b6:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
100428b8:	2280      	movs	r2, #128	@ 0x80
100428ba:	4393      	bics	r3, r2
100428bc:	0019      	movs	r1, r3
100428be:	230e      	movs	r3, #14
100428c0:	18fb      	adds	r3, r7, r3
100428c2:	781b      	ldrb	r3, [r3, #0]
100428c4:	01db      	lsls	r3, r3, #7
100428c6:	22ff      	movs	r2, #255	@ 0xff
100428c8:	401a      	ands	r2, r3
100428ca:	4b11      	ldr	r3, [pc, #68]	@ (10042910 <MRSUBG_EvaluateDSSS+0xc0>)
100428cc:	430a      	orrs	r2, r1
100428ce:	639a      	str	r2, [r3, #56]	@ 0x38
  MODIFY_REG_FIELD(MR_SUBG_GLOB_STATIC->DSSS_CTRL,  MR_SUBG_GLOB_STATIC_DSSS_CTRL_SPREADING_EXP, dsssExponent);
100428d0:	4b0f      	ldr	r3, [pc, #60]	@ (10042910 <MRSUBG_EvaluateDSSS+0xc0>)
100428d2:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
100428d4:	2270      	movs	r2, #112	@ 0x70
100428d6:	4393      	bics	r3, r2
100428d8:	0019      	movs	r1, r3
100428da:	1dbb      	adds	r3, r7, #6
100428dc:	781b      	ldrb	r3, [r3, #0]
100428de:	011b      	lsls	r3, r3, #4
100428e0:	2270      	movs	r2, #112	@ 0x70
100428e2:	401a      	ands	r2, r3
100428e4:	4b0a      	ldr	r3, [pc, #40]	@ (10042910 <MRSUBG_EvaluateDSSS+0xc0>)
100428e6:	430a      	orrs	r2, r1
100428e8:	639a      	str	r2, [r3, #56]	@ 0x38
  MODIFY_REG_FIELD(MR_SUBG_GLOB_STATIC->DSSS_CTRL,  MR_SUBG_GLOB_STATIC_DSSS_CTRL_ACQ_THR, dsss_acq_thr);
100428ea:	4b09      	ldr	r3, [pc, #36]	@ (10042910 <MRSUBG_EvaluateDSSS+0xc0>)
100428ec:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
100428ee:	4a09      	ldr	r2, [pc, #36]	@ (10042914 <MRSUBG_EvaluateDSSS+0xc4>)
100428f0:	4013      	ands	r3, r2
100428f2:	0019      	movs	r1, r3
100428f4:	230f      	movs	r3, #15
100428f6:	18fb      	adds	r3, r7, r3
100428f8:	781b      	ldrb	r3, [r3, #0]
100428fa:	029b      	lsls	r3, r3, #10
100428fc:	041b      	lsls	r3, r3, #16
100428fe:	0c1a      	lsrs	r2, r3, #16
10042900:	4b03      	ldr	r3, [pc, #12]	@ (10042910 <MRSUBG_EvaluateDSSS+0xc0>)
10042902:	430a      	orrs	r2, r1
10042904:	639a      	str	r2, [r3, #56]	@ 0x38
}
10042906:	46c0      	nop			@ (mov r8, r8)
10042908:	46bd      	mov	sp, r7
1004290a:	b004      	add	sp, #16
1004290c:	bd80      	pop	{r7, pc}
1004290e:	46c0      	nop			@ (mov r8, r8)
10042910:	49000400 	.word	0x49000400
10042914:	ffff03ff 	.word	0xffff03ff

10042918 <HAL_MRSubG_Init>:
  * @param  pxSRadioInitStruct pointer to a SMRSubGConfig_t structure that
  *         contains the configuration information for the MR_SUBG radio part of STM32WL3x.
  * @retval Error code: 0=no error, 1=error during calibration of VCO.
  */
uint8_t HAL_MRSubG_Init(SMRSubGConfig_t *pxSRadioInitStruct)
{
10042918:	b580      	push	{r7, lr}
1004291a:	b082      	sub	sp, #8
1004291c:	af00      	add	r7, sp, #0
1004291e:	6078      	str	r0, [r7, #4]

  assert_param(IS_FREQUENCY_BAND(pxSRadioInitStruct->lFrequencyBase));
  assert_param(IS_MODULATION(pxSRadioInitStruct->xModulationSelect));
  assert_param(IS_DATARATE(pxSRadioInitStruct->lDatarate));

  HAL_MRSubG_MspInit();
10042920:	f7fe f9da 	bl	10040cd8 <HAL_MRSubG_MspInit>

  /* Setup design values for default registers */
  MODIFY_REG_FIELD(MR_SUBG_RADIO->AFC1_CONFIG, MR_SUBG_RADIO_AFC1_CONFIG_AFC_FAST_PERIOD, 0x00);
10042924:	2392      	movs	r3, #146	@ 0x92
10042926:	05db      	lsls	r3, r3, #23
10042928:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
1004292a:	2392      	movs	r3, #146	@ 0x92
1004292c:	05db      	lsls	r3, r3, #23
1004292e:	21ff      	movs	r1, #255	@ 0xff
10042930:	438a      	bics	r2, r1
10042932:	625a      	str	r2, [r3, #36]	@ 0x24

  MODIFY_REG_FIELD(MR_SUBG_RADIO->CLKREC_CTRL0, MR_SUBG_RADIO_CLKREC_CTRL0_PSTFLT_LEN, 0x01);
10042934:	2392      	movs	r3, #146	@ 0x92
10042936:	05db      	lsls	r3, r3, #23
10042938:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
1004293a:	2392      	movs	r3, #146	@ 0x92
1004293c:	05db      	lsls	r3, r3, #23
1004293e:	2180      	movs	r1, #128	@ 0x80
10042940:	430a      	orrs	r2, r1
10042942:	631a      	str	r2, [r3, #48]	@ 0x30
  MODIFY_REG_FIELD(MR_SUBG_RADIO->CLKREC_CTRL0, MR_SUBG_RADIO_CLKREC_CTRL0_CLKREC_P_GAIN_FAST, 0x03);
10042944:	2392      	movs	r3, #146	@ 0x92
10042946:	05db      	lsls	r3, r3, #23
10042948:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
1004294a:	2270      	movs	r2, #112	@ 0x70
1004294c:	4393      	bics	r3, r2
1004294e:	001a      	movs	r2, r3
10042950:	2392      	movs	r3, #146	@ 0x92
10042952:	05db      	lsls	r3, r3, #23
10042954:	2130      	movs	r1, #48	@ 0x30
10042956:	430a      	orrs	r2, r1
10042958:	631a      	str	r2, [r3, #48]	@ 0x30
  MODIFY_REG_FIELD(MR_SUBG_RADIO->CLKREC_CTRL0, MR_SUBG_RADIO_CLKREC_CTRL0_CLKREC_I_GAIN_FAST, 0x08);
1004295a:	2392      	movs	r3, #146	@ 0x92
1004295c:	05db      	lsls	r3, r3, #23
1004295e:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
10042960:	220f      	movs	r2, #15
10042962:	4393      	bics	r3, r2
10042964:	001a      	movs	r2, r3
10042966:	2392      	movs	r3, #146	@ 0x92
10042968:	05db      	lsls	r3, r3, #23
1004296a:	2108      	movs	r1, #8
1004296c:	430a      	orrs	r2, r1
1004296e:	631a      	str	r2, [r3, #48]	@ 0x30

  MODIFY_REG_FIELD(MR_SUBG_RADIO->CLKREC_CTRL1, MR_SUBG_RADIO_CLKREC_CTRL1_CLKREC_ALGO_SEL, 0x00);
10042970:	2392      	movs	r3, #146	@ 0x92
10042972:	05db      	lsls	r3, r3, #23
10042974:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
10042976:	2392      	movs	r3, #146	@ 0x92
10042978:	05db      	lsls	r3, r3, #23
1004297a:	2180      	movs	r1, #128	@ 0x80
1004297c:	438a      	bics	r2, r1
1004297e:	635a      	str	r2, [r3, #52]	@ 0x34
  MODIFY_REG_FIELD(MR_SUBG_RADIO->CLKREC_CTRL1, MR_SUBG_RADIO_CLKREC_CTRL1_CLKREC_P_GAIN_SLOW, 0x05);
10042980:	2392      	movs	r3, #146	@ 0x92
10042982:	05db      	lsls	r3, r3, #23
10042984:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
10042986:	2270      	movs	r2, #112	@ 0x70
10042988:	4393      	bics	r3, r2
1004298a:	001a      	movs	r2, r3
1004298c:	2392      	movs	r3, #146	@ 0x92
1004298e:	05db      	lsls	r3, r3, #23
10042990:	2150      	movs	r1, #80	@ 0x50
10042992:	430a      	orrs	r2, r1
10042994:	635a      	str	r2, [r3, #52]	@ 0x34
  MODIFY_REG_FIELD(MR_SUBG_RADIO->CLKREC_CTRL1, MR_SUBG_RADIO_CLKREC_CTRL1_CLKREC_I_GAIN_SLOW, 0x0C);
10042996:	2392      	movs	r3, #146	@ 0x92
10042998:	05db      	lsls	r3, r3, #23
1004299a:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
1004299c:	220f      	movs	r2, #15
1004299e:	4393      	bics	r3, r2
100429a0:	001a      	movs	r2, r3
100429a2:	2392      	movs	r3, #146	@ 0x92
100429a4:	05db      	lsls	r3, r3, #23
100429a6:	210c      	movs	r1, #12
100429a8:	430a      	orrs	r2, r1
100429aa:	635a      	str	r2, [r3, #52]	@ 0x34

  MODIFY_REG_FIELD(MR_SUBG_GLOB_STATIC->DSSS_CTRL, MR_SUBG_GLOB_STATIC_DSSS_CTRL_ACQ_HITS, 0x03);
100429ac:	4b22      	ldr	r3, [pc, #136]	@ (10042a38 <HAL_MRSubG_Init+0x120>)
100429ae:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
100429b0:	4b21      	ldr	r3, [pc, #132]	@ (10042a38 <HAL_MRSubG_Init+0x120>)
100429b2:	21c0      	movs	r1, #192	@ 0xc0
100429b4:	0089      	lsls	r1, r1, #2
100429b6:	430a      	orrs	r2, r1
100429b8:	639a      	str	r2, [r3, #56]	@ 0x38
  MODIFY_REG_FIELD(MR_SUBG_GLOB_STATIC->DSSS_CTRL, MR_SUBG_GLOB_STATIC_DSSS_CTRL_ACQ_WINDOW, 0x04);
100429ba:	4b1f      	ldr	r3, [pc, #124]	@ (10042a38 <HAL_MRSubG_Init+0x120>)
100429bc:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
100429be:	220f      	movs	r2, #15
100429c0:	4393      	bics	r3, r2
100429c2:	001a      	movs	r2, r3
100429c4:	4b1c      	ldr	r3, [pc, #112]	@ (10042a38 <HAL_MRSubG_Init+0x120>)
100429c6:	2104      	movs	r1, #4
100429c8:	430a      	orrs	r2, r1
100429ca:	639a      	str	r2, [r3, #56]	@ 0x38

  /* Enable calibration */
  SET_BIT(MR_SUBG_GLOB_DYNAMIC->VCO_CAL_CONFIG, MR_SUBG_GLOB_DYNAMIC_VCO_CAL_CONFIG_VCO_CALIB_REQ);
100429cc:	4b1b      	ldr	r3, [pc, #108]	@ (10042a3c <HAL_MRSubG_Init+0x124>)
100429ce:	691a      	ldr	r2, [r3, #16]
100429d0:	4b1a      	ldr	r3, [pc, #104]	@ (10042a3c <HAL_MRSubG_Init+0x124>)
100429d2:	2180      	movs	r1, #128	@ 0x80
100429d4:	0609      	lsls	r1, r1, #24
100429d6:	430a      	orrs	r2, r1
100429d8:	611a      	str	r2, [r3, #16]

  /* Avoid AGC glitches */
  WRITE_REG(MR_SUBG_RADIO->RF_FSM7_TIMEOUT, 0x0F);
100429da:	2392      	movs	r3, #146	@ 0x92
100429dc:	05db      	lsls	r3, r3, #23
100429de:	220f      	movs	r2, #15
100429e0:	61da      	str	r2, [r3, #28]

  /* Set synth registers */
  HAL_MRSubG_SetFrequencyBase(pxSRadioInitStruct->lFrequencyBase);
100429e2:	687b      	ldr	r3, [r7, #4]
100429e4:	681b      	ldr	r3, [r3, #0]
100429e6:	0018      	movs	r0, r3
100429e8:	f000 f82a 	bl	10042a40 <HAL_MRSubG_SetFrequencyBase>

  /* Configure modulation */
  HAL_MRSubG_SetModulation(pxSRadioInitStruct->xModulationSelect, pxSRadioInitStruct->dsssExp);
100429ec:	687b      	ldr	r3, [r7, #4]
100429ee:	791a      	ldrb	r2, [r3, #4]
100429f0:	687b      	ldr	r3, [r7, #4]
100429f2:	7d1b      	ldrb	r3, [r3, #20]
100429f4:	0019      	movs	r1, r3
100429f6:	0010      	movs	r0, r2
100429f8:	f000 f960 	bl	10042cbc <HAL_MRSubG_SetModulation>

  /* Configure datarate */
  HAL_MRSubG_SetDatarate(pxSRadioInitStruct->lDatarate);
100429fc:	687b      	ldr	r3, [r7, #4]
100429fe:	689b      	ldr	r3, [r3, #8]
10042a00:	0018      	movs	r0, r3
10042a02:	f000 f865 	bl	10042ad0 <HAL_MRSubG_SetDatarate>

  /* Configure frequency deviation */
  HAL_MRSubG_SetFrequencyDev(pxSRadioInitStruct->lFreqDev);
10042a06:	687b      	ldr	r3, [r7, #4]
10042a08:	68db      	ldr	r3, [r3, #12]
10042a0a:	0018      	movs	r0, r3
10042a0c:	f000 f88c 	bl	10042b28 <HAL_MRSubG_SetFrequencyDev>

  /* Configure RX channel bandwidth */
  HAL_MRSubG_SetChannelBW(pxSRadioInitStruct->lBandwidth);
10042a10:	687b      	ldr	r3, [r7, #4]
10042a12:	691b      	ldr	r3, [r3, #16]
10042a14:	0018      	movs	r0, r3
10042a16:	f000 f8c1 	bl	10042b9c <HAL_MRSubG_SetChannelBW>

  /* Configure Output Power */
  HAL_MRSubG_SetPALeveldBm(7, pxSRadioInitStruct->outputPower, pxSRadioInitStruct->PADrvMode);
10042a1a:	687b      	ldr	r3, [r7, #4]
10042a1c:	2115      	movs	r1, #21
10042a1e:	5659      	ldrsb	r1, [r3, r1]
10042a20:	687b      	ldr	r3, [r7, #4]
10042a22:	7d9b      	ldrb	r3, [r3, #22]
10042a24:	001a      	movs	r2, r3
10042a26:	2007      	movs	r0, #7
10042a28:	f000 f9ce 	bl	10042dc8 <HAL_MRSubG_SetPALeveldBm>

  return 0;
10042a2c:	2300      	movs	r3, #0
}
10042a2e:	0018      	movs	r0, r3
10042a30:	46bd      	mov	sp, r7
10042a32:	b002      	add	sp, #8
10042a34:	bd80      	pop	{r7, pc}
10042a36:	46c0      	nop			@ (mov r8, r8)
10042a38:	49000400 	.word	0x49000400
10042a3c:	49000500 	.word	0x49000500

10042a40 <HAL_MRSubG_SetFrequencyBase>:
  * @brief  Set the Synth word and the Band Select register according to desired base carrier frequency.
  * @param  lFBase the base carrier frequency expressed in Hz as unsigned word.
  * @retval None.
  */
void HAL_MRSubG_SetFrequencyBase(uint32_t lFBase)
{
10042a40:	b5b0      	push	{r4, r5, r7, lr}
10042a42:	b086      	sub	sp, #24
10042a44:	af00      	add	r7, sp, #0
10042a46:	6078      	str	r0, [r7, #4]
  uint32_t synth_frac;
  uint32_t b_factor;

  assert_param(IS_FREQUENCY_BAND(lFBase));

  MRSubG_ComputeSynthWord(lFBase, &synth_int, &synth_frac, &band);
10042a48:	2413      	movs	r4, #19
10042a4a:	193b      	adds	r3, r7, r4
10042a4c:	220c      	movs	r2, #12
10042a4e:	18ba      	adds	r2, r7, r2
10042a50:	2512      	movs	r5, #18
10042a52:	1979      	adds	r1, r7, r5
10042a54:	6878      	ldr	r0, [r7, #4]
10042a56:	f7ff fa37 	bl	10041ec8 <MRSubG_ComputeSynthWord>

  MODIFY_REG_FIELD(MR_SUBG_GLOB_DYNAMIC->SYNTH_FREQ, MR_SUBG_GLOB_DYNAMIC_SYNTH_FREQ_SYNTH_INT, synth_int);
10042a5a:	4b1a      	ldr	r3, [pc, #104]	@ (10042ac4 <HAL_MRSubG_SetFrequencyBase+0x84>)
10042a5c:	68db      	ldr	r3, [r3, #12]
10042a5e:	4a1a      	ldr	r2, [pc, #104]	@ (10042ac8 <HAL_MRSubG_SetFrequencyBase+0x88>)
10042a60:	4013      	ands	r3, r2
10042a62:	0019      	movs	r1, r3
10042a64:	197b      	adds	r3, r7, r5
10042a66:	781b      	ldrb	r3, [r3, #0]
10042a68:	051a      	lsls	r2, r3, #20
10042a6a:	23ff      	movs	r3, #255	@ 0xff
10042a6c:	051b      	lsls	r3, r3, #20
10042a6e:	401a      	ands	r2, r3
10042a70:	4b14      	ldr	r3, [pc, #80]	@ (10042ac4 <HAL_MRSubG_SetFrequencyBase+0x84>)
10042a72:	430a      	orrs	r2, r1
10042a74:	60da      	str	r2, [r3, #12]
  MODIFY_REG_FIELD(MR_SUBG_GLOB_DYNAMIC->SYNTH_FREQ, MR_SUBG_GLOB_DYNAMIC_SYNTH_FREQ_SYNTH_FRAC, synth_frac);
10042a76:	4b13      	ldr	r3, [pc, #76]	@ (10042ac4 <HAL_MRSubG_SetFrequencyBase+0x84>)
10042a78:	68db      	ldr	r3, [r3, #12]
10042a7a:	0d1b      	lsrs	r3, r3, #20
10042a7c:	0519      	lsls	r1, r3, #20
10042a7e:	68fb      	ldr	r3, [r7, #12]
10042a80:	031b      	lsls	r3, r3, #12
10042a82:	0b1a      	lsrs	r2, r3, #12
10042a84:	4b0f      	ldr	r3, [pc, #60]	@ (10042ac4 <HAL_MRSubG_SetFrequencyBase+0x84>)
10042a86:	430a      	orrs	r2, r1
10042a88:	60da      	str	r2, [r3, #12]
  MODIFY_REG_FIELD(MR_SUBG_GLOB_DYNAMIC->ADDITIONAL_CTRL, MR_SUBG_GLOB_DYNAMIC_ADDITIONAL_CTRL_CH_NUM, 0x00);
10042a8a:	4b0e      	ldr	r3, [pc, #56]	@ (10042ac4 <HAL_MRSubG_SetFrequencyBase+0x84>)
10042a8c:	6a1a      	ldr	r2, [r3, #32]
10042a8e:	4b0d      	ldr	r3, [pc, #52]	@ (10042ac4 <HAL_MRSubG_SetFrequencyBase+0x84>)
10042a90:	21ff      	movs	r1, #255	@ 0xff
10042a92:	438a      	bics	r2, r1
10042a94:	621a      	str	r2, [r3, #32]
  else
  {
    b_factor = (band / 4) - 1;
  }
#else
  b_factor = (band / 4) - 1;
10042a96:	193b      	adds	r3, r7, r4
10042a98:	781b      	ldrb	r3, [r3, #0]
10042a9a:	089b      	lsrs	r3, r3, #2
10042a9c:	b2db      	uxtb	r3, r3
10042a9e:	3b01      	subs	r3, #1
10042aa0:	617b      	str	r3, [r7, #20]
#endif /* STM32WL3RX */

  MODIFY_REG_FIELD(MR_SUBG_GLOB_DYNAMIC->SYNTH_FREQ, MR_SUBG_GLOB_DYNAMIC_SYNTH_FREQ_BS, b_factor);
10042aa2:	4b08      	ldr	r3, [pc, #32]	@ (10042ac4 <HAL_MRSubG_SetFrequencyBase+0x84>)
10042aa4:	68db      	ldr	r3, [r3, #12]
10042aa6:	4a09      	ldr	r2, [pc, #36]	@ (10042acc <HAL_MRSubG_SetFrequencyBase+0x8c>)
10042aa8:	4013      	ands	r3, r2
10042aaa:	0019      	movs	r1, r3
10042aac:	697b      	ldr	r3, [r7, #20]
10042aae:	079a      	lsls	r2, r3, #30
10042ab0:	2380      	movs	r3, #128	@ 0x80
10042ab2:	05db      	lsls	r3, r3, #23
10042ab4:	401a      	ands	r2, r3
10042ab6:	4b03      	ldr	r3, [pc, #12]	@ (10042ac4 <HAL_MRSubG_SetFrequencyBase+0x84>)
10042ab8:	430a      	orrs	r2, r1
10042aba:	60da      	str	r2, [r3, #12]
}
10042abc:	46c0      	nop			@ (mov r8, r8)
10042abe:	46bd      	mov	sp, r7
10042ac0:	b006      	add	sp, #24
10042ac2:	bdb0      	pop	{r4, r5, r7, pc}
10042ac4:	49000500 	.word	0x49000500
10042ac8:	f00fffff 	.word	0xf00fffff
10042acc:	bfffffff 	.word	0xbfffffff

10042ad0 <HAL_MRSubG_SetDatarate>:
  * @brief  Set the datarate.
  * @param  lDatarate datarate expressed in sps.
  * @retval None.
  */
void HAL_MRSubG_SetDatarate(uint32_t lDatarate)
{
10042ad0:	b5b0      	push	{r4, r5, r7, lr}
10042ad2:	b084      	sub	sp, #16
10042ad4:	af00      	add	r7, sp, #0
10042ad6:	6078      	str	r0, [r7, #4]
  uint16_t dr_m;

  assert_param(IS_DATARATE(lDatarate));

  /* Calculates the datarate mantissa and exponent */
  MRSubG_SearchDatarateME(lDatarate, &dr_m, &dr_e);
10042ad8:	240f      	movs	r4, #15
10042ada:	193a      	adds	r2, r7, r4
10042adc:	250c      	movs	r5, #12
10042ade:	1979      	adds	r1, r7, r5
10042ae0:	687b      	ldr	r3, [r7, #4]
10042ae2:	0018      	movs	r0, r3
10042ae4:	f7ff fac6 	bl	10042074 <MRSubG_SearchDatarateME>

  MODIFY_REG_FIELD(MR_SUBG_GLOB_DYNAMIC->MOD0_CONFIG, MR_SUBG_GLOB_DYNAMIC_MOD0_CONFIG_DATARATE_M, dr_m);
10042ae8:	4b0d      	ldr	r3, [pc, #52]	@ (10042b20 <HAL_MRSubG_SetDatarate+0x50>)
10042aea:	685b      	ldr	r3, [r3, #4]
10042aec:	0c1b      	lsrs	r3, r3, #16
10042aee:	041a      	lsls	r2, r3, #16
10042af0:	197b      	adds	r3, r7, r5
10042af2:	881b      	ldrh	r3, [r3, #0]
10042af4:	0019      	movs	r1, r3
10042af6:	4b0a      	ldr	r3, [pc, #40]	@ (10042b20 <HAL_MRSubG_SetDatarate+0x50>)
10042af8:	430a      	orrs	r2, r1
10042afa:	605a      	str	r2, [r3, #4]
  MODIFY_REG_FIELD(MR_SUBG_GLOB_DYNAMIC->MOD0_CONFIG, MR_SUBG_GLOB_DYNAMIC_MOD0_CONFIG_DATARATE_E, dr_e);
10042afc:	4b08      	ldr	r3, [pc, #32]	@ (10042b20 <HAL_MRSubG_SetDatarate+0x50>)
10042afe:	685b      	ldr	r3, [r3, #4]
10042b00:	4a08      	ldr	r2, [pc, #32]	@ (10042b24 <HAL_MRSubG_SetDatarate+0x54>)
10042b02:	4013      	ands	r3, r2
10042b04:	0019      	movs	r1, r3
10042b06:	193b      	adds	r3, r7, r4
10042b08:	781b      	ldrb	r3, [r3, #0]
10042b0a:	041a      	lsls	r2, r3, #16
10042b0c:	23f0      	movs	r3, #240	@ 0xf0
10042b0e:	031b      	lsls	r3, r3, #12
10042b10:	401a      	ands	r2, r3
10042b12:	4b03      	ldr	r3, [pc, #12]	@ (10042b20 <HAL_MRSubG_SetDatarate+0x50>)
10042b14:	430a      	orrs	r2, r1
10042b16:	605a      	str	r2, [r3, #4]
}
10042b18:	46c0      	nop			@ (mov r8, r8)
10042b1a:	46bd      	mov	sp, r7
10042b1c:	b004      	add	sp, #16
10042b1e:	bdb0      	pop	{r4, r5, r7, pc}
10042b20:	49000500 	.word	0x49000500
10042b24:	fff0ffff 	.word	0xfff0ffff

10042b28 <HAL_MRSubG_SetFrequencyDev>:
  * @brief  Set the frequency deviation.
  * @param  lFDev frequency deviation expressed in Hz.
  * @retval None.
  */
void HAL_MRSubG_SetFrequencyDev(uint32_t lFDev)
{
10042b28:	b5b0      	push	{r4, r5, r7, lr}
10042b2a:	b084      	sub	sp, #16
10042b2c:	af00      	add	r7, sp, #0
10042b2e:	6078      	str	r0, [r7, #4]
  else
  {
    bs = (READ_REG_FIELD(MR_SUBG_GLOB_DYNAMIC->SYNTH_FREQ, MR_SUBG_GLOB_DYNAMIC_SYNTH_FREQ_BS) + 1) * 4;
  }
#else
  bs = (READ_REG_FIELD(MR_SUBG_GLOB_DYNAMIC->SYNTH_FREQ, MR_SUBG_GLOB_DYNAMIC_SYNTH_FREQ_BS) + 1) * 4;
10042b30:	4b18      	ldr	r3, [pc, #96]	@ (10042b94 <HAL_MRSubG_SetFrequencyDev+0x6c>)
10042b32:	68db      	ldr	r3, [r3, #12]
10042b34:	0f9b      	lsrs	r3, r3, #30
10042b36:	2201      	movs	r2, #1
10042b38:	4013      	ands	r3, r2
10042b3a:	3301      	adds	r3, #1
10042b3c:	b2da      	uxtb	r2, r3
10042b3e:	210f      	movs	r1, #15
10042b40:	187b      	adds	r3, r7, r1
10042b42:	0092      	lsls	r2, r2, #2
10042b44:	701a      	strb	r2, [r3, #0]
#endif /* STM32WL3RX */
#endif /* STM32WL33XA */

  /* Calculates the frequency deviation mantissa and exponent */
  MRSubG_SearchFreqDevME(lFDev, &uFDevM, &uFDevE, bs);
10042b46:	187b      	adds	r3, r7, r1
10042b48:	781b      	ldrb	r3, [r3, #0]
10042b4a:	240d      	movs	r4, #13
10042b4c:	193a      	adds	r2, r7, r4
10042b4e:	250e      	movs	r5, #14
10042b50:	1979      	adds	r1, r7, r5
10042b52:	6878      	ldr	r0, [r7, #4]
10042b54:	f7ff fc11 	bl	1004237a <MRSubG_SearchFreqDevME>

  MODIFY_REG_FIELD(MR_SUBG_GLOB_DYNAMIC->MOD1_CONFIG, MR_SUBG_GLOB_DYNAMIC_MOD1_CONFIG_FDEV_M, uFDevM);
10042b58:	4b0e      	ldr	r3, [pc, #56]	@ (10042b94 <HAL_MRSubG_SetFrequencyDev+0x6c>)
10042b5a:	689b      	ldr	r3, [r3, #8]
10042b5c:	22ff      	movs	r2, #255	@ 0xff
10042b5e:	4393      	bics	r3, r2
10042b60:	001a      	movs	r2, r3
10042b62:	197b      	adds	r3, r7, r5
10042b64:	781b      	ldrb	r3, [r3, #0]
10042b66:	0019      	movs	r1, r3
10042b68:	4b0a      	ldr	r3, [pc, #40]	@ (10042b94 <HAL_MRSubG_SetFrequencyDev+0x6c>)
10042b6a:	430a      	orrs	r2, r1
10042b6c:	609a      	str	r2, [r3, #8]
  MODIFY_REG_FIELD(MR_SUBG_GLOB_DYNAMIC->MOD1_CONFIG, MR_SUBG_GLOB_DYNAMIC_MOD1_CONFIG_FDEV_E, uFDevE);
10042b6e:	4b09      	ldr	r3, [pc, #36]	@ (10042b94 <HAL_MRSubG_SetFrequencyDev+0x6c>)
10042b70:	689b      	ldr	r3, [r3, #8]
10042b72:	4a09      	ldr	r2, [pc, #36]	@ (10042b98 <HAL_MRSubG_SetFrequencyDev+0x70>)
10042b74:	4013      	ands	r3, r2
10042b76:	0019      	movs	r1, r3
10042b78:	193b      	adds	r3, r7, r4
10042b7a:	781b      	ldrb	r3, [r3, #0]
10042b7c:	021a      	lsls	r2, r3, #8
10042b7e:	23f0      	movs	r3, #240	@ 0xf0
10042b80:	011b      	lsls	r3, r3, #4
10042b82:	401a      	ands	r2, r3
10042b84:	4b03      	ldr	r3, [pc, #12]	@ (10042b94 <HAL_MRSubG_SetFrequencyDev+0x6c>)
10042b86:	430a      	orrs	r2, r1
10042b88:	609a      	str	r2, [r3, #8]
}
10042b8a:	46c0      	nop			@ (mov r8, r8)
10042b8c:	46bd      	mov	sp, r7
10042b8e:	b004      	add	sp, #16
10042b90:	bdb0      	pop	{r4, r5, r7, pc}
10042b92:	46c0      	nop			@ (mov r8, r8)
10042b94:	49000500 	.word	0x49000500
10042b98:	fffff0ff 	.word	0xfffff0ff

10042b9c <HAL_MRSubG_SetChannelBW>:
  *         bandwidth values (@ref s_Channel_Filter_Bandwidth).
  *         To verify the settled channel bandwidth it is possible to use the HAL_MRSubG_GetChannelBW API.
  * @retval None.
  */
void HAL_MRSubG_SetChannelBW(uint32_t lBandwidth)
{
10042b9c:	b5b0      	push	{r4, r5, r7, lr}
10042b9e:	b088      	sub	sp, #32
10042ba0:	af00      	add	r7, sp, #0
10042ba2:	6078      	str	r0, [r7, #4]
  uint8_t uBwM = 0;
10042ba4:	240f      	movs	r4, #15
10042ba6:	193b      	adds	r3, r7, r4
10042ba8:	2200      	movs	r2, #0
10042baa:	701a      	strb	r2, [r3, #0]
  uint8_t uBwE = 0;
10042bac:	250e      	movs	r5, #14
10042bae:	197b      	adds	r3, r7, r5
10042bb0:	2200      	movs	r2, #0
10042bb2:	701a      	strb	r2, [r3, #0]
  uint32_t f_if = 0;
10042bb4:	2300      	movs	r3, #0
10042bb6:	61fb      	str	r3, [r7, #28]
  uint32_t if_offset = 0;
10042bb8:	2300      	movs	r3, #0
10042bba:	61bb      	str	r3, [r7, #24]
  uint32_t chf_threshold = CHANNEL_FILTER_THRESHOLD;
10042bbc:	4b38      	ldr	r3, [pc, #224]	@ (10042ca0 <HAL_MRSubG_SetChannelBW+0x104>)
10042bbe:	617b      	str	r3, [r7, #20]
  uint32_t f_dig = LL_GetXTALFreq() / 3;
10042bc0:	f001 fc7e 	bl	100444c0 <LL_GetXTALFreq>
10042bc4:	0003      	movs	r3, r0
10042bc6:	2103      	movs	r1, #3
10042bc8:	0018      	movs	r0, r3
10042bca:	f7fd fa83 	bl	100400d4 <__udivsi3>
10042bce:	0003      	movs	r3, r0
10042bd0:	613b      	str	r3, [r7, #16]

  /* Calculates the channel bandwidth mantissa and exponent */
  MRSubG_SearchChannelBwME(lBandwidth, &uBwM, &uBwE);
10042bd2:	197a      	adds	r2, r7, r5
10042bd4:	1939      	adds	r1, r7, r4
10042bd6:	687b      	ldr	r3, [r7, #4]
10042bd8:	0018      	movs	r0, r3
10042bda:	f7ff fcdf 	bl	1004259c <MRSubG_SearchChannelBwME>

  MODIFY_REG_FIELD(MR_SUBG_GLOB_DYNAMIC->MOD1_CONFIG, MR_SUBG_GLOB_DYNAMIC_MOD1_CONFIG_CHFLT_M, uBwM);
10042bde:	4b31      	ldr	r3, [pc, #196]	@ (10042ca4 <HAL_MRSubG_SetChannelBW+0x108>)
10042be0:	689b      	ldr	r3, [r3, #8]
10042be2:	4a31      	ldr	r2, [pc, #196]	@ (10042ca8 <HAL_MRSubG_SetChannelBW+0x10c>)
10042be4:	4013      	ands	r3, r2
10042be6:	0019      	movs	r1, r3
10042be8:	193b      	adds	r3, r7, r4
10042bea:	781b      	ldrb	r3, [r3, #0]
10042bec:	041a      	lsls	r2, r3, #16
10042bee:	23f0      	movs	r3, #240	@ 0xf0
10042bf0:	031b      	lsls	r3, r3, #12
10042bf2:	401a      	ands	r2, r3
10042bf4:	4b2b      	ldr	r3, [pc, #172]	@ (10042ca4 <HAL_MRSubG_SetChannelBW+0x108>)
10042bf6:	430a      	orrs	r2, r1
10042bf8:	609a      	str	r2, [r3, #8]
  MODIFY_REG_FIELD(MR_SUBG_GLOB_DYNAMIC->MOD1_CONFIG, MR_SUBG_GLOB_DYNAMIC_MOD1_CONFIG_CHFLT_E, uBwE);
10042bfa:	4b2a      	ldr	r3, [pc, #168]	@ (10042ca4 <HAL_MRSubG_SetChannelBW+0x108>)
10042bfc:	689b      	ldr	r3, [r3, #8]
10042bfe:	4a2b      	ldr	r2, [pc, #172]	@ (10042cac <HAL_MRSubG_SetChannelBW+0x110>)
10042c00:	4013      	ands	r3, r2
10042c02:	0019      	movs	r1, r3
10042c04:	197b      	adds	r3, r7, r5
10042c06:	781b      	ldrb	r3, [r3, #0]
10042c08:	051a      	lsls	r2, r3, #20
10042c0a:	23f0      	movs	r3, #240	@ 0xf0
10042c0c:	041b      	lsls	r3, r3, #16
10042c0e:	401a      	ands	r2, r3
10042c10:	4b24      	ldr	r3, [pc, #144]	@ (10042ca4 <HAL_MRSubG_SetChannelBW+0x108>)
10042c12:	430a      	orrs	r2, r1
10042c14:	609a      	str	r2, [r3, #8]

  /* Set IF to 600 kHz, if channel filter requested is greater than CHF threshold */
  if (lBandwidth > chf_threshold)
10042c16:	687a      	ldr	r2, [r7, #4]
10042c18:	697b      	ldr	r3, [r7, #20]
10042c1a:	429a      	cmp	r2, r3
10042c1c:	d90a      	bls.n	10042c34 <HAL_MRSubG_SetChannelBW+0x98>
  {
    SET_BIT(MR_SUBG_GLOB_STATIC->IF_CTRL, MR_SUBG_GLOB_STATIC_IF_CTRL_IF_MODE);
10042c1e:	4b24      	ldr	r3, [pc, #144]	@ (10042cb0 <HAL_MRSubG_SetChannelBW+0x114>)
10042c20:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
10042c22:	4b23      	ldr	r3, [pc, #140]	@ (10042cb0 <HAL_MRSubG_SetChannelBW+0x114>)
10042c24:	2180      	movs	r1, #128	@ 0x80
10042c26:	0609      	lsls	r1, r1, #24
10042c28:	430a      	orrs	r2, r1
10042c2a:	62da      	str	r2, [r3, #44]	@ 0x2c

    /* Define f_if */
    f_if = IF_FREQ_HIGH;
10042c2c:	2396      	movs	r3, #150	@ 0x96
10042c2e:	009b      	lsls	r3, r3, #2
10042c30:	61fb      	str	r3, [r7, #28]
10042c32:	e008      	b.n	10042c46 <HAL_MRSubG_SetChannelBW+0xaa>
  }
  else
  {
    /* Set antialiasing filter to 684kHz */
    CLEAR_BIT(MR_SUBG_GLOB_STATIC->IF_CTRL, MR_SUBG_GLOB_STATIC_IF_CTRL_IF_MODE);
10042c34:	4b1e      	ldr	r3, [pc, #120]	@ (10042cb0 <HAL_MRSubG_SetChannelBW+0x114>)
10042c36:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
10042c38:	4b1d      	ldr	r3, [pc, #116]	@ (10042cb0 <HAL_MRSubG_SetChannelBW+0x114>)
10042c3a:	0052      	lsls	r2, r2, #1
10042c3c:	0852      	lsrs	r2, r2, #1
10042c3e:	62da      	str	r2, [r3, #44]	@ 0x2c

    /* Define f_if */
    f_if = IF_FREQ_LOW;
10042c40:	2396      	movs	r3, #150	@ 0x96
10042c42:	005b      	lsls	r3, r3, #1
10042c44:	61fb      	str	r3, [r7, #28]
  }

  if_offset = (((f_if * 100) * 65536) / f_dig) * 10;
10042c46:	69fa      	ldr	r2, [r7, #28]
10042c48:	0013      	movs	r3, r2
10042c4a:	009b      	lsls	r3, r3, #2
10042c4c:	189b      	adds	r3, r3, r2
10042c4e:	009a      	lsls	r2, r3, #2
10042c50:	189b      	adds	r3, r3, r2
10042c52:	049b      	lsls	r3, r3, #18
10042c54:	6939      	ldr	r1, [r7, #16]
10042c56:	0018      	movs	r0, r3
10042c58:	f7fd fa3c 	bl	100400d4 <__udivsi3>
10042c5c:	0003      	movs	r3, r0
10042c5e:	001a      	movs	r2, r3
10042c60:	0013      	movs	r3, r2
10042c62:	009b      	lsls	r3, r3, #2
10042c64:	189b      	adds	r3, r3, r2
10042c66:	005b      	lsls	r3, r3, #1
10042c68:	61bb      	str	r3, [r7, #24]
  else
  {
    MODIFY_REG_FIELD(MR_SUBG_GLOB_STATIC->IF_CTRL, MR_SUBG_GLOB_STATIC_IF_CTRL_IF_OFFSET_ANA, if_offset);
  }
#else
  MODIFY_REG_FIELD(MR_SUBG_GLOB_STATIC->IF_CTRL, MR_SUBG_GLOB_STATIC_IF_CTRL_IF_OFFSET_ANA, if_offset);
10042c6a:	4b11      	ldr	r3, [pc, #68]	@ (10042cb0 <HAL_MRSubG_SetChannelBW+0x114>)
10042c6c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
10042c6e:	4a11      	ldr	r2, [pc, #68]	@ (10042cb4 <HAL_MRSubG_SetChannelBW+0x118>)
10042c70:	4013      	ands	r3, r2
10042c72:	0019      	movs	r1, r3
10042c74:	69bb      	ldr	r3, [r7, #24]
10042c76:	041b      	lsls	r3, r3, #16
10042c78:	4a0f      	ldr	r2, [pc, #60]	@ (10042cb8 <HAL_MRSubG_SetChannelBW+0x11c>)
10042c7a:	401a      	ands	r2, r3
10042c7c:	4b0c      	ldr	r3, [pc, #48]	@ (10042cb0 <HAL_MRSubG_SetChannelBW+0x114>)
10042c7e:	430a      	orrs	r2, r1
10042c80:	62da      	str	r2, [r3, #44]	@ 0x2c
#endif /*STM32WL3RX*/

  MODIFY_REG_FIELD(MR_SUBG_GLOB_STATIC->IF_CTRL, MR_SUBG_GLOB_STATIC_IF_CTRL_IF_OFFSET_DIG, if_offset);
10042c82:	4b0b      	ldr	r3, [pc, #44]	@ (10042cb0 <HAL_MRSubG_SetChannelBW+0x114>)
10042c84:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
10042c86:	0b5b      	lsrs	r3, r3, #13
10042c88:	0359      	lsls	r1, r3, #13
10042c8a:	69bb      	ldr	r3, [r7, #24]
10042c8c:	04db      	lsls	r3, r3, #19
10042c8e:	0cda      	lsrs	r2, r3, #19
10042c90:	4b07      	ldr	r3, [pc, #28]	@ (10042cb0 <HAL_MRSubG_SetChannelBW+0x114>)
10042c92:	430a      	orrs	r2, r1
10042c94:	62da      	str	r2, [r3, #44]	@ 0x2c
}
10042c96:	46c0      	nop			@ (mov r8, r8)
10042c98:	46bd      	mov	sp, r7
10042c9a:	b008      	add	sp, #32
10042c9c:	bdb0      	pop	{r4, r5, r7, pc}
10042c9e:	46c0      	nop			@ (mov r8, r8)
10042ca0:	00061a80 	.word	0x00061a80
10042ca4:	49000500 	.word	0x49000500
10042ca8:	fff0ffff 	.word	0xfff0ffff
10042cac:	ff0fffff 	.word	0xff0fffff
10042cb0:	49000400 	.word	0x49000400
10042cb4:	e000ffff 	.word	0xe000ffff
10042cb8:	1fff0000 	.word	0x1fff0000

10042cbc <HAL_MRSubG_SetModulation>:
  *         This parameter shall be of type @ref MRSubGModSelect.
  * @param  dsssExponent the DSSS spreading exponent. 0 means DSSS disabled.
  * @retval None.
  */
void HAL_MRSubG_SetModulation(MRSubGModSelect xModulation, uint8_t dsssExponent)
{
10042cbc:	b580      	push	{r7, lr}
10042cbe:	b082      	sub	sp, #8
10042cc0:	af00      	add	r7, sp, #0
10042cc2:	0002      	movs	r2, r0
10042cc4:	1dfb      	adds	r3, r7, #7
10042cc6:	701a      	strb	r2, [r3, #0]
10042cc8:	1dbb      	adds	r3, r7, #6
10042cca:	1c0a      	adds	r2, r1, #0
10042ccc:	701a      	strb	r2, [r3, #0]
  assert_param(IS_MODULATION(xModulation));

  /* Internal equalizer */
  switch (xModulation)
10042cce:	1dfb      	adds	r3, r7, #7
10042cd0:	781b      	ldrb	r3, [r3, #0]
10042cd2:	2b03      	cmp	r3, #3
10042cd4:	dc02      	bgt.n	10042cdc <HAL_MRSubG_SetModulation+0x20>
10042cd6:	2b02      	cmp	r3, #2
10042cd8:	da03      	bge.n	10042ce2 <HAL_MRSubG_SetModulation+0x26>
10042cda:	e00c      	b.n	10042cf6 <HAL_MRSubG_SetModulation+0x3a>
10042cdc:	3b12      	subs	r3, #18
10042cde:	2b01      	cmp	r3, #1
10042ce0:	d809      	bhi.n	10042cf6 <HAL_MRSubG_SetModulation+0x3a>
    case MOD_4GFSK05:
    case MOD_2GFSK1:
    case MOD_4GFSK1:
      /*In case of gaussian filter, in order to reduce intersymbol interference (ISI),
      * we have to set the internal equalizer to 2 symbols */
      MODIFY_REG_FIELD(MR_SUBG_GLOB_STATIC->AS_QI_CTRL, MR_SUBG_GLOB_STATIC_AS_QI_CTRL_AS_EQU_CTRL, 0x02);
10042ce2:	4b33      	ldr	r3, [pc, #204]	@ (10042db0 <HAL_MRSubG_SetModulation+0xf4>)
10042ce4:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
10042ce6:	4a33      	ldr	r2, [pc, #204]	@ (10042db4 <HAL_MRSubG_SetModulation+0xf8>)
10042ce8:	401a      	ands	r2, r3
10042cea:	4b31      	ldr	r3, [pc, #196]	@ (10042db0 <HAL_MRSubG_SetModulation+0xf4>)
10042cec:	2180      	movs	r1, #128	@ 0x80
10042cee:	0509      	lsls	r1, r1, #20
10042cf0:	430a      	orrs	r2, r1
10042cf2:	631a      	str	r2, [r3, #48]	@ 0x30
      break;
10042cf4:	e005      	b.n	10042d02 <HAL_MRSubG_SetModulation+0x46>
    default:
      /* For non gaussian modulation set internal equalizer to 0 symbols */
      MODIFY_REG_FIELD(MR_SUBG_GLOB_STATIC->AS_QI_CTRL, MR_SUBG_GLOB_STATIC_AS_QI_CTRL_AS_EQU_CTRL, 0x00);
10042cf6:	4b2e      	ldr	r3, [pc, #184]	@ (10042db0 <HAL_MRSubG_SetModulation+0xf4>)
10042cf8:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
10042cfa:	4b2d      	ldr	r3, [pc, #180]	@ (10042db0 <HAL_MRSubG_SetModulation+0xf4>)
10042cfc:	492d      	ldr	r1, [pc, #180]	@ (10042db4 <HAL_MRSubG_SetModulation+0xf8>)
10042cfe:	400a      	ands	r2, r1
10042d00:	631a      	str	r2, [r3, #48]	@ 0x30
  }

  /* Post filter */
  switch (xModulation)
10042d02:	1dfb      	adds	r3, r7, #7
10042d04:	781b      	ldrb	r3, [r3, #0]
10042d06:	2213      	movs	r2, #19
10042d08:	429a      	cmp	r2, r3
10042d0a:	4192      	sbcs	r2, r2
10042d0c:	4252      	negs	r2, r2
10042d0e:	b2d2      	uxtb	r2, r2
10042d10:	2a00      	cmp	r2, #0
10042d12:	d112      	bne.n	10042d3a <HAL_MRSubG_SetModulation+0x7e>
10042d14:	4a28      	ldr	r2, [pc, #160]	@ (10042db8 <HAL_MRSubG_SetModulation+0xfc>)
10042d16:	40da      	lsrs	r2, r3
10042d18:	0013      	movs	r3, r2
10042d1a:	2201      	movs	r2, #1
10042d1c:	4013      	ands	r3, r2
10042d1e:	1e5a      	subs	r2, r3, #1
10042d20:	4193      	sbcs	r3, r2
10042d22:	b2db      	uxtb	r3, r3
10042d24:	2b00      	cmp	r3, #0
10042d26:	d008      	beq.n	10042d3a <HAL_MRSubG_SetModulation+0x7e>
    case MOD_4GFSK05:
    case MOD_4GFSK1:
    case MOD_4FSK:
      /*In case of 4 level FSK modulation, in order to reduce intersymbol interference (ISI),
      * we have to set the post filter len equal to 8 (register value 0). */
      MODIFY_REG_FIELD(MR_SUBG_RADIO->CLKREC_CTRL0, MR_SUBG_RADIO_CLKREC_CTRL0_PSTFLT_LEN, 0x00);
10042d28:	2392      	movs	r3, #146	@ 0x92
10042d2a:	05db      	lsls	r3, r3, #23
10042d2c:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
10042d2e:	2392      	movs	r3, #146	@ 0x92
10042d30:	05db      	lsls	r3, r3, #23
10042d32:	2180      	movs	r1, #128	@ 0x80
10042d34:	438a      	bics	r2, r1
10042d36:	631a      	str	r2, [r3, #48]	@ 0x30
      break;
10042d38:	e007      	b.n	10042d4a <HAL_MRSubG_SetModulation+0x8e>
    default:
      MODIFY_REG_FIELD(MR_SUBG_RADIO->CLKREC_CTRL0, MR_SUBG_RADIO_CLKREC_CTRL0_PSTFLT_LEN, 0x01);
10042d3a:	2392      	movs	r3, #146	@ 0x92
10042d3c:	05db      	lsls	r3, r3, #23
10042d3e:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
10042d40:	2392      	movs	r3, #146	@ 0x92
10042d42:	05db      	lsls	r3, r3, #23
10042d44:	2180      	movs	r1, #128	@ 0x80
10042d46:	430a      	orrs	r2, r1
10042d48:	631a      	str	r2, [r3, #48]	@ 0x30
  }

  /* Modulation */
  switch (xModulation)
10042d4a:	1dfb      	adds	r3, r7, #7
10042d4c:	781b      	ldrb	r3, [r3, #0]
10042d4e:	3b12      	subs	r3, #18
10042d50:	2b01      	cmp	r3, #1
10042d52:	d80d      	bhi.n	10042d70 <HAL_MRSubG_SetModulation+0xb4>
  {
    case MOD_2GFSK05:
    case MOD_4GFSK05:
      MODIFY_REG_FIELD(MR_SUBG_GLOB_DYNAMIC->MOD0_CONFIG, MR_SUBG_GLOB_DYNAMIC_MOD0_CONFIG_BT_SEL, 1);
10042d54:	4b19      	ldr	r3, [pc, #100]	@ (10042dbc <HAL_MRSubG_SetModulation+0x100>)
10042d56:	685a      	ldr	r2, [r3, #4]
10042d58:	4b18      	ldr	r3, [pc, #96]	@ (10042dbc <HAL_MRSubG_SetModulation+0x100>)
10042d5a:	2180      	movs	r1, #128	@ 0x80
10042d5c:	04c9      	lsls	r1, r1, #19
10042d5e:	430a      	orrs	r2, r1
10042d60:	605a      	str	r2, [r3, #4]
      xModulation &= 0x0F;
10042d62:	1dfb      	adds	r3, r7, #7
10042d64:	1dfa      	adds	r2, r7, #7
10042d66:	7812      	ldrb	r2, [r2, #0]
10042d68:	210f      	movs	r1, #15
10042d6a:	400a      	ands	r2, r1
10042d6c:	701a      	strb	r2, [r3, #0]
      break;
10042d6e:	e005      	b.n	10042d7c <HAL_MRSubG_SetModulation+0xc0>
    default:
      MODIFY_REG_FIELD(MR_SUBG_GLOB_DYNAMIC->MOD0_CONFIG, MR_SUBG_GLOB_DYNAMIC_MOD0_CONFIG_BT_SEL, 0);
10042d70:	4b12      	ldr	r3, [pc, #72]	@ (10042dbc <HAL_MRSubG_SetModulation+0x100>)
10042d72:	685a      	ldr	r2, [r3, #4]
10042d74:	4b11      	ldr	r3, [pc, #68]	@ (10042dbc <HAL_MRSubG_SetModulation+0x100>)
10042d76:	4912      	ldr	r1, [pc, #72]	@ (10042dc0 <HAL_MRSubG_SetModulation+0x104>)
10042d78:	400a      	ands	r2, r1
10042d7a:	605a      	str	r2, [r3, #4]
  }

  /* Evaluate DSSS settings */
  MRSUBG_EvaluateDSSS(xModulation, dsssExponent);
10042d7c:	1dbb      	adds	r3, r7, #6
10042d7e:	781a      	ldrb	r2, [r3, #0]
10042d80:	1dfb      	adds	r3, r7, #7
10042d82:	781b      	ldrb	r3, [r3, #0]
10042d84:	0011      	movs	r1, r2
10042d86:	0018      	movs	r0, r3
10042d88:	f7ff fd62 	bl	10042850 <MRSUBG_EvaluateDSSS>

  MODIFY_REG_FIELD(MR_SUBG_GLOB_DYNAMIC->MOD0_CONFIG, MR_SUBG_GLOB_DYNAMIC_MOD0_CONFIG_MOD_TYPE, xModulation);
10042d8c:	4b0b      	ldr	r3, [pc, #44]	@ (10042dbc <HAL_MRSubG_SetModulation+0x100>)
10042d8e:	685b      	ldr	r3, [r3, #4]
10042d90:	4a0c      	ldr	r2, [pc, #48]	@ (10042dc4 <HAL_MRSubG_SetModulation+0x108>)
10042d92:	4013      	ands	r3, r2
10042d94:	0019      	movs	r1, r3
10042d96:	1dfb      	adds	r3, r7, #7
10042d98:	781b      	ldrb	r3, [r3, #0]
10042d9a:	051a      	lsls	r2, r3, #20
10042d9c:	23e0      	movs	r3, #224	@ 0xe0
10042d9e:	03db      	lsls	r3, r3, #15
10042da0:	401a      	ands	r2, r3
10042da2:	4b06      	ldr	r3, [pc, #24]	@ (10042dbc <HAL_MRSubG_SetModulation+0x100>)
10042da4:	430a      	orrs	r2, r1
10042da6:	605a      	str	r2, [r3, #4]
}
10042da8:	46c0      	nop			@ (mov r8, r8)
10042daa:	46bd      	mov	sp, r7
10042dac:	b002      	add	sp, #8
10042dae:	bd80      	pop	{r7, pc}
10042db0:	49000400 	.word	0x49000400
10042db4:	f3ffffff 	.word	0xf3ffffff
10042db8:	0008000a 	.word	0x0008000a
10042dbc:	49000500 	.word	0x49000500
10042dc0:	fbffffff 	.word	0xfbffffff
10042dc4:	ff8fffff 	.word	0xff8fffff

10042dc8 <HAL_MRSubG_SetPALeveldBm>:
  * @param  lPowerdBm PA value to write expressed in dBm.
  * @param  drvMode PA drive modes.
  * @retval None.
  */
void HAL_MRSubG_SetPALeveldBm(uint8_t cIndex, int8_t lPowerdBm, MRSubG_PA_DRVMode drvMode)
{
10042dc8:	b5b0      	push	{r4, r5, r7, lr}
10042dca:	b086      	sub	sp, #24
10042dcc:	af00      	add	r7, sp, #0
10042dce:	0004      	movs	r4, r0
10042dd0:	0008      	movs	r0, r1
10042dd2:	0011      	movs	r1, r2
10042dd4:	1dfb      	adds	r3, r7, #7
10042dd6:	1c22      	adds	r2, r4, #0
10042dd8:	701a      	strb	r2, [r3, #0]
10042dda:	1dbb      	adds	r3, r7, #6
10042ddc:	1c02      	adds	r2, r0, #0
10042dde:	701a      	strb	r2, [r3, #0]
10042de0:	1d7b      	adds	r3, r7, #5
10042de2:	1c0a      	adds	r2, r1, #0
10042de4:	701a      	strb	r2, [r3, #0]
  int32_t pa03 = 0;
10042de6:	2300      	movs	r3, #0
10042de8:	617b      	str	r3, [r7, #20]
  int32_t pa07 = 0;
10042dea:	2300      	movs	r3, #0
10042dec:	613b      	str	r3, [r7, #16]
  uint8_t maxAllowedValue;

  SET_BIT(MR_SUBG_GLOB_STATIC->PA_CONFIG, MR_SUBG_GLOB_STATIC_PA_CONFIG_PA_RAMP_ENABLE);
10042dee:	4b50      	ldr	r3, [pc, #320]	@ (10042f30 <HAL_MRSubG_SetPALeveldBm+0x168>)
10042df0:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
10042df2:	4b4f      	ldr	r3, [pc, #316]	@ (10042f30 <HAL_MRSubG_SetPALeveldBm+0x168>)
10042df4:	2180      	movs	r1, #128	@ 0x80
10042df6:	01c9      	lsls	r1, r1, #7
10042df8:	430a      	orrs	r2, r1
10042dfa:	629a      	str	r2, [r3, #40]	@ 0x28

  LL_MRSubG_SetPAMode(PA_LEGACY);
10042dfc:	2000      	movs	r0, #0
10042dfe:	f7fe fe7b 	bl	10041af8 <LL_MRSubG_SetPAMode>
  LL_MRSubG_SetPADriveMode(drvMode);
10042e02:	1d7b      	adds	r3, r7, #5
10042e04:	781b      	ldrb	r3, [r3, #0]
10042e06:	0018      	movs	r0, r3
10042e08:	f7fe fe92 	bl	10041b30 <LL_MRSubG_SetPADriveMode>

  MODIFY_REG_FIELD(MR_SUBG_GLOB_STATIC->PA_CONFIG, MR_SUBG_GLOB_STATIC_PA_CONFIG_PA_LEVEL_MAX_INDEX, cIndex);
10042e0c:	4b48      	ldr	r3, [pc, #288]	@ (10042f30 <HAL_MRSubG_SetPALeveldBm+0x168>)
10042e0e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
10042e10:	221c      	movs	r2, #28
10042e12:	4393      	bics	r3, r2
10042e14:	0019      	movs	r1, r3
10042e16:	1dfb      	adds	r3, r7, #7
10042e18:	781b      	ldrb	r3, [r3, #0]
10042e1a:	009b      	lsls	r3, r3, #2
10042e1c:	221c      	movs	r2, #28
10042e1e:	401a      	ands	r2, r3
10042e20:	4b43      	ldr	r3, [pc, #268]	@ (10042f30 <HAL_MRSubG_SetPALeveldBm+0x168>)
10042e22:	430a      	orrs	r2, r1
10042e24:	629a      	str	r2, [r3, #40]	@ 0x28

  maxAllowedValue = MRSubG_GetAllowedMaxOutputPower(drvMode);
10042e26:	250d      	movs	r5, #13
10042e28:	197c      	adds	r4, r7, r5
10042e2a:	1d7b      	adds	r3, r7, #5
10042e2c:	781b      	ldrb	r3, [r3, #0]
10042e2e:	0018      	movs	r0, r3
10042e30:	f7ff fce4 	bl	100427fc <MRSubG_GetAllowedMaxOutputPower>
10042e34:	0003      	movs	r3, r0
10042e36:	7023      	strb	r3, [r4, #0]

  if (lPowerdBm > maxAllowedValue)
10042e38:	1dbb      	adds	r3, r7, #6
10042e3a:	2200      	movs	r2, #0
10042e3c:	569a      	ldrsb	r2, [r3, r2]
10042e3e:	197b      	adds	r3, r7, r5
10042e40:	781b      	ldrb	r3, [r3, #0]
10042e42:	429a      	cmp	r2, r3
10042e44:	dd06      	ble.n	10042e54 <HAL_MRSubG_SetPALeveldBm+0x8c>
  {
    lPowerdBm = MAX_DBM;
10042e46:	1dbb      	adds	r3, r7, #6
10042e48:	2251      	movs	r2, #81	@ 0x51
10042e4a:	701a      	strb	r2, [r3, #0]
    LL_MRSubG_SetPADegen(ENABLE);
10042e4c:	2001      	movs	r0, #1
10042e4e:	f7fe fe8b 	bl	10041b68 <LL_MRSubG_SetPADegen>
10042e52:	e017      	b.n	10042e84 <HAL_MRSubG_SetPALeveldBm+0xbc>
  }
  else
  {
    int8_t tmpPow;
    tmpPow = MAX_DBM - ((maxAllowedValue - lPowerdBm) * 2);
10042e54:	230d      	movs	r3, #13
10042e56:	18fb      	adds	r3, r7, r3
10042e58:	781a      	ldrb	r2, [r3, #0]
10042e5a:	1dbb      	adds	r3, r7, #6
10042e5c:	781b      	ldrb	r3, [r3, #0]
10042e5e:	b25b      	sxtb	r3, r3
10042e60:	1ad3      	subs	r3, r2, r3
10042e62:	b2db      	uxtb	r3, r3
10042e64:	18db      	adds	r3, r3, r3
10042e66:	b2db      	uxtb	r3, r3
10042e68:	2251      	movs	r2, #81	@ 0x51
10042e6a:	1ad3      	subs	r3, r2, r3
10042e6c:	b2da      	uxtb	r2, r3
10042e6e:	210c      	movs	r1, #12
10042e70:	187b      	adds	r3, r7, r1
10042e72:	701a      	strb	r2, [r3, #0]

    lPowerdBm = tmpPow > 0 ? tmpPow : 0;
10042e74:	1dba      	adds	r2, r7, #6
10042e76:	187b      	adds	r3, r7, r1
10042e78:	781b      	ldrb	r3, [r3, #0]
10042e7a:	b259      	sxtb	r1, r3
10042e7c:	2900      	cmp	r1, #0
10042e7e:	da00      	bge.n	10042e82 <HAL_MRSubG_SetPALeveldBm+0xba>
10042e80:	2300      	movs	r3, #0
10042e82:	7013      	strb	r3, [r2, #0]
  }

  for (int16_t i = cIndex; i >= 0; i--)
10042e84:	230e      	movs	r3, #14
10042e86:	18fb      	adds	r3, r7, r3
10042e88:	1dfa      	adds	r2, r7, #7
10042e8a:	7812      	ldrb	r2, [r2, #0]
10042e8c:	801a      	strh	r2, [r3, #0]
10042e8e:	e03f      	b.n	10042f10 <HAL_MRSubG_SetPALeveldBm+0x148>
  {
    if (i < 4)
10042e90:	210e      	movs	r1, #14
10042e92:	187b      	adds	r3, r7, r1
10042e94:	2200      	movs	r2, #0
10042e96:	5e9b      	ldrsh	r3, [r3, r2]
10042e98:	2b03      	cmp	r3, #3
10042e9a:	dc0c      	bgt.n	10042eb6 <HAL_MRSubG_SetPALeveldBm+0xee>
    {
      pa03 |= (int32_t)(lPowerdBm) << (i * 8);
10042e9c:	1dbb      	adds	r3, r7, #6
10042e9e:	2200      	movs	r2, #0
10042ea0:	569a      	ldrsb	r2, [r3, r2]
10042ea2:	187b      	adds	r3, r7, r1
10042ea4:	2100      	movs	r1, #0
10042ea6:	5e5b      	ldrsh	r3, [r3, r1]
10042ea8:	00db      	lsls	r3, r3, #3
10042eaa:	409a      	lsls	r2, r3
10042eac:	0013      	movs	r3, r2
10042eae:	697a      	ldr	r2, [r7, #20]
10042eb0:	4313      	orrs	r3, r2
10042eb2:	617b      	str	r3, [r7, #20]
10042eb4:	e015      	b.n	10042ee2 <HAL_MRSubG_SetPALeveldBm+0x11a>
    }
    else
      pa07 |= (int32_t)lPowerdBm
10042eb6:	1dbb      	adds	r3, r7, #6
10042eb8:	2200      	movs	r2, #0
10042eba:	569a      	ldrsb	r2, [r3, r2]
              << ((i % 4) * 8);
10042ebc:	230e      	movs	r3, #14
10042ebe:	18fb      	adds	r3, r7, r3
10042ec0:	2100      	movs	r1, #0
10042ec2:	5e5b      	ldrsh	r3, [r3, r1]
10042ec4:	491b      	ldr	r1, [pc, #108]	@ (10042f34 <HAL_MRSubG_SetPALeveldBm+0x16c>)
10042ec6:	400b      	ands	r3, r1
10042ec8:	d504      	bpl.n	10042ed4 <HAL_MRSubG_SetPALeveldBm+0x10c>
10042eca:	3b01      	subs	r3, #1
10042ecc:	2104      	movs	r1, #4
10042ece:	4249      	negs	r1, r1
10042ed0:	430b      	orrs	r3, r1
10042ed2:	3301      	adds	r3, #1
10042ed4:	b21b      	sxth	r3, r3
10042ed6:	00db      	lsls	r3, r3, #3
10042ed8:	409a      	lsls	r2, r3
10042eda:	0013      	movs	r3, r2
      pa07 |= (int32_t)lPowerdBm
10042edc:	693a      	ldr	r2, [r7, #16]
10042ede:	4313      	orrs	r3, r2
10042ee0:	613b      	str	r3, [r7, #16]
    lPowerdBm = (lPowerdBm - 10) > 0 ? lPowerdBm - 10 : 0;
10042ee2:	1dbb      	adds	r3, r7, #6
10042ee4:	781b      	ldrb	r3, [r3, #0]
10042ee6:	b25b      	sxtb	r3, r3
10042ee8:	2b0a      	cmp	r3, #10
10042eea:	dd05      	ble.n	10042ef8 <HAL_MRSubG_SetPALeveldBm+0x130>
10042eec:	1dbb      	adds	r3, r7, #6
10042eee:	781b      	ldrb	r3, [r3, #0]
10042ef0:	3b0a      	subs	r3, #10
10042ef2:	b2db      	uxtb	r3, r3
10042ef4:	b25a      	sxtb	r2, r3
10042ef6:	e000      	b.n	10042efa <HAL_MRSubG_SetPALeveldBm+0x132>
10042ef8:	2200      	movs	r2, #0
10042efa:	1dbb      	adds	r3, r7, #6
10042efc:	701a      	strb	r2, [r3, #0]
  for (int16_t i = cIndex; i >= 0; i--)
10042efe:	210e      	movs	r1, #14
10042f00:	187b      	adds	r3, r7, r1
10042f02:	2200      	movs	r2, #0
10042f04:	5e9b      	ldrsh	r3, [r3, r2]
10042f06:	b29b      	uxth	r3, r3
10042f08:	3b01      	subs	r3, #1
10042f0a:	b29a      	uxth	r2, r3
10042f0c:	187b      	adds	r3, r7, r1
10042f0e:	801a      	strh	r2, [r3, #0]
10042f10:	230e      	movs	r3, #14
10042f12:	18fb      	adds	r3, r7, r3
10042f14:	2200      	movs	r2, #0
10042f16:	5e9b      	ldrsh	r3, [r3, r2]
10042f18:	2b00      	cmp	r3, #0
10042f1a:	dab9      	bge.n	10042e90 <HAL_MRSubG_SetPALeveldBm+0xc8>
  }

  WRITE_REG(MR_SUBG_GLOB_STATIC->PA_LEVEL_3_0, pa03);
10042f1c:	4b04      	ldr	r3, [pc, #16]	@ (10042f30 <HAL_MRSubG_SetPALeveldBm+0x168>)
10042f1e:	697a      	ldr	r2, [r7, #20]
10042f20:	621a      	str	r2, [r3, #32]
  WRITE_REG(MR_SUBG_GLOB_STATIC->PA_LEVEL_7_4, pa07);
10042f22:	4b03      	ldr	r3, [pc, #12]	@ (10042f30 <HAL_MRSubG_SetPALeveldBm+0x168>)
10042f24:	693a      	ldr	r2, [r7, #16]
10042f26:	625a      	str	r2, [r3, #36]	@ 0x24
}
10042f28:	46c0      	nop			@ (mov r8, r8)
10042f2a:	46bd      	mov	sp, r7
10042f2c:	b006      	add	sp, #24
10042f2e:	bdb0      	pop	{r4, r5, r7, pc}
10042f30:	49000400 	.word	0x49000400
10042f34:	80000003 	.word	0x80000003

10042f38 <HAL_MRSubG_PktBasicSetPayloadLength>:
  * @brief  Set the payload length for the Basic packet format.
  * @param  nPayloadLength payload length in bytes.
  * @retval None.
  */
void HAL_MRSubG_PktBasicSetPayloadLength(uint16_t nPayloadLength)
{
10042f38:	b580      	push	{r7, lr}
10042f3a:	b082      	sub	sp, #8
10042f3c:	af00      	add	r7, sp, #0
10042f3e:	0002      	movs	r2, r0
10042f40:	1dbb      	adds	r3, r7, #6
10042f42:	801a      	strh	r2, [r3, #0]
  MODIFY_REG_FIELD(MR_SUBG_GLOB_STATIC->DATABUFFER_SIZE, MR_SUBG_GLOB_STATIC_DATABUFFER_SIZE_DATABUFFER_SIZE,
10042f44:	4b08      	ldr	r3, [pc, #32]	@ (10042f68 <HAL_MRSubG_PktBasicSetPayloadLength+0x30>)
10042f46:	69db      	ldr	r3, [r3, #28]
10042f48:	0c1b      	lsrs	r3, r3, #16
10042f4a:	0419      	lsls	r1, r3, #16
10042f4c:	1dbb      	adds	r3, r7, #6
10042f4e:	881a      	ldrh	r2, [r3, #0]
10042f50:	4b05      	ldr	r3, [pc, #20]	@ (10042f68 <HAL_MRSubG_PktBasicSetPayloadLength+0x30>)
10042f52:	430a      	orrs	r2, r1
10042f54:	61da      	str	r2, [r3, #28]
                   nPayloadLength);
  LL_MRSUBG_SetPacketLength(nPayloadLength);
10042f56:	1dbb      	adds	r3, r7, #6
10042f58:	881b      	ldrh	r3, [r3, #0]
10042f5a:	0018      	movs	r0, r3
10042f5c:	f7fe ff66 	bl	10041e2c <LL_MRSUBG_SetPacketLength>
}
10042f60:	46c0      	nop			@ (mov r8, r8)
10042f62:	46bd      	mov	sp, r7
10042f64:	b002      	add	sp, #8
10042f66:	bd80      	pop	{r7, pc}
10042f68:	49000400 	.word	0x49000400

10042f6c <HAL_MRSubG_PacketBasicInit>:
  * @param  pxPktBasicInit Basic packet init structure.
  *         This parameter is a pointer to @ref MRSubG_PcktBasicFields_t.
  * @retval None.
  */
void HAL_MRSubG_PacketBasicInit(MRSubG_PcktBasicFields_t *pxPktBasicInit)
{
10042f6c:	b580      	push	{r7, lr}
10042f6e:	b082      	sub	sp, #8
10042f70:	af00      	add	r7, sp, #0
10042f72:	6078      	str	r0, [r7, #4]
  assert_param(IS_PREAMBLE_LEN(pxPktBasicInit->PreambleLength));
  assert_param(IS_SYNC_LEN(pxPktBasicInit->SyncLength));
  assert_param(IS_FUNCTIONAL_STATE(pxPktBasicInit->DataWhitening));

  /* Set the Packet Format to Basic Packet */
  MODIFY_REG_FIELD(MR_SUBG_GLOB_STATIC->PCKT_CTRL, MR_SUBG_GLOB_STATIC_PCKT_CTRL_PCKT_FORMAT, PKT_BASIC);
10042f74:	4b29      	ldr	r3, [pc, #164]	@ (1004301c <HAL_MRSubG_PacketBasicInit+0xb0>)
10042f76:	691a      	ldr	r2, [r3, #16]
10042f78:	4b28      	ldr	r3, [pc, #160]	@ (1004301c <HAL_MRSubG_PacketBasicInit+0xb0>)
10042f7a:	2101      	movs	r1, #1
10042f7c:	438a      	bics	r2, r1
10042f7e:	611a      	str	r2, [r3, #16]

  /* Init the Whitening to 0x1FF */
  LL_MRSubG_PacketHandlerSetWhiteningInit(0x1FF);
10042f80:	4b27      	ldr	r3, [pc, #156]	@ (10043020 <HAL_MRSubG_PacketBasicInit+0xb4>)
10042f82:	0018      	movs	r0, r3
10042f84:	f7fe ff00 	bl	10041d88 <LL_MRSubG_PacketHandlerSetWhiteningInit>

  /* Set the SYNC */
  LL_MRSubG_SetSyncPresent(pxPktBasicInit->SyncPresent);
10042f88:	687b      	ldr	r3, [r7, #4]
10042f8a:	7cdb      	ldrb	r3, [r3, #19]
10042f8c:	0018      	movs	r0, r3
10042f8e:	f7fe fe7b 	bl	10041c88 <LL_MRSubG_SetSyncPresent>
  LL_MRSubG_SetSyncLength(pxPktBasicInit->SyncLength);
10042f92:	687b      	ldr	r3, [r7, #4]
10042f94:	791b      	ldrb	r3, [r3, #4]
10042f96:	0018      	movs	r0, r3
10042f98:	f7fe feac 	bl	10041cf4 <LL_MRSubG_SetSyncLength>
  LL_MRSubG_SetSyncWord(pxPktBasicInit->SyncWord);
10042f9c:	687b      	ldr	r3, [r7, #4]
10042f9e:	689b      	ldr	r3, [r3, #8]
10042fa0:	0018      	movs	r0, r3
10042fa2:	f7fe fec3 	bl	10041d2c <LL_MRSubG_SetSyncWord>
  LL_MRSubG_SetSecondarySync(DISABLE);
10042fa6:	2000      	movs	r0, #0
10042fa8:	f7fe fe8a 	bl	10041cc0 <LL_MRSubG_SetSecondarySync>

  /* Set the PREAMBLE */
  LL_MRSubG_SetPreambleLength(pxPktBasicInit->PreambleLength);
10042fac:	687b      	ldr	r3, [r7, #4]
10042fae:	881b      	ldrh	r3, [r3, #0]
10042fb0:	0018      	movs	r0, r3
10042fb2:	f7fe fdfd 	bl	10041bb0 <LL_MRSubG_SetPreambleLength>
  LL_MRSubG_SetPreambleSeq(pxPktBasicInit->PreambleSequence);
10042fb6:	687b      	ldr	r3, [r7, #4]
10042fb8:	7b5b      	ldrb	r3, [r3, #13]
10042fba:	0018      	movs	r0, r3
10042fbc:	f7fe fe16 	bl	10041bec <LL_MRSubG_SetPreambleSeq>

  LL_MRSubG_PacketHandlerWhitening(pxPktBasicInit->DataWhitening);
10042fc0:	687b      	ldr	r3, [r7, #4]
10042fc2:	7c5b      	ldrb	r3, [r3, #17]
10042fc4:	0018      	movs	r0, r3
10042fc6:	f7fe febf 	bl	10041d48 <LL_MRSubG_PacketHandlerWhitening>
  LL_MRSubG_PacketHandlerCoding(pxPktBasicInit->Coding);
10042fca:	687b      	ldr	r3, [r7, #4]
10042fcc:	7c1b      	ldrb	r3, [r3, #16]
10042fce:	0018      	movs	r0, r3
10042fd0:	f7fe fef8 	bl	10041dc4 <LL_MRSubG_PacketHandlerCoding>
  LL_MRSubG_PacketHandlerSetCrcMode(pxPktBasicInit->CrcMode);
10042fd4:	687b      	ldr	r3, [r7, #4]
10042fd6:	7bdb      	ldrb	r3, [r3, #15]
10042fd8:	0018      	movs	r0, r3
10042fda:	f7fe ff0f 	bl	10041dfc <LL_MRSubG_PacketHandlerSetCrcMode>
  MODIFY_REG(MR_SUBG_GLOB_STATIC->CRC_INIT, MR_SUBG_GLOB_STATIC_CRC_INIT_CRC_INIT_VAL, 0xFFFFFFFF);
10042fde:	4b0f      	ldr	r3, [pc, #60]	@ (1004301c <HAL_MRSubG_PacketBasicInit+0xb0>)
10042fe0:	68db      	ldr	r3, [r3, #12]
10042fe2:	4b0e      	ldr	r3, [pc, #56]	@ (1004301c <HAL_MRSubG_PacketBasicInit+0xb0>)
10042fe4:	2201      	movs	r2, #1
10042fe6:	4252      	negs	r2, r2
10042fe8:	60da      	str	r2, [r3, #12]

  /* Set the Fixed or Variable Packet Length mode */
  LL_MRSUBG_SetFixedVariableLength(pxPktBasicInit->FixVarLength);
10042fea:	687b      	ldr	r3, [r7, #4]
10042fec:	7b1b      	ldrb	r3, [r3, #12]
10042fee:	0018      	movs	r0, r3
10042ff0:	f7fe ff32 	bl	10041e58 <LL_MRSUBG_SetFixedVariableLength>

  /* Set the Packet Length width. Relevant only if FIX_VAR_LEN=1  */
  LL_MRSubG_SetLenWidth(pxPktBasicInit->LengthWidth);
10042ff4:	687b      	ldr	r3, [r7, #4]
10042ff6:	7c9b      	ldrb	r3, [r3, #18]
10042ff8:	0018      	movs	r0, r3
10042ffa:	f7fe ff49 	bl	10041e90 <LL_MRSubG_SetLenWidth>

  LL_MRSubG_SetPostambleLength(pxPktBasicInit->PostambleLength);
10042ffe:	687b      	ldr	r3, [r7, #4]
10043000:	885b      	ldrh	r3, [r3, #2]
10043002:	0018      	movs	r0, r3
10043004:	f7fe fe0e 	bl	10041c24 <LL_MRSubG_SetPostambleLength>
  LL_MRSubG_SetPostamblSeq(pxPktBasicInit->PostambleSequence);
10043008:	687b      	ldr	r3, [r7, #4]
1004300a:	7b9b      	ldrb	r3, [r3, #14]
1004300c:	0018      	movs	r0, r3
1004300e:	f7fe fe25 	bl	10041c5c <LL_MRSubG_SetPostamblSeq>
}
10043012:	46c0      	nop			@ (mov r8, r8)
10043014:	46bd      	mov	sp, r7
10043016:	b002      	add	sp, #8
10043018:	bd80      	pop	{r7, pc}
1004301a:	46c0      	nop			@ (mov r8, r8)
1004301c:	49000400 	.word	0x49000400
10043020:	000001ff 	.word	0x000001ff

10043024 <HAL_MRSubG_IRQHandler>:
             the HAL_MRSubG_WKUP_Callback could be implemented in the user file
    */
}

void HAL_MRSubG_IRQHandler(void)
{
10043024:	b580      	push	{r7, lr}
10043026:	af00      	add	r7, sp, #0
  HAL_MRSubG_IRQ_Callback();
10043028:	f7fd fd92 	bl	10040b50 <HAL_MRSubG_IRQ_Callback>
}
1004302c:	46c0      	nop			@ (mov r8, r8)
1004302e:	46bd      	mov	sp, r7
10043030:	bd80      	pop	{r7, pc}
	...

10043034 <LL_PWR_SetNoPullB>:
  * @retval None
  * @note   Please refer the user manual to know which IOs are able for this
  *         feature.
  */
__STATIC_INLINE void LL_PWR_SetNoPullB(uint32_t IO)
{
10043034:	b580      	push	{r7, lr}
10043036:	b082      	sub	sp, #8
10043038:	af00      	add	r7, sp, #0
1004303a:	6078      	str	r0, [r7, #4]
  CLEAR_BIT(PWR->PUCRB, IO);
1004303c:	4b08      	ldr	r3, [pc, #32]	@ (10043060 <LL_PWR_SetNoPullB+0x2c>)
1004303e:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
10043040:	687b      	ldr	r3, [r7, #4]
10043042:	43d9      	mvns	r1, r3
10043044:	4b06      	ldr	r3, [pc, #24]	@ (10043060 <LL_PWR_SetNoPullB+0x2c>)
10043046:	400a      	ands	r2, r1
10043048:	629a      	str	r2, [r3, #40]	@ 0x28
  CLEAR_BIT(PWR->PDCRB, IO);
1004304a:	4b05      	ldr	r3, [pc, #20]	@ (10043060 <LL_PWR_SetNoPullB+0x2c>)
1004304c:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
1004304e:	687b      	ldr	r3, [r7, #4]
10043050:	43d9      	mvns	r1, r3
10043052:	4b03      	ldr	r3, [pc, #12]	@ (10043060 <LL_PWR_SetNoPullB+0x2c>)
10043054:	400a      	ands	r2, r1
10043056:	62da      	str	r2, [r3, #44]	@ 0x2c
}
10043058:	46c0      	nop			@ (mov r8, r8)
1004305a:	46bd      	mov	sp, r7
1004305c:	b002      	add	sp, #8
1004305e:	bd80      	pop	{r7, pc}
10043060:	48500000 	.word	0x48500000

10043064 <LL_RCC_HSE_Enable>:
  * @brief  Enable HSE crystal oscillator (HSE ON)
  * @rmtoll CR           HSEON         LL_RCC_HSE_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_HSE_Enable(void)
{
10043064:	b580      	push	{r7, lr}
10043066:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CR, RCC_CR_HSEON);
10043068:	4b04      	ldr	r3, [pc, #16]	@ (1004307c <LL_RCC_HSE_Enable+0x18>)
1004306a:	681a      	ldr	r2, [r3, #0]
1004306c:	4b03      	ldr	r3, [pc, #12]	@ (1004307c <LL_RCC_HSE_Enable+0x18>)
1004306e:	2180      	movs	r1, #128	@ 0x80
10043070:	0249      	lsls	r1, r1, #9
10043072:	430a      	orrs	r2, r1
10043074:	601a      	str	r2, [r3, #0]
}
10043076:	46c0      	nop			@ (mov r8, r8)
10043078:	46bd      	mov	sp, r7
1004307a:	bd80      	pop	{r7, pc}
1004307c:	48400000 	.word	0x48400000

10043080 <LL_RCC_HSE_Disable>:
  * @brief  Disable HSE crystal oscillator (HSE ON)
  * @rmtoll CR           HSEON         LL_RCC_HSE_Disable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_HSE_Disable(void)
{
10043080:	b580      	push	{r7, lr}
10043082:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CR, RCC_CR_HSEON);
10043084:	4b04      	ldr	r3, [pc, #16]	@ (10043098 <LL_RCC_HSE_Disable+0x18>)
10043086:	681a      	ldr	r2, [r3, #0]
10043088:	4b03      	ldr	r3, [pc, #12]	@ (10043098 <LL_RCC_HSE_Disable+0x18>)
1004308a:	4904      	ldr	r1, [pc, #16]	@ (1004309c <LL_RCC_HSE_Disable+0x1c>)
1004308c:	400a      	ands	r2, r1
1004308e:	601a      	str	r2, [r3, #0]
}
10043090:	46c0      	nop			@ (mov r8, r8)
10043092:	46bd      	mov	sp, r7
10043094:	bd80      	pop	{r7, pc}
10043096:	46c0      	nop			@ (mov r8, r8)
10043098:	48400000 	.word	0x48400000
1004309c:	fffeffff 	.word	0xfffeffff

100430a0 <LL_RCC_HSE_IsReady>:
  * @brief  Check if HSE oscillator Ready
  * @rmtoll CR           HSERDY        LL_RCC_HSE_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_HSE_IsReady(void)
{
100430a0:	b580      	push	{r7, lr}
100430a2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_HSERDY) == (RCC_CR_HSERDY)) ? 1UL : 0UL);
100430a4:	4b07      	ldr	r3, [pc, #28]	@ (100430c4 <LL_RCC_HSE_IsReady+0x24>)
100430a6:	681a      	ldr	r2, [r3, #0]
100430a8:	2380      	movs	r3, #128	@ 0x80
100430aa:	029b      	lsls	r3, r3, #10
100430ac:	401a      	ands	r2, r3
100430ae:	2380      	movs	r3, #128	@ 0x80
100430b0:	029b      	lsls	r3, r3, #10
100430b2:	429a      	cmp	r2, r3
100430b4:	d101      	bne.n	100430ba <LL_RCC_HSE_IsReady+0x1a>
100430b6:	2301      	movs	r3, #1
100430b8:	e000      	b.n	100430bc <LL_RCC_HSE_IsReady+0x1c>
100430ba:	2300      	movs	r3, #0
}
100430bc:	0018      	movs	r0, r3
100430be:	46bd      	mov	sp, r7
100430c0:	bd80      	pop	{r7, pc}
100430c2:	46c0      	nop			@ (mov r8, r8)
100430c4:	48400000 	.word	0x48400000

100430c8 <LL_RCC_HSE_SetCapacitorTuning>:
  * @rmtoll RFSWHSECR        SWXOTUNE       LL_RCC_HSE_SetCapacitorTuning
  * @param  Value Between Min_Data = 0 and Max_Data = 63
  * @retval None
  */
__STATIC_INLINE void LL_RCC_HSE_SetCapacitorTuning(uint32_t Value)
{
100430c8:	b580      	push	{r7, lr}
100430ca:	b082      	sub	sp, #8
100430cc:	af00      	add	r7, sp, #0
100430ce:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->RFSWHSECR, RCC_RFSWHSECR_SWXOTUNE, Value << RCC_RFSWHSECR_SWXOTUNE_Pos);
100430d0:	4a0b      	ldr	r2, [pc, #44]	@ (10043100 <LL_RCC_HSE_SetCapacitorTuning+0x38>)
100430d2:	2398      	movs	r3, #152	@ 0x98
100430d4:	58d3      	ldr	r3, [r2, r3]
100430d6:	4a0b      	ldr	r2, [pc, #44]	@ (10043104 <LL_RCC_HSE_SetCapacitorTuning+0x3c>)
100430d8:	401a      	ands	r2, r3
100430da:	687b      	ldr	r3, [r7, #4]
100430dc:	021b      	lsls	r3, r3, #8
100430de:	4908      	ldr	r1, [pc, #32]	@ (10043100 <LL_RCC_HSE_SetCapacitorTuning+0x38>)
100430e0:	4313      	orrs	r3, r2
100430e2:	2298      	movs	r2, #152	@ 0x98
100430e4:	508b      	str	r3, [r1, r2]
  SET_BIT(RCC->RFSWHSECR, RCC_RFSWHSECR_SWXOTUNEEN);
100430e6:	4a06      	ldr	r2, [pc, #24]	@ (10043100 <LL_RCC_HSE_SetCapacitorTuning+0x38>)
100430e8:	2398      	movs	r3, #152	@ 0x98
100430ea:	58d3      	ldr	r3, [r2, r3]
100430ec:	4904      	ldr	r1, [pc, #16]	@ (10043100 <LL_RCC_HSE_SetCapacitorTuning+0x38>)
100430ee:	2280      	movs	r2, #128	@ 0x80
100430f0:	4313      	orrs	r3, r2
100430f2:	2298      	movs	r2, #152	@ 0x98
100430f4:	508b      	str	r3, [r1, r2]
}
100430f6:	46c0      	nop			@ (mov r8, r8)
100430f8:	46bd      	mov	sp, r7
100430fa:	b002      	add	sp, #8
100430fc:	bd80      	pop	{r7, pc}
100430fe:	46c0      	nop			@ (mov r8, r8)
10043100:	48400000 	.word	0x48400000
10043104:	ffffc0ff 	.word	0xffffc0ff

10043108 <LL_RCC_HSE_SetCurrentControl>:
  *         Example GMC[6:0]=0b1111001=25*40uA
  * @rmtoll RFSWHSECR        GMC       LL_RCC_HSE_SetCurrentControl
  * @param  CurrentMax HSE current calculated with the previous formula
  */
__STATIC_INLINE void LL_RCC_HSE_SetCurrentControl(uint32_t CurrentMax)
{
10043108:	b580      	push	{r7, lr}
1004310a:	b082      	sub	sp, #8
1004310c:	af00      	add	r7, sp, #0
1004310e:	6078      	str	r0, [r7, #4]
  MODIFY_REG_FIELD(RCC->RFSWHSECR, RCC_RFSWHSECR_GMC, CurrentMax);
10043110:	4a08      	ldr	r2, [pc, #32]	@ (10043134 <LL_RCC_HSE_SetCurrentControl+0x2c>)
10043112:	2398      	movs	r3, #152	@ 0x98
10043114:	58d3      	ldr	r3, [r2, r3]
10043116:	227f      	movs	r2, #127	@ 0x7f
10043118:	4393      	bics	r3, r2
1004311a:	001a      	movs	r2, r3
1004311c:	687b      	ldr	r3, [r7, #4]
1004311e:	217f      	movs	r1, #127	@ 0x7f
10043120:	400b      	ands	r3, r1
10043122:	4904      	ldr	r1, [pc, #16]	@ (10043134 <LL_RCC_HSE_SetCurrentControl+0x2c>)
10043124:	4313      	orrs	r3, r2
10043126:	2298      	movs	r2, #152	@ 0x98
10043128:	508b      	str	r3, [r1, r2]
}
1004312a:	46c0      	nop			@ (mov r8, r8)
1004312c:	46bd      	mov	sp, r7
1004312e:	b002      	add	sp, #8
10043130:	bd80      	pop	{r7, pc}
10043132:	46c0      	nop			@ (mov r8, r8)
10043134:	48400000 	.word	0x48400000

10043138 <LL_RCC_HSE_SetStartupCurrent>:
  * @brief  Set HSE startup current
  * @rmtoll RFSWHSECR        ISTARTUP      LL_RCC_HSE_SetStartupCurrent
  * @param  StartupCurrent HSE startup current
  */
__STATIC_INLINE void LL_RCC_HSE_SetStartupCurrent(uint32_t StartupCurrent)
{
10043138:	b580      	push	{r7, lr}
1004313a:	b082      	sub	sp, #8
1004313c:	af00      	add	r7, sp, #0
1004313e:	6078      	str	r0, [r7, #4]
  MODIFY_REG_FIELD(RCC->RFSWHSECR, RCC_RFSWHSECR_ISTARTUP, StartupCurrent);
10043140:	4a08      	ldr	r2, [pc, #32]	@ (10043164 <LL_RCC_HSE_SetStartupCurrent+0x2c>)
10043142:	2398      	movs	r3, #152	@ 0x98
10043144:	58d3      	ldr	r3, [r2, r3]
10043146:	4a08      	ldr	r2, [pc, #32]	@ (10043168 <LL_RCC_HSE_SetStartupCurrent+0x30>)
10043148:	401a      	ands	r2, r3
1004314a:	687b      	ldr	r3, [r7, #4]
1004314c:	039b      	lsls	r3, r3, #14
1004314e:	041b      	lsls	r3, r3, #16
10043150:	0c1b      	lsrs	r3, r3, #16
10043152:	4904      	ldr	r1, [pc, #16]	@ (10043164 <LL_RCC_HSE_SetStartupCurrent+0x2c>)
10043154:	4313      	orrs	r3, r2
10043156:	2298      	movs	r2, #152	@ 0x98
10043158:	508b      	str	r3, [r1, r2]
}
1004315a:	46c0      	nop			@ (mov r8, r8)
1004315c:	46bd      	mov	sp, r7
1004315e:	b002      	add	sp, #8
10043160:	bd80      	pop	{r7, pc}
10043162:	46c0      	nop			@ (mov r8, r8)
10043164:	48400000 	.word	0x48400000
10043168:	ffff3fff 	.word	0xffff3fff

1004316c <LL_RCC_HSE_SetAmplitudeThreshold>:
  * @brief  Set HSE Amplitude Control threshold
  * @rmtoll RFSWHSECR        AMPLTHRESH      LL_RCC_HSE_SetAmplitudeThreshold
  * @param  AmplThr HSE Amplitude Control threshold
  */
__STATIC_INLINE void LL_RCC_HSE_SetAmplitudeThreshold(uint32_t AmplThr)
{
1004316c:	b580      	push	{r7, lr}
1004316e:	b082      	sub	sp, #8
10043170:	af00      	add	r7, sp, #0
10043172:	6078      	str	r0, [r7, #4]
  MODIFY_REG_FIELD(RCC->RFSWHSECR, RCC_RFSWHSECR_AMPLTHRESH, AmplThr);
10043174:	4a08      	ldr	r2, [pc, #32]	@ (10043198 <LL_RCC_HSE_SetAmplitudeThreshold+0x2c>)
10043176:	2398      	movs	r3, #152	@ 0x98
10043178:	58d3      	ldr	r3, [r2, r3]
1004317a:	4a08      	ldr	r2, [pc, #32]	@ (1004319c <LL_RCC_HSE_SetAmplitudeThreshold+0x30>)
1004317c:	401a      	ands	r2, r3
1004317e:	687b      	ldr	r3, [r7, #4]
10043180:	0419      	lsls	r1, r3, #16
10043182:	23e0      	movs	r3, #224	@ 0xe0
10043184:	02db      	lsls	r3, r3, #11
10043186:	400b      	ands	r3, r1
10043188:	4903      	ldr	r1, [pc, #12]	@ (10043198 <LL_RCC_HSE_SetAmplitudeThreshold+0x2c>)
1004318a:	4313      	orrs	r3, r2
1004318c:	2298      	movs	r2, #152	@ 0x98
1004318e:	508b      	str	r3, [r1, r2]
}
10043190:	46c0      	nop			@ (mov r8, r8)
10043192:	46bd      	mov	sp, r7
10043194:	b002      	add	sp, #8
10043196:	bd80      	pop	{r7, pc}
10043198:	48400000 	.word	0x48400000
1004319c:	fff8ffff 	.word	0xfff8ffff

100431a0 <LL_RCC_HSI_Enable>:
  * @brief  Enable HSI
  * @rmtoll CFGR           STOPHSI        LL_RCC_HSI_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_HSI_Enable(void)
{
100431a0:	b580      	push	{r7, lr}
100431a2:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CFGR, RCC_CFGR_STOPHSI);
100431a4:	4b07      	ldr	r3, [pc, #28]	@ (100431c4 <LL_RCC_HSI_Enable+0x24>)
100431a6:	689a      	ldr	r2, [r3, #8]
100431a8:	4b06      	ldr	r3, [pc, #24]	@ (100431c4 <LL_RCC_HSI_Enable+0x24>)
100431aa:	2104      	movs	r1, #4
100431ac:	438a      	bics	r2, r1
100431ae:	609a      	str	r2, [r3, #8]
  CLEAR_BIT(RCC->CFGR, RCC_CFGR_HSESEL);
100431b0:	4b04      	ldr	r3, [pc, #16]	@ (100431c4 <LL_RCC_HSI_Enable+0x24>)
100431b2:	689a      	ldr	r2, [r3, #8]
100431b4:	4b03      	ldr	r3, [pc, #12]	@ (100431c4 <LL_RCC_HSI_Enable+0x24>)
100431b6:	2102      	movs	r1, #2
100431b8:	438a      	bics	r2, r1
100431ba:	609a      	str	r2, [r3, #8]
}
100431bc:	46c0      	nop			@ (mov r8, r8)
100431be:	46bd      	mov	sp, r7
100431c0:	bd80      	pop	{r7, pc}
100431c2:	46c0      	nop			@ (mov r8, r8)
100431c4:	48400000 	.word	0x48400000

100431c8 <LL_RCC_HSI_Disable>:
  * @brief  Disable HSI
  * @rmtoll CFGR           STOPHSI        LL_RCC_HSI_Disable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_HSI_Disable(void)
{
100431c8:	b580      	push	{r7, lr}
100431ca:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CFGR, RCC_CFGR_HSESEL);
100431cc:	4b07      	ldr	r3, [pc, #28]	@ (100431ec <LL_RCC_HSI_Disable+0x24>)
100431ce:	689a      	ldr	r2, [r3, #8]
100431d0:	4b06      	ldr	r3, [pc, #24]	@ (100431ec <LL_RCC_HSI_Disable+0x24>)
100431d2:	2102      	movs	r1, #2
100431d4:	430a      	orrs	r2, r1
100431d6:	609a      	str	r2, [r3, #8]
  SET_BIT(RCC->CFGR, RCC_CFGR_STOPHSI);
100431d8:	4b04      	ldr	r3, [pc, #16]	@ (100431ec <LL_RCC_HSI_Disable+0x24>)
100431da:	689a      	ldr	r2, [r3, #8]
100431dc:	4b03      	ldr	r3, [pc, #12]	@ (100431ec <LL_RCC_HSI_Disable+0x24>)
100431de:	2104      	movs	r1, #4
100431e0:	430a      	orrs	r2, r1
100431e2:	609a      	str	r2, [r3, #8]
}
100431e4:	46c0      	nop			@ (mov r8, r8)
100431e6:	46bd      	mov	sp, r7
100431e8:	bd80      	pop	{r7, pc}
100431ea:	46c0      	nop			@ (mov r8, r8)
100431ec:	48400000 	.word	0x48400000

100431f0 <LL_RCC_HSI_IsReady>:
  * @brief  Check if HSI clock is ready
  * @rmtoll CR           HSIRDY        LL_RCC_HSI_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_HSI_IsReady(void)
{
100431f0:	b580      	push	{r7, lr}
100431f2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_HSIRDY) == (RCC_CR_HSIRDY)) ? 1UL : 0UL);
100431f4:	4b07      	ldr	r3, [pc, #28]	@ (10043214 <LL_RCC_HSI_IsReady+0x24>)
100431f6:	681a      	ldr	r2, [r3, #0]
100431f8:	2380      	movs	r3, #128	@ 0x80
100431fa:	00db      	lsls	r3, r3, #3
100431fc:	401a      	ands	r2, r3
100431fe:	2380      	movs	r3, #128	@ 0x80
10043200:	00db      	lsls	r3, r3, #3
10043202:	429a      	cmp	r2, r3
10043204:	d101      	bne.n	1004320a <LL_RCC_HSI_IsReady+0x1a>
10043206:	2301      	movs	r3, #1
10043208:	e000      	b.n	1004320c <LL_RCC_HSI_IsReady+0x1c>
1004320a:	2300      	movs	r3, #0
}
1004320c:	0018      	movs	r0, r3
1004320e:	46bd      	mov	sp, r7
10043210:	bd80      	pop	{r7, pc}
10043212:	46c0      	nop			@ (mov r8, r8)
10043214:	48400000 	.word	0x48400000

10043218 <LL_RCC_DIRECT_HSE_Enable>:
  * @brief  Enable DIRECT_HSE mode
  * @rmtoll CFGR       HSESEL/STOPHSI         LL_RCC_HSE_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_DIRECT_HSE_Enable(void)
{
10043218:	b580      	push	{r7, lr}
1004321a:	b082      	sub	sp, #8
1004321c:	af00      	add	r7, sp, #0
  while (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0);
1004321e:	46c0      	nop			@ (mov r8, r8)
10043220:	4b0f      	ldr	r3, [pc, #60]	@ (10043260 <LL_RCC_DIRECT_HSE_Enable+0x48>)
10043222:	681a      	ldr	r2, [r3, #0]
10043224:	2380      	movs	r3, #128	@ 0x80
10043226:	029b      	lsls	r3, r3, #10
10043228:	4013      	ands	r3, r2
1004322a:	d0f9      	beq.n	10043220 <LL_RCC_DIRECT_HSE_Enable+0x8>
  SET_BIT(RCC->CFGR, RCC_CFGR_HSESEL);
1004322c:	4b0c      	ldr	r3, [pc, #48]	@ (10043260 <LL_RCC_DIRECT_HSE_Enable+0x48>)
1004322e:	689a      	ldr	r2, [r3, #8]
10043230:	4b0b      	ldr	r3, [pc, #44]	@ (10043260 <LL_RCC_DIRECT_HSE_Enable+0x48>)
10043232:	2102      	movs	r1, #2
10043234:	430a      	orrs	r2, r1
10043236:	609a      	str	r2, [r3, #8]
  for (volatile int i = 0; i < 6; i++)
10043238:	2300      	movs	r3, #0
1004323a:	607b      	str	r3, [r7, #4]
1004323c:	e003      	b.n	10043246 <LL_RCC_DIRECT_HSE_Enable+0x2e>
  {
    __asm("NOP");
1004323e:	46c0      	nop			@ (mov r8, r8)
  for (volatile int i = 0; i < 6; i++)
10043240:	687b      	ldr	r3, [r7, #4]
10043242:	3301      	adds	r3, #1
10043244:	607b      	str	r3, [r7, #4]
10043246:	687b      	ldr	r3, [r7, #4]
10043248:	2b05      	cmp	r3, #5
1004324a:	ddf8      	ble.n	1004323e <LL_RCC_DIRECT_HSE_Enable+0x26>
  }
  SET_BIT(RCC->CFGR, RCC_CFGR_STOPHSI);
1004324c:	4b04      	ldr	r3, [pc, #16]	@ (10043260 <LL_RCC_DIRECT_HSE_Enable+0x48>)
1004324e:	689a      	ldr	r2, [r3, #8]
10043250:	4b03      	ldr	r3, [pc, #12]	@ (10043260 <LL_RCC_DIRECT_HSE_Enable+0x48>)
10043252:	2104      	movs	r1, #4
10043254:	430a      	orrs	r2, r1
10043256:	609a      	str	r2, [r3, #8]
}
10043258:	46c0      	nop			@ (mov r8, r8)
1004325a:	46bd      	mov	sp, r7
1004325c:	b002      	add	sp, #8
1004325e:	bd80      	pop	{r7, pc}
10043260:	48400000 	.word	0x48400000

10043264 <LL_RCC_LSCO_SetSource>:
  *         @arg @ref LL_RCC_LSCO_CLKSOURCE_LSI
  *         @arg @ref LL_RCC_LSCO_CLKSOURCE_HSI64M_DIV2048
  * @retval None
  */
__STATIC_INLINE void LL_RCC_LSCO_SetSource(uint32_t Source)
{
10043264:	b580      	push	{r7, lr}
10043266:	b082      	sub	sp, #8
10043268:	af00      	add	r7, sp, #0
1004326a:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_CLKSLOWSEL, Source);
1004326c:	4b06      	ldr	r3, [pc, #24]	@ (10043288 <LL_RCC_LSCO_SetSource+0x24>)
1004326e:	689b      	ldr	r3, [r3, #8]
10043270:	4a06      	ldr	r2, [pc, #24]	@ (1004328c <LL_RCC_LSCO_SetSource+0x28>)
10043272:	4013      	ands	r3, r2
10043274:	0019      	movs	r1, r3
10043276:	4b04      	ldr	r3, [pc, #16]	@ (10043288 <LL_RCC_LSCO_SetSource+0x24>)
10043278:	687a      	ldr	r2, [r7, #4]
1004327a:	430a      	orrs	r2, r1
1004327c:	609a      	str	r2, [r3, #8]
}
1004327e:	46c0      	nop			@ (mov r8, r8)
10043280:	46bd      	mov	sp, r7
10043282:	b002      	add	sp, #8
10043284:	bd80      	pop	{r7, pc}
10043286:	46c0      	nop			@ (mov r8, r8)
10043288:	48400000 	.word	0x48400000
1004328c:	fffe7fff 	.word	0xfffe7fff

10043290 <LL_RCC_LSE_Enable>:
  * @brief  Enable  Low Speed External (LSE) crystal.
  * @rmtoll CR         LSEON         LL_RCC_LSE_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_LSE_Enable(void)
{
10043290:	b580      	push	{r7, lr}
10043292:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CR, RCC_CR_LSEON);
10043294:	4b04      	ldr	r3, [pc, #16]	@ (100432a8 <LL_RCC_LSE_Enable+0x18>)
10043296:	681a      	ldr	r2, [r3, #0]
10043298:	4b03      	ldr	r3, [pc, #12]	@ (100432a8 <LL_RCC_LSE_Enable+0x18>)
1004329a:	2110      	movs	r1, #16
1004329c:	430a      	orrs	r2, r1
1004329e:	601a      	str	r2, [r3, #0]
}
100432a0:	46c0      	nop			@ (mov r8, r8)
100432a2:	46bd      	mov	sp, r7
100432a4:	bd80      	pop	{r7, pc}
100432a6:	46c0      	nop			@ (mov r8, r8)
100432a8:	48400000 	.word	0x48400000

100432ac <LL_RCC_LSE_Disable>:
  * @brief  Disable  Low Speed External (LSE) crystal.
  * @rmtoll CR         LSEON         LL_RCC_LSE_Disable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_LSE_Disable(void)
{
100432ac:	b580      	push	{r7, lr}
100432ae:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CR, RCC_CR_LSEON);
100432b0:	4b04      	ldr	r3, [pc, #16]	@ (100432c4 <LL_RCC_LSE_Disable+0x18>)
100432b2:	681a      	ldr	r2, [r3, #0]
100432b4:	4b03      	ldr	r3, [pc, #12]	@ (100432c4 <LL_RCC_LSE_Disable+0x18>)
100432b6:	2110      	movs	r1, #16
100432b8:	438a      	bics	r2, r1
100432ba:	601a      	str	r2, [r3, #0]
}
100432bc:	46c0      	nop			@ (mov r8, r8)
100432be:	46bd      	mov	sp, r7
100432c0:	bd80      	pop	{r7, pc}
100432c2:	46c0      	nop			@ (mov r8, r8)
100432c4:	48400000 	.word	0x48400000

100432c8 <LL_RCC_LSE_IsReady>:
  * @brief  Check if LSE oscillator Ready
  * @rmtoll CR         LSERDY        LL_RCC_LSE_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_LSE_IsReady(void)
{
100432c8:	b580      	push	{r7, lr}
100432ca:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_LSERDY) == (RCC_CR_LSERDY)) ? 1UL : 0UL);
100432cc:	4b05      	ldr	r3, [pc, #20]	@ (100432e4 <LL_RCC_LSE_IsReady+0x1c>)
100432ce:	681b      	ldr	r3, [r3, #0]
100432d0:	2220      	movs	r2, #32
100432d2:	4013      	ands	r3, r2
100432d4:	2b20      	cmp	r3, #32
100432d6:	d101      	bne.n	100432dc <LL_RCC_LSE_IsReady+0x14>
100432d8:	2301      	movs	r3, #1
100432da:	e000      	b.n	100432de <LL_RCC_LSE_IsReady+0x16>
100432dc:	2300      	movs	r3, #0
}
100432de:	0018      	movs	r0, r3
100432e0:	46bd      	mov	sp, r7
100432e2:	bd80      	pop	{r7, pc}
100432e4:	48400000 	.word	0x48400000

100432e8 <LL_RCC_LSE_EnableBypass>:
  * @brief  Enable external clock source (LSE bypass).
  * @rmtoll CR         LSEBYP        LL_RCC_LSE_EnableBypass
  * @retval None
  */
__STATIC_INLINE void LL_RCC_LSE_EnableBypass(void)
{
100432e8:	b580      	push	{r7, lr}
100432ea:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CR, RCC_CR_LSEBYP);
100432ec:	4b04      	ldr	r3, [pc, #16]	@ (10043300 <LL_RCC_LSE_EnableBypass+0x18>)
100432ee:	681a      	ldr	r2, [r3, #0]
100432f0:	4b03      	ldr	r3, [pc, #12]	@ (10043300 <LL_RCC_LSE_EnableBypass+0x18>)
100432f2:	2140      	movs	r1, #64	@ 0x40
100432f4:	430a      	orrs	r2, r1
100432f6:	601a      	str	r2, [r3, #0]
}
100432f8:	46c0      	nop			@ (mov r8, r8)
100432fa:	46bd      	mov	sp, r7
100432fc:	bd80      	pop	{r7, pc}
100432fe:	46c0      	nop			@ (mov r8, r8)
10043300:	48400000 	.word	0x48400000

10043304 <LL_RCC_LSE_DisableBypass>:
  * @brief  Disable external clock source (LSE bypass).
  * @rmtoll CR         LSEBYP        LL_RCC_LSE_DisableBypass
  * @retval None
  */
__STATIC_INLINE void LL_RCC_LSE_DisableBypass(void)
{
10043304:	b580      	push	{r7, lr}
10043306:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CR, RCC_CR_LSEBYP);
10043308:	4b04      	ldr	r3, [pc, #16]	@ (1004331c <LL_RCC_LSE_DisableBypass+0x18>)
1004330a:	681a      	ldr	r2, [r3, #0]
1004330c:	4b03      	ldr	r3, [pc, #12]	@ (1004331c <LL_RCC_LSE_DisableBypass+0x18>)
1004330e:	2140      	movs	r1, #64	@ 0x40
10043310:	438a      	bics	r2, r1
10043312:	601a      	str	r2, [r3, #0]
}
10043314:	46c0      	nop			@ (mov r8, r8)
10043316:	46bd      	mov	sp, r7
10043318:	bd80      	pop	{r7, pc}
1004331a:	46c0      	nop			@ (mov r8, r8)
1004331c:	48400000 	.word	0x48400000

10043320 <LL_RCC_LSE_IsBypassEnabled>:
  * @brief  Check if LSE bypass configuration is enabled.
  * @rmtoll CR         LSEBYP        LL_RCC_LSE_IsBypassEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_LSE_IsBypassEnabled(void)
{
10043320:	b580      	push	{r7, lr}
10043322:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_LSEBYP) == (RCC_CR_LSEBYP)) ? 1UL : 0UL);
10043324:	4b05      	ldr	r3, [pc, #20]	@ (1004333c <LL_RCC_LSE_IsBypassEnabled+0x1c>)
10043326:	681b      	ldr	r3, [r3, #0]
10043328:	2240      	movs	r2, #64	@ 0x40
1004332a:	4013      	ands	r3, r2
1004332c:	2b40      	cmp	r3, #64	@ 0x40
1004332e:	d101      	bne.n	10043334 <LL_RCC_LSE_IsBypassEnabled+0x14>
10043330:	2301      	movs	r3, #1
10043332:	e000      	b.n	10043336 <LL_RCC_LSE_IsBypassEnabled+0x16>
10043334:	2300      	movs	r3, #0
}
10043336:	0018      	movs	r0, r3
10043338:	46bd      	mov	sp, r7
1004333a:	bd80      	pop	{r7, pc}
1004333c:	48400000 	.word	0x48400000

10043340 <LL_RCC_LSE_SetDriveCapability>:
  *         @arg @ref LL_RCC_LSEDRIVE_MEDIUMHIGH
  *         @arg @ref LL_RCC_LSEDRIVE_HIGH
  * @retval None
  */
__STATIC_INLINE void LL_RCC_LSE_SetDriveCapability(uint32_t LSEDrive)
{
10043340:	b580      	push	{r7, lr}
10043342:	b082      	sub	sp, #8
10043344:	af00      	add	r7, sp, #0
10043346:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CSSWCR, RCC_CSSWCR_LSEDRV, LSEDrive);
10043348:	4b06      	ldr	r3, [pc, #24]	@ (10043364 <LL_RCC_LSE_SetDriveCapability+0x24>)
1004334a:	68db      	ldr	r3, [r3, #12]
1004334c:	2260      	movs	r2, #96	@ 0x60
1004334e:	4393      	bics	r3, r2
10043350:	0019      	movs	r1, r3
10043352:	4b04      	ldr	r3, [pc, #16]	@ (10043364 <LL_RCC_LSE_SetDriveCapability+0x24>)
10043354:	687a      	ldr	r2, [r7, #4]
10043356:	430a      	orrs	r2, r1
10043358:	60da      	str	r2, [r3, #12]
}
1004335a:	46c0      	nop			@ (mov r8, r8)
1004335c:	46bd      	mov	sp, r7
1004335e:	b002      	add	sp, #8
10043360:	bd80      	pop	{r7, pc}
10043362:	46c0      	nop			@ (mov r8, r8)
10043364:	48400000 	.word	0x48400000

10043368 <LL_RCC_LSI_Enable>:
  * @brief  Enable LSI Oscillator
  * @rmtoll CR          LSION         LL_RCC_LSI_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_LSI_Enable(void)
{
10043368:	b580      	push	{r7, lr}
1004336a:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CR, RCC_CR_LSION);
1004336c:	4b04      	ldr	r3, [pc, #16]	@ (10043380 <LL_RCC_LSI_Enable+0x18>)
1004336e:	681a      	ldr	r2, [r3, #0]
10043370:	4b03      	ldr	r3, [pc, #12]	@ (10043380 <LL_RCC_LSI_Enable+0x18>)
10043372:	2104      	movs	r1, #4
10043374:	430a      	orrs	r2, r1
10043376:	601a      	str	r2, [r3, #0]
}
10043378:	46c0      	nop			@ (mov r8, r8)
1004337a:	46bd      	mov	sp, r7
1004337c:	bd80      	pop	{r7, pc}
1004337e:	46c0      	nop			@ (mov r8, r8)
10043380:	48400000 	.word	0x48400000

10043384 <LL_RCC_LSI_Disable>:
  * @brief  Disable LSI Oscillator
  * @rmtoll CR          LSION         LL_RCC_LSI_Disable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_LSI_Disable(void)
{
10043384:	b580      	push	{r7, lr}
10043386:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CR, RCC_CR_LSION);
10043388:	4b04      	ldr	r3, [pc, #16]	@ (1004339c <LL_RCC_LSI_Disable+0x18>)
1004338a:	681a      	ldr	r2, [r3, #0]
1004338c:	4b03      	ldr	r3, [pc, #12]	@ (1004339c <LL_RCC_LSI_Disable+0x18>)
1004338e:	2104      	movs	r1, #4
10043390:	438a      	bics	r2, r1
10043392:	601a      	str	r2, [r3, #0]
}
10043394:	46c0      	nop			@ (mov r8, r8)
10043396:	46bd      	mov	sp, r7
10043398:	bd80      	pop	{r7, pc}
1004339a:	46c0      	nop			@ (mov r8, r8)
1004339c:	48400000 	.word	0x48400000

100433a0 <LL_RCC_LSI_IsReady>:
  * @brief  Check if LSI is Ready
  * @rmtoll CR          LSIRDY        LL_RCC_LSI_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_LSI_IsReady(void)
{
100433a0:	b580      	push	{r7, lr}
100433a2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_LSIRDY) == (RCC_CR_LSIRDY)) ? 1UL : 0UL);
100433a4:	4b05      	ldr	r3, [pc, #20]	@ (100433bc <LL_RCC_LSI_IsReady+0x1c>)
100433a6:	681b      	ldr	r3, [r3, #0]
100433a8:	2208      	movs	r2, #8
100433aa:	4013      	ands	r3, r2
100433ac:	2b08      	cmp	r3, #8
100433ae:	d101      	bne.n	100433b4 <LL_RCC_LSI_IsReady+0x14>
100433b0:	2301      	movs	r3, #1
100433b2:	e000      	b.n	100433b6 <LL_RCC_LSI_IsReady+0x16>
100433b4:	2300      	movs	r3, #0
}
100433b6:	0018      	movs	r0, r3
100433b8:	46bd      	mov	sp, r7
100433ba:	bd80      	pop	{r7, pc}
100433bc:	48400000 	.word	0x48400000

100433c0 <LL_RCC_RC64MPLL_Enable>:
  * @brief  Enable RC64MPLL
  * @rmtoll CR           HSIPLLON         LL_RCC_RC64MPLL_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_RC64MPLL_Enable(void)
{
100433c0:	b580      	push	{r7, lr}
100433c2:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CR, RCC_CR_HSIPLLON);
100433c4:	4b04      	ldr	r3, [pc, #16]	@ (100433d8 <LL_RCC_RC64MPLL_Enable+0x18>)
100433c6:	681a      	ldr	r2, [r3, #0]
100433c8:	4b03      	ldr	r3, [pc, #12]	@ (100433d8 <LL_RCC_RC64MPLL_Enable+0x18>)
100433ca:	2180      	movs	r1, #128	@ 0x80
100433cc:	0189      	lsls	r1, r1, #6
100433ce:	430a      	orrs	r2, r1
100433d0:	601a      	str	r2, [r3, #0]
}
100433d2:	46c0      	nop			@ (mov r8, r8)
100433d4:	46bd      	mov	sp, r7
100433d6:	bd80      	pop	{r7, pc}
100433d8:	48400000 	.word	0x48400000

100433dc <LL_RCC_RC64MPLL_Disable>:
  * @note Cannot be disabled if the RC64MPLL clock is used as the system clock
  * @rmtoll CR           HSIPLLON         LL_RCC_RC64MPLL_Disable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_RC64MPLL_Disable(void)
{
100433dc:	b580      	push	{r7, lr}
100433de:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CR, RCC_CR_HSIPLLON);
100433e0:	4b04      	ldr	r3, [pc, #16]	@ (100433f4 <LL_RCC_RC64MPLL_Disable+0x18>)
100433e2:	681a      	ldr	r2, [r3, #0]
100433e4:	4b03      	ldr	r3, [pc, #12]	@ (100433f4 <LL_RCC_RC64MPLL_Disable+0x18>)
100433e6:	4904      	ldr	r1, [pc, #16]	@ (100433f8 <LL_RCC_RC64MPLL_Disable+0x1c>)
100433e8:	400a      	ands	r2, r1
100433ea:	601a      	str	r2, [r3, #0]
}
100433ec:	46c0      	nop			@ (mov r8, r8)
100433ee:	46bd      	mov	sp, r7
100433f0:	bd80      	pop	{r7, pc}
100433f2:	46c0      	nop			@ (mov r8, r8)
100433f4:	48400000 	.word	0x48400000
100433f8:	ffffdfff 	.word	0xffffdfff

100433fc <LL_RCC_RC64MPLL_IsReady>:
  * @brief  Check if RC64MPLL is Ready
  * @rmtoll CR           HSIPLLRDY        LL_RCC_RC64MPLL_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_RC64MPLL_IsReady(void)
{
100433fc:	b580      	push	{r7, lr}
100433fe:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_HSIPLLRDY) == (RCC_CR_HSIPLLRDY)) ? 1UL : 0UL);
10043400:	4b07      	ldr	r3, [pc, #28]	@ (10043420 <LL_RCC_RC64MPLL_IsReady+0x24>)
10043402:	681a      	ldr	r2, [r3, #0]
10043404:	2380      	movs	r3, #128	@ 0x80
10043406:	01db      	lsls	r3, r3, #7
10043408:	401a      	ands	r2, r3
1004340a:	2380      	movs	r3, #128	@ 0x80
1004340c:	01db      	lsls	r3, r3, #7
1004340e:	429a      	cmp	r2, r3
10043410:	d101      	bne.n	10043416 <LL_RCC_RC64MPLL_IsReady+0x1a>
10043412:	2301      	movs	r3, #1
10043414:	e000      	b.n	10043418 <LL_RCC_RC64MPLL_IsReady+0x1c>
10043416:	2300      	movs	r3, #0
}
10043418:	0018      	movs	r0, r3
1004341a:	46bd      	mov	sp, r7
1004341c:	bd80      	pop	{r7, pc}
1004341e:	46c0      	nop			@ (mov r8, r8)
10043420:	48400000 	.word	0x48400000

10043424 <LL_RCC_SetRC64MPLLPrescaler>:
  *         @arg @ref LL_RCC_RC64MPLL_DIV_32
  *         @arg @ref LL_RCC_RC64MPLL_DIV_64
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetRC64MPLLPrescaler(uint32_t Prescaler)
{
10043424:	b580      	push	{r7, lr}
10043426:	b082      	sub	sp, #8
10043428:	af00      	add	r7, sp, #0
1004342a:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_CLKSYSDIV, Prescaler);
1004342c:	4b06      	ldr	r3, [pc, #24]	@ (10043448 <LL_RCC_SetRC64MPLLPrescaler+0x24>)
1004342e:	689b      	ldr	r3, [r3, #8]
10043430:	22e0      	movs	r2, #224	@ 0xe0
10043432:	4393      	bics	r3, r2
10043434:	0019      	movs	r1, r3
10043436:	4b04      	ldr	r3, [pc, #16]	@ (10043448 <LL_RCC_SetRC64MPLLPrescaler+0x24>)
10043438:	687a      	ldr	r2, [r7, #4]
1004343a:	430a      	orrs	r2, r1
1004343c:	609a      	str	r2, [r3, #8]
}
1004343e:	46c0      	nop			@ (mov r8, r8)
10043440:	46bd      	mov	sp, r7
10043442:	b002      	add	sp, #8
10043444:	bd80      	pop	{r7, pc}
10043446:	46c0      	nop			@ (mov r8, r8)
10043448:	48400000 	.word	0x48400000

1004344c <HAL_RCC_OscConfig>:
  * @param  RCC_OscInitStruct  pointer to a @ref RCC_OscInitTypeDef structure that
  *         contains the configuration information for the RCC Oscillators.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
1004344c:	b580      	push	{r7, lr}
1004344e:	b084      	sub	sp, #16
10043450:	af00      	add	r7, sp, #0
10043452:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Check Null pointer */
  if (RCC_OscInitStruct == NULL)
10043454:	687b      	ldr	r3, [r7, #4]
10043456:	2b00      	cmp	r3, #0
10043458:	d101      	bne.n	1004345e <HAL_RCC_OscConfig+0x12>
  {
    return HAL_ERROR;
1004345a:	2301      	movs	r3, #1
1004345c:	e146      	b.n	100436ec <HAL_RCC_OscConfig+0x2a0>

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*------------------------------- HSI Configuration ------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
1004345e:	687b      	ldr	r3, [r7, #4]
10043460:	681b      	ldr	r3, [r3, #0]
10043462:	2210      	movs	r2, #16
10043464:	4013      	ands	r3, r2
10043466:	d033      	beq.n	100434d0 <HAL_RCC_OscConfig+0x84>
  {
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);
10043468:	687b      	ldr	r3, [r7, #4]
1004346a:	689b      	ldr	r3, [r3, #8]
1004346c:	2b00      	cmp	r3, #0
1004346e:	d102      	bne.n	10043476 <HAL_RCC_OscConfig+0x2a>
10043470:	f7ff fe96 	bl	100431a0 <LL_RCC_HSI_Enable>
10043474:	e001      	b.n	1004347a <HAL_RCC_OscConfig+0x2e>
10043476:	f7ff fea7 	bl	100431c8 <LL_RCC_HSI_Disable>

    if(RCC_OscInitStruct->HSIState == RCC_HSI_OFF)
1004347a:	687b      	ldr	r3, [r7, #4]
1004347c:	689b      	ldr	r3, [r3, #8]
1004347e:	2b04      	cmp	r3, #4
10043480:	d113      	bne.n	100434aa <HAL_RCC_OscConfig+0x5e>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
10043482:	f7fe f891 	bl	100415a8 <HAL_GetTick>
10043486:	0003      	movs	r3, r0
10043488:	60fb      	str	r3, [r7, #12]

      /* Wait till HSI is disabled */
      while (LL_RCC_HSI_IsReady() == 1U)
1004348a:	e008      	b.n	1004349e <HAL_RCC_OscConfig+0x52>
      {
        if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
1004348c:	f7fe f88c 	bl	100415a8 <HAL_GetTick>
10043490:	0002      	movs	r2, r0
10043492:	68fb      	ldr	r3, [r7, #12]
10043494:	1ad3      	subs	r3, r2, r3
10043496:	2b64      	cmp	r3, #100	@ 0x64
10043498:	d901      	bls.n	1004349e <HAL_RCC_OscConfig+0x52>
        {
          return HAL_TIMEOUT;
1004349a:	2303      	movs	r3, #3
1004349c:	e126      	b.n	100436ec <HAL_RCC_OscConfig+0x2a0>
      while (LL_RCC_HSI_IsReady() == 1U)
1004349e:	f7ff fea7 	bl	100431f0 <LL_RCC_HSI_IsReady>
100434a2:	0003      	movs	r3, r0
100434a4:	2b01      	cmp	r3, #1
100434a6:	d0f1      	beq.n	1004348c <HAL_RCC_OscConfig+0x40>
100434a8:	e012      	b.n	100434d0 <HAL_RCC_OscConfig+0x84>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
100434aa:	f7fe f87d 	bl	100415a8 <HAL_GetTick>
100434ae:	0003      	movs	r3, r0
100434b0:	60fb      	str	r3, [r7, #12]

      /* Wait till HSI is enabled */
      while (LL_RCC_HSI_IsReady() != 1U)
100434b2:	e008      	b.n	100434c6 <HAL_RCC_OscConfig+0x7a>
      {
        if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
100434b4:	f7fe f878 	bl	100415a8 <HAL_GetTick>
100434b8:	0002      	movs	r2, r0
100434ba:	68fb      	ldr	r3, [r7, #12]
100434bc:	1ad3      	subs	r3, r2, r3
100434be:	2b64      	cmp	r3, #100	@ 0x64
100434c0:	d901      	bls.n	100434c6 <HAL_RCC_OscConfig+0x7a>
        {
          return HAL_TIMEOUT;
100434c2:	2303      	movs	r3, #3
100434c4:	e112      	b.n	100436ec <HAL_RCC_OscConfig+0x2a0>
      while (LL_RCC_HSI_IsReady() != 1U)
100434c6:	f7ff fe93 	bl	100431f0 <LL_RCC_HSI_IsReady>
100434ca:	0003      	movs	r3, r0
100434cc:	2b01      	cmp	r3, #1
100434ce:	d1f1      	bne.n	100434b4 <HAL_RCC_OscConfig+0x68>
      }
    }
  }

  /*------------------------------- HSE Configuration ------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
100434d0:	687b      	ldr	r3, [r7, #4]
100434d2:	681b      	ldr	r3, [r3, #0]
100434d4:	2201      	movs	r2, #1
100434d6:	4013      	ands	r3, r2
100434d8:	d03f      	beq.n	1004355a <HAL_RCC_OscConfig+0x10e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    /* Set HSE Capacitor Tuning */
    LL_RCC_HSE_SetCapacitorTuning(CFG_HW_RCC_HSE_CAPACITOR_TUNE);
100434da:	2020      	movs	r0, #32
100434dc:	f7ff fdf4 	bl	100430c8 <LL_RCC_HSE_SetCapacitorTuning>

    /* Set HSE startup Current */
    LL_RCC_HSE_SetStartupCurrent(0);
100434e0:	2000      	movs	r0, #0
100434e2:	f7ff fe29 	bl	10043138 <LL_RCC_HSE_SetStartupCurrent>

    /*  Set HSE Amplitude Threshold */
    LL_RCC_HSE_SetAmplitudeThreshold(0);
100434e6:	2000      	movs	r0, #0
100434e8:	f7ff fe40 	bl	1004316c <LL_RCC_HSE_SetAmplitudeThreshold>

    /* Set HSE Current Control */
    LL_RCC_HSE_SetCurrentControl(40);
100434ec:	2028      	movs	r0, #40	@ 0x28
100434ee:	f7ff fe0b 	bl	10043108 <LL_RCC_HSE_SetCurrentControl>

    /* Set the new HSE configuration ---------------------------------------*/
    __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
100434f2:	687b      	ldr	r3, [r7, #4]
100434f4:	685a      	ldr	r2, [r3, #4]
100434f6:	2380      	movs	r3, #128	@ 0x80
100434f8:	025b      	lsls	r3, r3, #9
100434fa:	429a      	cmp	r2, r3
100434fc:	d102      	bne.n	10043504 <HAL_RCC_OscConfig+0xb8>
100434fe:	f7ff fdb1 	bl	10043064 <LL_RCC_HSE_Enable>
10043502:	e001      	b.n	10043508 <HAL_RCC_OscConfig+0xbc>
10043504:	f7ff fdbc 	bl	10043080 <LL_RCC_HSE_Disable>

    /* Check the HSE State */
    if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
10043508:	687b      	ldr	r3, [r7, #4]
1004350a:	685b      	ldr	r3, [r3, #4]
1004350c:	2b00      	cmp	r3, #0
1004350e:	d012      	beq.n	10043536 <HAL_RCC_OscConfig+0xea>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
10043510:	f7fe f84a 	bl	100415a8 <HAL_GetTick>
10043514:	0003      	movs	r3, r0
10043516:	60fb      	str	r3, [r7, #12]

      /* Wait till HSE is ready */
      while (LL_RCC_HSE_IsReady() == 0U)
10043518:	e008      	b.n	1004352c <HAL_RCC_OscConfig+0xe0>
      {
        if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
1004351a:	f7fe f845 	bl	100415a8 <HAL_GetTick>
1004351e:	0002      	movs	r2, r0
10043520:	68fb      	ldr	r3, [r7, #12]
10043522:	1ad3      	subs	r3, r2, r3
10043524:	2b64      	cmp	r3, #100	@ 0x64
10043526:	d901      	bls.n	1004352c <HAL_RCC_OscConfig+0xe0>
        {
          return HAL_TIMEOUT;
10043528:	2303      	movs	r3, #3
1004352a:	e0df      	b.n	100436ec <HAL_RCC_OscConfig+0x2a0>
      while (LL_RCC_HSE_IsReady() == 0U)
1004352c:	f7ff fdb8 	bl	100430a0 <LL_RCC_HSE_IsReady>
10043530:	1e03      	subs	r3, r0, #0
10043532:	d0f2      	beq.n	1004351a <HAL_RCC_OscConfig+0xce>
10043534:	e011      	b.n	1004355a <HAL_RCC_OscConfig+0x10e>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
10043536:	f7fe f837 	bl	100415a8 <HAL_GetTick>
1004353a:	0003      	movs	r3, r0
1004353c:	60fb      	str	r3, [r7, #12]

      /* Wait till HSE is disabled */
      while (LL_RCC_HSE_IsReady() != 0U)
1004353e:	e008      	b.n	10043552 <HAL_RCC_OscConfig+0x106>
      {
        if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
10043540:	f7fe f832 	bl	100415a8 <HAL_GetTick>
10043544:	0002      	movs	r2, r0
10043546:	68fb      	ldr	r3, [r7, #12]
10043548:	1ad3      	subs	r3, r2, r3
1004354a:	2b64      	cmp	r3, #100	@ 0x64
1004354c:	d901      	bls.n	10043552 <HAL_RCC_OscConfig+0x106>
        {
          return HAL_TIMEOUT;
1004354e:	2303      	movs	r3, #3
10043550:	e0cc      	b.n	100436ec <HAL_RCC_OscConfig+0x2a0>
      while (LL_RCC_HSE_IsReady() != 0U)
10043552:	f7ff fda5 	bl	100430a0 <LL_RCC_HSE_IsReady>
10043556:	1e03      	subs	r3, r0, #0
10043558:	d1f2      	bne.n	10043540 <HAL_RCC_OscConfig+0xf4>
      }
    }
  }

  /*--------------------------------- LSI Configuration -----------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
1004355a:	687b      	ldr	r3, [r7, #4]
1004355c:	681b      	ldr	r3, [r3, #0]
1004355e:	2204      	movs	r2, #4
10043560:	4013      	ands	r3, r2
10043562:	d03a      	beq.n	100435da <HAL_RCC_OscConfig+0x18e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if (RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
10043564:	687b      	ldr	r3, [r7, #4]
10043566:	691b      	ldr	r3, [r3, #16]
10043568:	2b00      	cmp	r3, #0
1004356a:	d022      	beq.n	100435b2 <HAL_RCC_OscConfig+0x166>
    {
      /* Disable the LSI */
      __HAL_RCC_LSI_DISABLE();
1004356c:	f7ff ff0a 	bl	10043384 <LL_RCC_LSI_Disable>
      while (__HAL_RCC_GET_LSI_READYFLAG() != 0U);
10043570:	46c0      	nop			@ (mov r8, r8)
10043572:	f7ff ff15 	bl	100433a0 <LL_RCC_LSI_IsReady>
10043576:	1e03      	subs	r3, r0, #0
10043578:	d1fb      	bne.n	10043572 <HAL_RCC_OscConfig+0x126>

      /* Disable the LSE */
      __HAL_RCC_LSE_CONFIG(RCC_LSE_OFF);
1004357a:	f7ff fe97 	bl	100432ac <LL_RCC_LSE_Disable>

      /* Configure the Low Speed Clock to LSI */
      LL_RCC_LSCO_SetSource(LL_RCC_LSCO_CLKSOURCE_LSI);
1004357e:	2380      	movs	r3, #128	@ 0x80
10043580:	025b      	lsls	r3, r3, #9
10043582:	0018      	movs	r0, r3
10043584:	f7ff fe6e 	bl	10043264 <LL_RCC_LSCO_SetSource>

      /*  Enable the Internal Low Speed oscillator (LSI)  */
      __HAL_RCC_LSI_ENABLE();
10043588:	f7ff feee 	bl	10043368 <LL_RCC_LSI_Enable>

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
1004358c:	f7fe f80c 	bl	100415a8 <HAL_GetTick>
10043590:	0003      	movs	r3, r0
10043592:	60fb      	str	r3, [r7, #12]

      /* Wait till LSI is ready */
      while (__HAL_RCC_GET_LSI_READYFLAG() == 0U)
10043594:	e008      	b.n	100435a8 <HAL_RCC_OscConfig+0x15c>
      {
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
10043596:	f7fe f807 	bl	100415a8 <HAL_GetTick>
1004359a:	0002      	movs	r2, r0
1004359c:	68fb      	ldr	r3, [r7, #12]
1004359e:	1ad3      	subs	r3, r2, r3
100435a0:	2b02      	cmp	r3, #2
100435a2:	d901      	bls.n	100435a8 <HAL_RCC_OscConfig+0x15c>
        {
          return HAL_TIMEOUT;
100435a4:	2303      	movs	r3, #3
100435a6:	e0a1      	b.n	100436ec <HAL_RCC_OscConfig+0x2a0>
      while (__HAL_RCC_GET_LSI_READYFLAG() == 0U)
100435a8:	f7ff fefa 	bl	100433a0 <LL_RCC_LSI_IsReady>
100435ac:	1e03      	subs	r3, r0, #0
100435ae:	d0f2      	beq.n	10043596 <HAL_RCC_OscConfig+0x14a>
100435b0:	e013      	b.n	100435da <HAL_RCC_OscConfig+0x18e>
    }
    else
    {

      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
100435b2:	f7ff fee7 	bl	10043384 <LL_RCC_LSI_Disable>

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
100435b6:	f7fd fff7 	bl	100415a8 <HAL_GetTick>
100435ba:	0003      	movs	r3, r0
100435bc:	60fb      	str	r3, [r7, #12]

      /* Wait till LSI is disabled */
      while (__HAL_RCC_GET_LSI_READYFLAG() != 0U)
100435be:	e008      	b.n	100435d2 <HAL_RCC_OscConfig+0x186>
      {
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
100435c0:	f7fd fff2 	bl	100415a8 <HAL_GetTick>
100435c4:	0002      	movs	r2, r0
100435c6:	68fb      	ldr	r3, [r7, #12]
100435c8:	1ad3      	subs	r3, r2, r3
100435ca:	2b02      	cmp	r3, #2
100435cc:	d901      	bls.n	100435d2 <HAL_RCC_OscConfig+0x186>
        {
          return HAL_TIMEOUT;
100435ce:	2303      	movs	r3, #3
100435d0:	e08c      	b.n	100436ec <HAL_RCC_OscConfig+0x2a0>
      while (__HAL_RCC_GET_LSI_READYFLAG() != 0U)
100435d2:	f7ff fee5 	bl	100433a0 <LL_RCC_LSI_IsReady>
100435d6:	1e03      	subs	r3, r0, #0
100435d8:	d1f2      	bne.n	100435c0 <HAL_RCC_OscConfig+0x174>
      }
    }
  }

  /*------------------------------ LSE Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
100435da:	687b      	ldr	r3, [r7, #4]
100435dc:	681b      	ldr	r3, [r3, #0]
100435de:	2202      	movs	r2, #2
100435e0:	4013      	ands	r3, r2
100435e2:	d049      	beq.n	10043678 <HAL_RCC_OscConfig+0x22c>

    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Disable LSI */
    __HAL_RCC_LSI_DISABLE();
100435e4:	f7ff fece 	bl	10043384 <LL_RCC_LSI_Disable>

    /* Disable LSE */
    __HAL_RCC_LSE_CONFIG(RCC_LSE_OFF);
100435e8:	f7ff fe60 	bl	100432ac <LL_RCC_LSE_Disable>
    while (__HAL_RCC_GET_LSE_READYFLAG() != 0);
100435ec:	46c0      	nop			@ (mov r8, r8)
100435ee:	f7ff fe6b 	bl	100432c8 <LL_RCC_LSE_IsReady>
100435f2:	1e03      	subs	r3, r0, #0
100435f4:	d1fb      	bne.n	100435ee <HAL_RCC_OscConfig+0x1a2>

    /* Configure the PB12 and PB13 in NO PULL mode */
    LL_PWR_SetNoPullB(LL_PWR_GPIO_BIT_12 |
100435f6:	23c0      	movs	r3, #192	@ 0xc0
100435f8:	019b      	lsls	r3, r3, #6
100435fa:	0018      	movs	r0, r3
100435fc:	f7ff fd1a 	bl	10043034 <LL_PWR_SetNoPullB>
                      LL_PWR_GPIO_BIT_13);

    /* Configure the Low Speed Clock to LSE */
    LL_RCC_LSCO_SetSource(LL_RCC_LSCO_CLKSOURCE_LSE);
10043600:	2380      	movs	r3, #128	@ 0x80
10043602:	021b      	lsls	r3, r3, #8
10043604:	0018      	movs	r0, r3
10043606:	f7ff fe2d 	bl	10043264 <LL_RCC_LSCO_SetSource>

    /* Set LSE oscillator drive capability */
    __HAL_RCC_LSEDRIVE_CONFIG(RCC_LSEDRIVE_MEDIUMLOW);
1004360a:	2020      	movs	r0, #32
1004360c:	f7ff fe98 	bl	10043340 <LL_RCC_LSE_SetDriveCapability>

    /* Set the new LSE state */
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
10043610:	687b      	ldr	r3, [r7, #4]
10043612:	68db      	ldr	r3, [r3, #12]
10043614:	2b10      	cmp	r3, #16
10043616:	d102      	bne.n	1004361e <HAL_RCC_OscConfig+0x1d2>
10043618:	f7ff fe3a 	bl	10043290 <LL_RCC_LSE_Enable>
1004361c:	e001      	b.n	10043622 <HAL_RCC_OscConfig+0x1d6>
1004361e:	f7ff fe45 	bl	100432ac <LL_RCC_LSE_Disable>

    /* Check the LSE State */
    if (RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
10043622:	687b      	ldr	r3, [r7, #4]
10043624:	68db      	ldr	r3, [r3, #12]
10043626:	2b00      	cmp	r3, #0
10043628:	d013      	beq.n	10043652 <HAL_RCC_OscConfig+0x206>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
1004362a:	f7fd ffbd 	bl	100415a8 <HAL_GetTick>
1004362e:	0003      	movs	r3, r0
10043630:	60fb      	str	r3, [r7, #12]

      /* Wait till LSE is ready */
      while (__HAL_RCC_GET_LSE_READYFLAG() == 0U)
10043632:	e009      	b.n	10043648 <HAL_RCC_OscConfig+0x1fc>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
10043634:	f7fd ffb8 	bl	100415a8 <HAL_GetTick>
10043638:	0002      	movs	r2, r0
1004363a:	68fb      	ldr	r3, [r7, #12]
1004363c:	1ad3      	subs	r3, r2, r3
1004363e:	4a2d      	ldr	r2, [pc, #180]	@ (100436f4 <HAL_RCC_OscConfig+0x2a8>)
10043640:	4293      	cmp	r3, r2
10043642:	d901      	bls.n	10043648 <HAL_RCC_OscConfig+0x1fc>
        {
          return HAL_TIMEOUT;
10043644:	2303      	movs	r3, #3
10043646:	e051      	b.n	100436ec <HAL_RCC_OscConfig+0x2a0>
      while (__HAL_RCC_GET_LSE_READYFLAG() == 0U)
10043648:	f7ff fe3e 	bl	100432c8 <LL_RCC_LSE_IsReady>
1004364c:	1e03      	subs	r3, r0, #0
1004364e:	d0f1      	beq.n	10043634 <HAL_RCC_OscConfig+0x1e8>
10043650:	e012      	b.n	10043678 <HAL_RCC_OscConfig+0x22c>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
10043652:	f7fd ffa9 	bl	100415a8 <HAL_GetTick>
10043656:	0003      	movs	r3, r0
10043658:	60fb      	str	r3, [r7, #12]

      /* Wait till LSE is disabled */
      while (__HAL_RCC_GET_LSE_READYFLAG() != 0U)
1004365a:	e009      	b.n	10043670 <HAL_RCC_OscConfig+0x224>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
1004365c:	f7fd ffa4 	bl	100415a8 <HAL_GetTick>
10043660:	0002      	movs	r2, r0
10043662:	68fb      	ldr	r3, [r7, #12]
10043664:	1ad3      	subs	r3, r2, r3
10043666:	4a23      	ldr	r2, [pc, #140]	@ (100436f4 <HAL_RCC_OscConfig+0x2a8>)
10043668:	4293      	cmp	r3, r2
1004366a:	d901      	bls.n	10043670 <HAL_RCC_OscConfig+0x224>
        {
          return HAL_TIMEOUT;
1004366c:	2303      	movs	r3, #3
1004366e:	e03d      	b.n	100436ec <HAL_RCC_OscConfig+0x2a0>
      while (__HAL_RCC_GET_LSE_READYFLAG() != 0U)
10043670:	f7ff fe2a 	bl	100432c8 <LL_RCC_LSE_IsReady>
10043674:	1e03      	subs	r3, r0, #0
10043676:	d1f1      	bne.n	1004365c <HAL_RCC_OscConfig+0x210>
      }
    }
  }

  /*------------------------------ LSE Bypass Configuration ------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE_BYPASS) == RCC_OSCILLATORTYPE_LSE_BYPASS)
10043678:	687b      	ldr	r3, [r7, #4]
1004367a:	681b      	ldr	r3, [r3, #0]
1004367c:	2208      	movs	r2, #8
1004367e:	4013      	ands	r3, r2
10043680:	d033      	beq.n	100436ea <HAL_RCC_OscConfig+0x29e>

    /* Check the parameters */
    assert_param(IS_RCC_LSE_BYPASS(RCC_OscInitStruct->LSEBYPASSState));

    /* Set the new LSE Bypass configuration -----------------------------------------*/
    __HAL_RCC_LSE_BYPASS_CONFIG(RCC_OscInitStruct->LSEBYPASSState);
10043682:	687b      	ldr	r3, [r7, #4]
10043684:	695b      	ldr	r3, [r3, #20]
10043686:	2b40      	cmp	r3, #64	@ 0x40
10043688:	d102      	bne.n	10043690 <HAL_RCC_OscConfig+0x244>
1004368a:	f7ff fe2d 	bl	100432e8 <LL_RCC_LSE_EnableBypass>
1004368e:	e001      	b.n	10043694 <HAL_RCC_OscConfig+0x248>
10043690:	f7ff fe38 	bl	10043304 <LL_RCC_LSE_DisableBypass>

    /* Check the LSE Bypass State */
    if (RCC_OscInitStruct->LSEBYPASSState != RCC_LSE_OFF)
10043694:	687b      	ldr	r3, [r7, #4]
10043696:	695b      	ldr	r3, [r3, #20]
10043698:	2b00      	cmp	r3, #0
1004369a:	d013      	beq.n	100436c4 <HAL_RCC_OscConfig+0x278>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
1004369c:	f7fd ff84 	bl	100415a8 <HAL_GetTick>
100436a0:	0003      	movs	r3, r0
100436a2:	60fb      	str	r3, [r7, #12]

      /* Wait till LSE is ready */
      while (LL_RCC_LSE_IsBypassEnabled() == 0U)
100436a4:	e009      	b.n	100436ba <HAL_RCC_OscConfig+0x26e>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
100436a6:	f7fd ff7f 	bl	100415a8 <HAL_GetTick>
100436aa:	0002      	movs	r2, r0
100436ac:	68fb      	ldr	r3, [r7, #12]
100436ae:	1ad3      	subs	r3, r2, r3
100436b0:	4a10      	ldr	r2, [pc, #64]	@ (100436f4 <HAL_RCC_OscConfig+0x2a8>)
100436b2:	4293      	cmp	r3, r2
100436b4:	d901      	bls.n	100436ba <HAL_RCC_OscConfig+0x26e>
        {
          return HAL_TIMEOUT;
100436b6:	2303      	movs	r3, #3
100436b8:	e018      	b.n	100436ec <HAL_RCC_OscConfig+0x2a0>
      while (LL_RCC_LSE_IsBypassEnabled() == 0U)
100436ba:	f7ff fe31 	bl	10043320 <LL_RCC_LSE_IsBypassEnabled>
100436be:	1e03      	subs	r3, r0, #0
100436c0:	d0f1      	beq.n	100436a6 <HAL_RCC_OscConfig+0x25a>
100436c2:	e012      	b.n	100436ea <HAL_RCC_OscConfig+0x29e>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
100436c4:	f7fd ff70 	bl	100415a8 <HAL_GetTick>
100436c8:	0003      	movs	r3, r0
100436ca:	60fb      	str	r3, [r7, #12]

      /* Wait till LSE is disabled */
      while (LL_RCC_LSE_IsBypassEnabled() != 0U)
100436cc:	e009      	b.n	100436e2 <HAL_RCC_OscConfig+0x296>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
100436ce:	f7fd ff6b 	bl	100415a8 <HAL_GetTick>
100436d2:	0002      	movs	r2, r0
100436d4:	68fb      	ldr	r3, [r7, #12]
100436d6:	1ad3      	subs	r3, r2, r3
100436d8:	4a06      	ldr	r2, [pc, #24]	@ (100436f4 <HAL_RCC_OscConfig+0x2a8>)
100436da:	4293      	cmp	r3, r2
100436dc:	d901      	bls.n	100436e2 <HAL_RCC_OscConfig+0x296>
        {
          return HAL_TIMEOUT;
100436de:	2303      	movs	r3, #3
100436e0:	e004      	b.n	100436ec <HAL_RCC_OscConfig+0x2a0>
      while (LL_RCC_LSE_IsBypassEnabled() != 0U)
100436e2:	f7ff fe1d 	bl	10043320 <LL_RCC_LSE_IsBypassEnabled>
100436e6:	1e03      	subs	r3, r0, #0
100436e8:	d1f1      	bne.n	100436ce <HAL_RCC_OscConfig+0x282>
        }
      }
    }
  }

  return HAL_OK;
100436ea:	2300      	movs	r3, #0
}
100436ec:	0018      	movs	r0, r3
100436ee:	46bd      	mov	sp, r7
100436f0:	b004      	add	sp, #16
100436f2:	bd80      	pop	{r7, pc}
100436f4:	00001388 	.word	0x00001388

100436f8 <HAL_RCC_ClockConfig>:
  *         currently used as system clock source.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
100436f8:	b580      	push	{r7, lr}
100436fa:	b084      	sub	sp, #16
100436fc:	af00      	add	r7, sp, #0
100436fe:	6078      	str	r0, [r7, #4]
10043700:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;

  /* Check Null pointer */
  if (RCC_ClkInitStruct == NULL)
10043702:	687b      	ldr	r3, [r7, #4]
10043704:	2b00      	cmp	r3, #0
10043706:	d101      	bne.n	1004370c <HAL_RCC_ClockConfig+0x14>
  {
    return HAL_ERROR;
10043708:	2301      	movs	r3, #1
1004370a:	e08e      	b.n	1004382a <HAL_RCC_ClockConfig+0x132>

  /* Check the parameters */
  assert_param(IS_FLASH_WAIT_STATES(FLatency));

  /* Set FALSH_WAIT_STATES_1 */
  __HAL_FLASH_SET_WAIT_STATES(FLatency);
1004370c:	4b49      	ldr	r3, [pc, #292]	@ (10043834 <HAL_RCC_ClockConfig+0x13c>)
1004370e:	685b      	ldr	r3, [r3, #4]
10043710:	2230      	movs	r2, #48	@ 0x30
10043712:	4393      	bics	r3, r2
10043714:	0019      	movs	r1, r3
10043716:	4b47      	ldr	r3, [pc, #284]	@ (10043834 <HAL_RCC_ClockConfig+0x13c>)
10043718:	683a      	ldr	r2, [r7, #0]
1004371a:	430a      	orrs	r2, r1
1004371c:	605a      	str	r2, [r3, #4]
  /*------------------------- SYSCLK Configuration ---------------------------*/
  assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
  assert_param(IS_RCC_SYSCLK_DIVIDER(RCC_ClkInitStruct->SYSCLKDivider));

  /* HSI is selected as System Clock Source */
  if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI)
1004371e:	687b      	ldr	r3, [r7, #4]
10043720:	681b      	ldr	r3, [r3, #0]
10043722:	2b02      	cmp	r3, #2
10043724:	d10e      	bne.n	10043744 <HAL_RCC_ClockConfig+0x4c>
  {
    LL_RCC_HSI_Enable();
10043726:	f7ff fd3b 	bl	100431a0 <LL_RCC_HSI_Enable>
    
    /* Check the HSI ready flag */
    if (LL_RCC_HSI_IsReady() == 0U)
1004372a:	f7ff fd61 	bl	100431f0 <LL_RCC_HSI_IsReady>
1004372e:	1e03      	subs	r3, r0, #0
10043730:	d101      	bne.n	10043736 <HAL_RCC_ClockConfig+0x3e>
    {
      return HAL_ERROR;
10043732:	2301      	movs	r3, #1
10043734:	e079      	b.n	1004382a <HAL_RCC_ClockConfig+0x132>
    }

    /* Disable the RC64MPLL*/
    __HAL_RCC_RC64MPLL_DISABLE();
10043736:	f7ff fe51 	bl	100433dc <LL_RCC_RC64MPLL_Disable>
    
    /* Configure the RC64MPLL multiplication factor */
    __HAL_RCC_RC64MPLL_PRESC_CONFIG(RCC_ClkInitStruct->SYSCLKDivider);
1004373a:	687b      	ldr	r3, [r7, #4]
1004373c:	685b      	ldr	r3, [r3, #4]
1004373e:	0018      	movs	r0, r3
10043740:	f7ff fe70 	bl	10043424 <LL_RCC_SetRC64MPLLPrescaler>
  }

  /* RC64MPLL is selected as System Clock Source */
  if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_RC64MPLL)
10043744:	687b      	ldr	r3, [r7, #4]
10043746:	681b      	ldr	r3, [r3, #0]
10043748:	2b00      	cmp	r3, #0
1004374a:	d124      	bne.n	10043796 <HAL_RCC_ClockConfig+0x9e>
  {
    /* Check the HSI ready flag */
    if (LL_RCC_HSI_IsReady() == 0U)
1004374c:	f7ff fd50 	bl	100431f0 <LL_RCC_HSI_IsReady>
10043750:	1e03      	subs	r3, r0, #0
10043752:	d101      	bne.n	10043758 <HAL_RCC_ClockConfig+0x60>
    {
      return HAL_ERROR;
10043754:	2301      	movs	r3, #1
10043756:	e068      	b.n	1004382a <HAL_RCC_ClockConfig+0x132>
    }

    /* Check the HSE ready flag */
    if (LL_RCC_HSE_IsReady() == 0U)
10043758:	f7ff fca2 	bl	100430a0 <LL_RCC_HSE_IsReady>
1004375c:	1e03      	subs	r3, r0, #0
1004375e:	d101      	bne.n	10043764 <HAL_RCC_ClockConfig+0x6c>
    {
      return HAL_ERROR;
10043760:	2301      	movs	r3, #1
10043762:	e062      	b.n	1004382a <HAL_RCC_ClockConfig+0x132>
    }

    /* Enable the RC64MPLL*/
    __HAL_RCC_RC64MPLL_ENABLE();
10043764:	f7ff fe2c 	bl	100433c0 <LL_RCC_RC64MPLL_Enable>

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
10043768:	f7fd ff1e 	bl	100415a8 <HAL_GetTick>
1004376c:	0003      	movs	r3, r0
1004376e:	60fb      	str	r3, [r7, #12]

    /* Wait till RC64MPLL is ready */
    while (LL_RCC_RC64MPLL_IsReady() == 0)
10043770:	e008      	b.n	10043784 <HAL_RCC_ClockConfig+0x8c>
    {
      if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
10043772:	f7fd ff19 	bl	100415a8 <HAL_GetTick>
10043776:	0002      	movs	r2, r0
10043778:	68fb      	ldr	r3, [r7, #12]
1004377a:	1ad3      	subs	r3, r2, r3
1004377c:	2b02      	cmp	r3, #2
1004377e:	d901      	bls.n	10043784 <HAL_RCC_ClockConfig+0x8c>
      {
        return HAL_TIMEOUT;
10043780:	2303      	movs	r3, #3
10043782:	e052      	b.n	1004382a <HAL_RCC_ClockConfig+0x132>
    while (LL_RCC_RC64MPLL_IsReady() == 0)
10043784:	f7ff fe3a 	bl	100433fc <LL_RCC_RC64MPLL_IsReady>
10043788:	1e03      	subs	r3, r0, #0
1004378a:	d0f2      	beq.n	10043772 <HAL_RCC_ClockConfig+0x7a>
      }
    }

    /* Configure the RC64MPLL multiplication factor */
    __HAL_RCC_RC64MPLL_PRESC_CONFIG(RCC_ClkInitStruct->SYSCLKDivider);
1004378c:	687b      	ldr	r3, [r7, #4]
1004378e:	685b      	ldr	r3, [r3, #4]
10043790:	0018      	movs	r0, r3
10043792:	f7ff fe47 	bl	10043424 <LL_RCC_SetRC64MPLLPrescaler>
  }

  /* DIRECT_HSE is selected as System Clock Source */
  if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_DIRECT_HSE)
10043796:	687b      	ldr	r3, [r7, #4]
10043798:	681b      	ldr	r3, [r3, #0]
1004379a:	2b01      	cmp	r3, #1
1004379c:	d117      	bne.n	100437ce <HAL_RCC_ClockConfig+0xd6>
  {
    /* Enable the DIRECT_HSE configuration */
    LL_RCC_DIRECT_HSE_Enable();
1004379e:	f7ff fd3b 	bl	10043218 <LL_RCC_DIRECT_HSE_Enable>

    /* Check the HSI ready flag */
    if (LL_RCC_HSI_IsReady() != 0U)
100437a2:	f7ff fd25 	bl	100431f0 <LL_RCC_HSI_IsReady>
100437a6:	1e03      	subs	r3, r0, #0
100437a8:	d001      	beq.n	100437ae <HAL_RCC_ClockConfig+0xb6>
    {
      return HAL_ERROR;
100437aa:	2301      	movs	r3, #1
100437ac:	e03d      	b.n	1004382a <HAL_RCC_ClockConfig+0x132>
    }

    /* Check the HSE ready flag */
    if (LL_RCC_HSE_IsReady() == 0U)
100437ae:	f7ff fc77 	bl	100430a0 <LL_RCC_HSE_IsReady>
100437b2:	1e03      	subs	r3, r0, #0
100437b4:	d101      	bne.n	100437ba <HAL_RCC_ClockConfig+0xc2>
    {
      return HAL_ERROR;
100437b6:	2301      	movs	r3, #1
100437b8:	e037      	b.n	1004382a <HAL_RCC_ClockConfig+0x132>
    }

    /* Configure the DIRECT_HSE multiplication factor */
    __HAL_RCC_DIRECT_HSE_PRESC_CONFIG(RCC_ClkInitStruct->SYSCLKDivider);
100437ba:	4b1f      	ldr	r3, [pc, #124]	@ (10043838 <HAL_RCC_ClockConfig+0x140>)
100437bc:	689b      	ldr	r3, [r3, #8]
100437be:	22e0      	movs	r2, #224	@ 0xe0
100437c0:	4393      	bics	r3, r2
100437c2:	0019      	movs	r1, r3
100437c4:	687b      	ldr	r3, [r7, #4]
100437c6:	685a      	ldr	r2, [r3, #4]
100437c8:	4b1b      	ldr	r3, [pc, #108]	@ (10043838 <HAL_RCC_ClockConfig+0x140>)
100437ca:	430a      	orrs	r2, r1
100437cc:	609a      	str	r2, [r3, #8]
  /*----------------------- FLASH Latency Configuration ------------------------*/
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
     must be correctly programmed according to the frequency of the FLASH clock */

  /* Setup flash wait states because according the system clock frequency */
  if (FLatency != __HAL_FLASH_GET_WAIT_STATES())
100437ce:	4b19      	ldr	r3, [pc, #100]	@ (10043834 <HAL_RCC_ClockConfig+0x13c>)
100437d0:	685b      	ldr	r3, [r3, #4]
100437d2:	2230      	movs	r2, #48	@ 0x30
100437d4:	4013      	ands	r3, r2
100437d6:	683a      	ldr	r2, [r7, #0]
100437d8:	429a      	cmp	r2, r3
100437da:	d01d      	beq.n	10043818 <HAL_RCC_ClockConfig+0x120>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_CONFIG register */
    __HAL_FLASH_SET_WAIT_STATES(FLatency);
100437dc:	4b15      	ldr	r3, [pc, #84]	@ (10043834 <HAL_RCC_ClockConfig+0x13c>)
100437de:	685b      	ldr	r3, [r3, #4]
100437e0:	2230      	movs	r2, #48	@ 0x30
100437e2:	4393      	bics	r3, r2
100437e4:	0019      	movs	r1, r3
100437e6:	4b13      	ldr	r3, [pc, #76]	@ (10043834 <HAL_RCC_ClockConfig+0x13c>)
100437e8:	683a      	ldr	r2, [r7, #0]
100437ea:	430a      	orrs	r2, r1
100437ec:	605a      	str	r2, [r3, #4]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
100437ee:	f7fd fedb 	bl	100415a8 <HAL_GetTick>
100437f2:	0003      	movs	r3, r0
100437f4:	60fb      	str	r3, [r7, #12]

    /* Check that the new number of wait states is taken into account to access the Flash
       memory by reading the FLASH_CONFIG register */
    while (__HAL_FLASH_GET_WAIT_STATES() != FLatency)
100437f6:	e008      	b.n	1004380a <HAL_RCC_ClockConfig+0x112>
    {
      if ((HAL_GetTick() - tickstart) > LATENCY_TIMEOUT_VALUE)
100437f8:	f7fd fed6 	bl	100415a8 <HAL_GetTick>
100437fc:	0002      	movs	r2, r0
100437fe:	68fb      	ldr	r3, [r7, #12]
10043800:	1ad3      	subs	r3, r2, r3
10043802:	2b02      	cmp	r3, #2
10043804:	d901      	bls.n	1004380a <HAL_RCC_ClockConfig+0x112>
      {
        return HAL_TIMEOUT;
10043806:	2303      	movs	r3, #3
10043808:	e00f      	b.n	1004382a <HAL_RCC_ClockConfig+0x132>
    while (__HAL_FLASH_GET_WAIT_STATES() != FLatency)
1004380a:	4b0a      	ldr	r3, [pc, #40]	@ (10043834 <HAL_RCC_ClockConfig+0x13c>)
1004380c:	685b      	ldr	r3, [r3, #4]
1004380e:	2230      	movs	r2, #48	@ 0x30
10043810:	4013      	ands	r3, r2
10043812:	683a      	ldr	r2, [r7, #0]
10043814:	429a      	cmp	r2, r3
10043816:	d1ef      	bne.n	100437f8 <HAL_RCC_ClockConfig+0x100>
  }

  /*---------------------------------------------------------------------------*/

  /* Update the SystemCoreClock global variable */
  SystemCoreClockUpdate();
10043818:	f7fd fe06 	bl	10041428 <SystemCoreClockUpdate>

  /* Configure the source of time base considering new system clocks settings*/
  return HAL_InitTick(HAL_GetTickPrio());
1004381c:	f7fd fece 	bl	100415bc <HAL_GetTickPrio>
10043820:	0003      	movs	r3, r0
10043822:	0018      	movs	r0, r3
10043824:	f7fd fe66 	bl	100414f4 <HAL_InitTick>
10043828:	0003      	movs	r3, r0
}
1004382a:	0018      	movs	r0, r3
1004382c:	46bd      	mov	sp, r7
1004382e:	b004      	add	sp, #16
10043830:	bd80      	pop	{r7, pc}
10043832:	46c0      	nop			@ (mov r8, r8)
10043834:	40001000 	.word	0x40001000
10043838:	48400000 	.word	0x48400000

1004383c <HAL_RCC_GetSysClockFreq>:
  *         content of the SystemCoreClock CMSIS variable
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
1004383c:	b580      	push	{r7, lr}
1004383e:	af00      	add	r7, sp, #0
  return SystemCoreClock;
10043840:	4b02      	ldr	r3, [pc, #8]	@ (1004384c <HAL_RCC_GetSysClockFreq+0x10>)
10043842:	681b      	ldr	r3, [r3, #0]
}
10043844:	0018      	movs	r0, r3
10043846:	46bd      	mov	sp, r7
10043848:	bd80      	pop	{r7, pc}
1004384a:	46c0      	nop			@ (mov r8, r8)
1004384c:	20000688 	.word	0x20000688

10043850 <LL_RCC_DIRECT_HSE_IsEnabled>:
{
10043850:	b580      	push	{r7, lr}
10043852:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CFGR, RCC_CFGR_HSESEL_STATUS) == (RCC_CFGR_HSESEL_STATUS)) ? 1UL : 0UL);
10043854:	4b05      	ldr	r3, [pc, #20]	@ (1004386c <LL_RCC_DIRECT_HSE_IsEnabled+0x1c>)
10043856:	689b      	ldr	r3, [r3, #8]
10043858:	2208      	movs	r2, #8
1004385a:	4013      	ands	r3, r2
1004385c:	2b08      	cmp	r3, #8
1004385e:	d101      	bne.n	10043864 <LL_RCC_DIRECT_HSE_IsEnabled+0x14>
10043860:	2301      	movs	r3, #1
10043862:	e000      	b.n	10043866 <LL_RCC_DIRECT_HSE_IsEnabled+0x16>
10043864:	2300      	movs	r3, #0
}
10043866:	0018      	movs	r0, r3
10043868:	46bd      	mov	sp, r7
1004386a:	bd80      	pop	{r7, pc}
1004386c:	48400000 	.word	0x48400000

10043870 <LL_RCC_LSCO_SetSource>:
{
10043870:	b580      	push	{r7, lr}
10043872:	b082      	sub	sp, #8
10043874:	af00      	add	r7, sp, #0
10043876:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_CLKSLOWSEL, Source);
10043878:	4b06      	ldr	r3, [pc, #24]	@ (10043894 <LL_RCC_LSCO_SetSource+0x24>)
1004387a:	689b      	ldr	r3, [r3, #8]
1004387c:	4a06      	ldr	r2, [pc, #24]	@ (10043898 <LL_RCC_LSCO_SetSource+0x28>)
1004387e:	4013      	ands	r3, r2
10043880:	0019      	movs	r1, r3
10043882:	4b04      	ldr	r3, [pc, #16]	@ (10043894 <LL_RCC_LSCO_SetSource+0x24>)
10043884:	687a      	ldr	r2, [r7, #4]
10043886:	430a      	orrs	r2, r1
10043888:	609a      	str	r2, [r3, #8]
}
1004388a:	46c0      	nop			@ (mov r8, r8)
1004388c:	46bd      	mov	sp, r7
1004388e:	b002      	add	sp, #8
10043890:	bd80      	pop	{r7, pc}
10043892:	46c0      	nop			@ (mov r8, r8)
10043894:	48400000 	.word	0x48400000
10043898:	fffe7fff 	.word	0xfffe7fff

1004389c <LL_RCC_SetSMPSPrescaler>:
{
1004389c:	b580      	push	{r7, lr}
1004389e:	b082      	sub	sp, #8
100438a0:	af00      	add	r7, sp, #0
100438a2:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_SMPSDIV, Prescaler);
100438a4:	4b06      	ldr	r3, [pc, #24]	@ (100438c0 <LL_RCC_SetSMPSPrescaler+0x24>)
100438a6:	689b      	ldr	r3, [r3, #8]
100438a8:	4a06      	ldr	r2, [pc, #24]	@ (100438c4 <LL_RCC_SetSMPSPrescaler+0x28>)
100438aa:	4013      	ands	r3, r2
100438ac:	0019      	movs	r1, r3
100438ae:	4b04      	ldr	r3, [pc, #16]	@ (100438c0 <LL_RCC_SetSMPSPrescaler+0x24>)
100438b0:	687a      	ldr	r2, [r7, #4]
100438b2:	430a      	orrs	r2, r1
100438b4:	609a      	str	r2, [r3, #8]
}
100438b6:	46c0      	nop			@ (mov r8, r8)
100438b8:	46bd      	mov	sp, r7
100438ba:	b002      	add	sp, #8
100438bc:	bd80      	pop	{r7, pc}
100438be:	46c0      	nop			@ (mov r8, r8)
100438c0:	48400000 	.word	0x48400000
100438c4:	ffffefff 	.word	0xffffefff

100438c8 <LL_RCC_GetSMPSPrescaler>:
{
100438c8:	b580      	push	{r7, lr}
100438ca:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SMPSDIV));
100438cc:	4b03      	ldr	r3, [pc, #12]	@ (100438dc <LL_RCC_GetSMPSPrescaler+0x14>)
100438ce:	689a      	ldr	r2, [r3, #8]
100438d0:	2380      	movs	r3, #128	@ 0x80
100438d2:	015b      	lsls	r3, r3, #5
100438d4:	4013      	ands	r3, r2
}
100438d6:	0018      	movs	r0, r3
100438d8:	46bd      	mov	sp, r7
100438da:	bd80      	pop	{r7, pc}
100438dc:	48400000 	.word	0x48400000

100438e0 <LL_RCC_KRM_IsEnabled>:
{
100438e0:	b580      	push	{r7, lr}
100438e2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->KRMR, RCC_KRMR_KRM_EN) == (RCC_KRMR_KRM_EN)) ? 1UL : 0UL);
100438e4:	4b05      	ldr	r3, [pc, #20]	@ (100438fc <LL_RCC_KRM_IsEnabled+0x1c>)
100438e6:	691b      	ldr	r3, [r3, #16]
100438e8:	2201      	movs	r2, #1
100438ea:	4013      	ands	r3, r2
100438ec:	2b01      	cmp	r3, #1
100438ee:	d101      	bne.n	100438f4 <LL_RCC_KRM_IsEnabled+0x14>
100438f0:	2301      	movs	r3, #1
100438f2:	e000      	b.n	100438f6 <LL_RCC_KRM_IsEnabled+0x16>
100438f4:	2300      	movs	r3, #0
}
100438f6:	0018      	movs	r0, r3
100438f8:	46bd      	mov	sp, r7
100438fa:	bd80      	pop	{r7, pc}
100438fc:	48400000 	.word	0x48400000

10043900 <LL_RCC_KRM_SetRateMultiplier>:
{
10043900:	b580      	push	{r7, lr}
10043902:	b082      	sub	sp, #8
10043904:	af00      	add	r7, sp, #0
10043906:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->KRMR, RCC_KRMR_KRM, Value << RCC_KRMR_KRM_Pos);
10043908:	4b06      	ldr	r3, [pc, #24]	@ (10043924 <LL_RCC_KRM_SetRateMultiplier+0x24>)
1004390a:	691b      	ldr	r3, [r3, #16]
1004390c:	4a06      	ldr	r2, [pc, #24]	@ (10043928 <LL_RCC_KRM_SetRateMultiplier+0x28>)
1004390e:	4013      	ands	r3, r2
10043910:	0019      	movs	r1, r3
10043912:	687b      	ldr	r3, [r7, #4]
10043914:	005a      	lsls	r2, r3, #1
10043916:	4b03      	ldr	r3, [pc, #12]	@ (10043924 <LL_RCC_KRM_SetRateMultiplier+0x24>)
10043918:	430a      	orrs	r2, r1
1004391a:	611a      	str	r2, [r3, #16]
}
1004391c:	46c0      	nop			@ (mov r8, r8)
1004391e:	46bd      	mov	sp, r7
10043920:	b002      	add	sp, #8
10043922:	bd80      	pop	{r7, pc}
10043924:	48400000 	.word	0x48400000
10043928:	ffff0001 	.word	0xffff0001

1004392c <LL_RCC_KRM_GetRateMultiplier>:
{
1004392c:	b580      	push	{r7, lr}
1004392e:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->KRMR, RCC_KRMR_KRM) >> RCC_KRMR_KRM_Pos);
10043930:	4b03      	ldr	r3, [pc, #12]	@ (10043940 <LL_RCC_KRM_GetRateMultiplier+0x14>)
10043932:	691b      	ldr	r3, [r3, #16]
10043934:	085b      	lsrs	r3, r3, #1
10043936:	045b      	lsls	r3, r3, #17
10043938:	0c5b      	lsrs	r3, r3, #17
}
1004393a:	0018      	movs	r0, r3
1004393c:	46bd      	mov	sp, r7
1004393e:	bd80      	pop	{r7, pc}
10043940:	48400000 	.word	0x48400000

10043944 <LL_RCC_SetLPUARTClockSource>:
{
10043944:	b580      	push	{r7, lr}
10043946:	b082      	sub	sp, #8
10043948:	af00      	add	r7, sp, #0
1004394a:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_LPUCLKSEL, Source);
1004394c:	4b06      	ldr	r3, [pc, #24]	@ (10043968 <LL_RCC_SetLPUARTClockSource+0x24>)
1004394e:	689b      	ldr	r3, [r3, #8]
10043950:	4a06      	ldr	r2, [pc, #24]	@ (1004396c <LL_RCC_SetLPUARTClockSource+0x28>)
10043952:	4013      	ands	r3, r2
10043954:	0019      	movs	r1, r3
10043956:	4b04      	ldr	r3, [pc, #16]	@ (10043968 <LL_RCC_SetLPUARTClockSource+0x24>)
10043958:	687a      	ldr	r2, [r7, #4]
1004395a:	430a      	orrs	r2, r1
1004395c:	609a      	str	r2, [r3, #8]
}
1004395e:	46c0      	nop			@ (mov r8, r8)
10043960:	46bd      	mov	sp, r7
10043962:	b002      	add	sp, #8
10043964:	bd80      	pop	{r7, pc}
10043966:	46c0      	nop			@ (mov r8, r8)
10043968:	48400000 	.word	0x48400000
1004396c:	ffffdfff 	.word	0xffffdfff

10043970 <LL_RCC_GetLPUARTClockSource>:
{
10043970:	b580      	push	{r7, lr}
10043972:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_LPUCLKSEL));
10043974:	4b03      	ldr	r3, [pc, #12]	@ (10043984 <LL_RCC_GetLPUARTClockSource+0x14>)
10043976:	689a      	ldr	r2, [r3, #8]
10043978:	2380      	movs	r3, #128	@ 0x80
1004397a:	019b      	lsls	r3, r3, #6
1004397c:	4013      	ands	r3, r2
}
1004397e:	0018      	movs	r0, r3
10043980:	46bd      	mov	sp, r7
10043982:	bd80      	pop	{r7, pc}
10043984:	48400000 	.word	0x48400000

10043988 <LL_RCC_SetSPI3I2SClockSource>:
{
10043988:	b580      	push	{r7, lr}
1004398a:	b082      	sub	sp, #8
1004398c:	af00      	add	r7, sp, #0
1004398e:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_SPI3I2SCLKSEL, Source);
10043990:	4b06      	ldr	r3, [pc, #24]	@ (100439ac <LL_RCC_SetSPI3I2SClockSource+0x24>)
10043992:	689b      	ldr	r3, [r3, #8]
10043994:	4a06      	ldr	r2, [pc, #24]	@ (100439b0 <LL_RCC_SetSPI3I2SClockSource+0x28>)
10043996:	4013      	ands	r3, r2
10043998:	0019      	movs	r1, r3
1004399a:	4b04      	ldr	r3, [pc, #16]	@ (100439ac <LL_RCC_SetSPI3I2SClockSource+0x24>)
1004399c:	687a      	ldr	r2, [r7, #4]
1004399e:	430a      	orrs	r2, r1
100439a0:	609a      	str	r2, [r3, #8]
}
100439a2:	46c0      	nop			@ (mov r8, r8)
100439a4:	46bd      	mov	sp, r7
100439a6:	b002      	add	sp, #8
100439a8:	bd80      	pop	{r7, pc}
100439aa:	46c0      	nop			@ (mov r8, r8)
100439ac:	48400000 	.word	0x48400000
100439b0:	ff3fffff 	.word	0xff3fffff

100439b4 <LL_RCC_GetSPI3I2SClockSource>:
{
100439b4:	b580      	push	{r7, lr}
100439b6:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SPI3I2SCLKSEL));
100439b8:	4b03      	ldr	r3, [pc, #12]	@ (100439c8 <LL_RCC_GetSPI3I2SClockSource+0x14>)
100439ba:	689a      	ldr	r2, [r3, #8]
100439bc:	23c0      	movs	r3, #192	@ 0xc0
100439be:	041b      	lsls	r3, r3, #16
100439c0:	4013      	ands	r3, r2
}
100439c2:	0018      	movs	r0, r3
100439c4:	46bd      	mov	sp, r7
100439c6:	bd80      	pop	{r7, pc}
100439c8:	48400000 	.word	0x48400000

100439cc <HAL_RCCEx_PeriphCLKConfig>:
  *            @arg @ref RCC_PERIPHCLK_LPUART1           LPUART1 peripheral clock
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
100439cc:	b580      	push	{r7, lr}
100439ce:	b082      	sub	sp, #8
100439d0:	af00      	add	r7, sp, #0
100439d2:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));


  /*-------------------------- SMPS clock configuration -------------------------------*/
  if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SMPS) == RCC_PERIPHCLK_SMPS))
100439d4:	687b      	ldr	r3, [r7, #4]
100439d6:	681b      	ldr	r3, [r3, #0]
100439d8:	2202      	movs	r2, #2
100439da:	4013      	ands	r3, r2
100439dc:	d009      	beq.n	100439f2 <HAL_RCCEx_PeriphCLKConfig+0x26>
  {
    assert_param(IS_RCC_SMPS_CLOCK_PRESC(PeriphClkInit->SmpsDivSelection));
    __HAL_RCC_SMPS_DIV_CONFIG(PeriphClkInit->SmpsDivSelection);
100439de:	687b      	ldr	r3, [r7, #4]
100439e0:	691b      	ldr	r3, [r3, #16]
100439e2:	0018      	movs	r0, r3
100439e4:	f7ff ff5a 	bl	1004389c <LL_RCC_SetSMPSPrescaler>
    __HAL_RCC_KRM_RATE_MULTIPLIER_CONFIG(PeriphClkInit->KRMRateMultiplier);
100439e8:	687b      	ldr	r3, [r7, #4]
100439ea:	695b      	ldr	r3, [r3, #20]
100439ec:	0018      	movs	r0, r3
100439ee:	f7ff ff87 	bl	10043900 <LL_RCC_KRM_SetRateMultiplier>
  }

  /*-------------------------- SPI3_I2S clock source configuration ---------------------*/
  if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI3_I2S) == RCC_PERIPHCLK_SPI3_I2S))
100439f2:	687b      	ldr	r3, [r7, #4]
100439f4:	681b      	ldr	r3, [r3, #0]
100439f6:	2208      	movs	r2, #8
100439f8:	4013      	ands	r3, r2
100439fa:	d004      	beq.n	10043a06 <HAL_RCCEx_PeriphCLKConfig+0x3a>
  {
    assert_param(IS_RCC_SPI3I2S_CLOCK_SOURCE(PeriphClkInit->SPI3I2SClockSelection));
    __HAL_RCC_SPI3I2S_CLK_CONFIG(PeriphClkInit->SPI3I2SClockSelection);
100439fc:	687b      	ldr	r3, [r7, #4]
100439fe:	685b      	ldr	r3, [r3, #4]
10043a00:	0018      	movs	r0, r3
10043a02:	f7ff ffc1 	bl	10043988 <LL_RCC_SetSPI3I2SClockSource>
  }
#if defined(RCC_CFGR_LPUCLKSEL)
  /*-------------------------- LPUART1 clock source configuration ---------------------*/
  if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1))
10043a06:	687b      	ldr	r3, [r7, #4]
10043a08:	681b      	ldr	r3, [r3, #0]
10043a0a:	2210      	movs	r2, #16
10043a0c:	4013      	ands	r3, r2
10043a0e:	d004      	beq.n	10043a1a <HAL_RCCEx_PeriphCLKConfig+0x4e>
  {
    assert_param(IS_RCC_LPUART1_CLOCK_SOURCE(PeriphClkInit->LPUART1ClockSelection));
    __HAL_RCC_LPUART1_CLK_CONFIG(PeriphClkInit->LPUART1ClockSelection);
10043a10:	687b      	ldr	r3, [r7, #4]
10043a12:	68db      	ldr	r3, [r3, #12]
10043a14:	0018      	movs	r0, r3
10043a16:	f7ff ff95 	bl	10043944 <LL_RCC_SetLPUARTClockSource>
  }
#endif /* RCC_CFGR_LPUCLKSEL */

  if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC_WDG_SUBG_LPAWUR_LCD_LCSC) ==
10043a1a:	687b      	ldr	r3, [r7, #4]
10043a1c:	681b      	ldr	r3, [r3, #0]
10043a1e:	2220      	movs	r2, #32
10043a20:	4013      	ands	r3, r2
10043a22:	d004      	beq.n	10043a2e <HAL_RCCEx_PeriphCLKConfig+0x62>
       RCC_PERIPHCLK_RTC_WDG_SUBG_LPAWUR_LCD_LCSC))
  {
    assert_param(IS_RCC_RTC_WDG_SUBG_PAWUR_LCD_LCSC_CLOCK_SOURCE(PeriphClkInit->RTCWDGSUBGLPAWURLCDLCSCClockSelection));
    __HAL_RCC_RTC_SUBG_LPAWUR_LCD_LCSC_CLK_CONFIG(PeriphClkInit->RTCWDGSUBGLPAWURLCDLCSCClockSelection);
10043a24:	687b      	ldr	r3, [r7, #4]
10043a26:	689b      	ldr	r3, [r3, #8]
10043a28:	0018      	movs	r0, r3
10043a2a:	f7ff ff21 	bl	10043870 <LL_RCC_LSCO_SetSource>
  }

  return HAL_OK;
10043a2e:	2300      	movs	r3, #0
}
10043a30:	0018      	movs	r0, r3
10043a32:	46bd      	mov	sp, r7
10043a34:	b002      	add	sp, #8
10043a36:	bd80      	pop	{r7, pc}

10043a38 <HAL_RCCEx_GetPeriphCLKFreq>:
  *            @arg @ref RCC_PERIPHCLK_LPUART1           LPUART1 peripheral clock
  * @retval Frequency in Hz
  * @note   (*) Peripherals are not available on all devices
  */
uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)
{
10043a38:	b580      	push	{r7, lr}
10043a3a:	b086      	sub	sp, #24
10043a3c:	af00      	add	r7, sp, #0
10043a3e:	6078      	str	r0, [r7, #4]

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClk));

  /* No if clausule is covered */
  frequency = 0;
10043a40:	2300      	movs	r3, #0
10043a42:	617b      	str	r3, [r7, #20]

  switch (PeriphClk)
10043a44:	687b      	ldr	r3, [r7, #4]
10043a46:	2b10      	cmp	r3, #16
10043a48:	d100      	bne.n	10043a4c <HAL_RCCEx_GetPeriphCLKFreq+0x14>
10043a4a:	e06b      	b.n	10043b24 <HAL_RCCEx_GetPeriphCLKFreq+0xec>
10043a4c:	687b      	ldr	r3, [r7, #4]
10043a4e:	2b10      	cmp	r3, #16
10043a50:	d900      	bls.n	10043a54 <HAL_RCCEx_GetPeriphCLKFreq+0x1c>
10043a52:	e076      	b.n	10043b42 <HAL_RCCEx_GetPeriphCLKFreq+0x10a>
10043a54:	687b      	ldr	r3, [r7, #4]
10043a56:	2b08      	cmp	r3, #8
10043a58:	d03a      	beq.n	10043ad0 <HAL_RCCEx_GetPeriphCLKFreq+0x98>
10043a5a:	687b      	ldr	r3, [r7, #4]
10043a5c:	2b08      	cmp	r3, #8
10043a5e:	d900      	bls.n	10043a62 <HAL_RCCEx_GetPeriphCLKFreq+0x2a>
10043a60:	e06f      	b.n	10043b42 <HAL_RCCEx_GetPeriphCLKFreq+0x10a>
10043a62:	687b      	ldr	r3, [r7, #4]
10043a64:	2b01      	cmp	r3, #1
10043a66:	d003      	beq.n	10043a70 <HAL_RCCEx_GetPeriphCLKFreq+0x38>
10043a68:	687b      	ldr	r3, [r7, #4]
10043a6a:	2b02      	cmp	r3, #2
10043a6c:	d003      	beq.n	10043a76 <HAL_RCCEx_GetPeriphCLKFreq+0x3e>
          break;
      }
      break;
#endif /* RCC_CFGR_LPUCLKSEL */
    default :
      break;
10043a6e:	e068      	b.n	10043b42 <HAL_RCCEx_GetPeriphCLKFreq+0x10a>
      frequency = HSE_VALUE / 3;
10043a70:	4b38      	ldr	r3, [pc, #224]	@ (10043b54 <HAL_RCCEx_GetPeriphCLKFreq+0x11c>)
10043a72:	617b      	str	r3, [r7, #20]
      break;
10043a74:	e068      	b.n	10043b48 <HAL_RCCEx_GetPeriphCLKFreq+0x110>
      if (__HAL_RCC_IS_KRM_ENABLED())
10043a76:	f7ff ff33 	bl	100438e0 <LL_RCC_KRM_IsEnabled>
10043a7a:	1e03      	subs	r3, r0, #0
10043a7c:	d018      	beq.n	10043ab0 <HAL_RCCEx_GetPeriphCLKFreq+0x78>
        if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_DIRECT_HSE)
10043a7e:	f7ff fee7 	bl	10043850 <LL_RCC_DIRECT_HSE_IsEnabled>
10043a82:	1e03      	subs	r3, r0, #0
10043a84:	d002      	beq.n	10043a8c <HAL_RCCEx_GetPeriphCLKFreq+0x54>
          frequency = HSE_VALUE;
10043a86:	4b34      	ldr	r3, [pc, #208]	@ (10043b58 <HAL_RCCEx_GetPeriphCLKFreq+0x120>)
10043a88:	617b      	str	r3, [r7, #20]
10043a8a:	e001      	b.n	10043a90 <HAL_RCCEx_GetPeriphCLKFreq+0x58>
          frequency = RC64MPLL_VALUE;
10043a8c:	4b33      	ldr	r3, [pc, #204]	@ (10043b5c <HAL_RCCEx_GetPeriphCLKFreq+0x124>)
10043a8e:	617b      	str	r3, [r7, #20]
        krmValue = __HAL_RCC_GET_KRM_RATE_MULTIPLIER();
10043a90:	f7ff ff4c 	bl	1004392c <LL_RCC_KRM_GetRateMultiplier>
10043a94:	0003      	movs	r3, r0
10043a96:	613b      	str	r3, [r7, #16]
        if (krmValue < 8)
10043a98:	693b      	ldr	r3, [r7, #16]
10043a9a:	2b07      	cmp	r3, #7
10043a9c:	d801      	bhi.n	10043aa2 <HAL_RCCEx_GetPeriphCLKFreq+0x6a>
          krmValue = 8;
10043a9e:	2308      	movs	r3, #8
10043aa0:	613b      	str	r3, [r7, #16]
        frequency = frequency / krmValue;
10043aa2:	6939      	ldr	r1, [r7, #16]
10043aa4:	6978      	ldr	r0, [r7, #20]
10043aa6:	f7fc fb15 	bl	100400d4 <__udivsi3>
10043aaa:	0003      	movs	r3, r0
10043aac:	617b      	str	r3, [r7, #20]
      break;
10043aae:	e04b      	b.n	10043b48 <HAL_RCCEx_GetPeriphCLKFreq+0x110>
        switch (__HAL_RCC_GET_SMPS_DIV())
10043ab0:	f7ff ff0a 	bl	100438c8 <LL_RCC_GetSMPSPrescaler>
10043ab4:	1e03      	subs	r3, r0, #0
10043ab6:	d004      	beq.n	10043ac2 <HAL_RCCEx_GetPeriphCLKFreq+0x8a>
10043ab8:	2280      	movs	r2, #128	@ 0x80
10043aba:	0152      	lsls	r2, r2, #5
10043abc:	4293      	cmp	r3, r2
10043abe:	d003      	beq.n	10043ac8 <HAL_RCCEx_GetPeriphCLKFreq+0x90>
      break;
10043ac0:	e042      	b.n	10043b48 <HAL_RCCEx_GetPeriphCLKFreq+0x110>
            frequency = RC64MPLL_VALUE / 8;
10043ac2:	4b27      	ldr	r3, [pc, #156]	@ (10043b60 <HAL_RCCEx_GetPeriphCLKFreq+0x128>)
10043ac4:	617b      	str	r3, [r7, #20]
            break;
10043ac6:	e002      	b.n	10043ace <HAL_RCCEx_GetPeriphCLKFreq+0x96>
            frequency = RC64MPLL_VALUE / 16;
10043ac8:	4b26      	ldr	r3, [pc, #152]	@ (10043b64 <HAL_RCCEx_GetPeriphCLKFreq+0x12c>)
10043aca:	617b      	str	r3, [r7, #20]
            break;
10043acc:	46c0      	nop			@ (mov r8, r8)
      break;
10043ace:	e03b      	b.n	10043b48 <HAL_RCCEx_GetPeriphCLKFreq+0x110>
      spiFreqValue = __HAL_RCC_GET_SPI3I2S_CLK_CONFIG();
10043ad0:	f7ff ff70 	bl	100439b4 <LL_RCC_GetSPI3I2SClockSource>
10043ad4:	0003      	movs	r3, r0
10043ad6:	60fb      	str	r3, [r7, #12]
      switch (spiFreqValue)
10043ad8:	68fa      	ldr	r2, [r7, #12]
10043ada:	2380      	movs	r3, #128	@ 0x80
10043adc:	041b      	lsls	r3, r3, #16
10043ade:	429a      	cmp	r2, r3
10043ae0:	d01a      	beq.n	10043b18 <HAL_RCCEx_GetPeriphCLKFreq+0xe0>
10043ae2:	68fa      	ldr	r2, [r7, #12]
10043ae4:	2380      	movs	r3, #128	@ 0x80
10043ae6:	041b      	lsls	r3, r3, #16
10043ae8:	429a      	cmp	r2, r3
10043aea:	d82c      	bhi.n	10043b46 <HAL_RCCEx_GetPeriphCLKFreq+0x10e>
10043aec:	68fb      	ldr	r3, [r7, #12]
10043aee:	2b00      	cmp	r3, #0
10043af0:	d005      	beq.n	10043afe <HAL_RCCEx_GetPeriphCLKFreq+0xc6>
10043af2:	68fa      	ldr	r2, [r7, #12]
10043af4:	2380      	movs	r3, #128	@ 0x80
10043af6:	03db      	lsls	r3, r3, #15
10043af8:	429a      	cmp	r2, r3
10043afa:	d003      	beq.n	10043b04 <HAL_RCCEx_GetPeriphCLKFreq+0xcc>
      break;
10043afc:	e023      	b.n	10043b46 <HAL_RCCEx_GetPeriphCLKFreq+0x10e>
          frequency = RC64MPLL_VALUE / 4;
10043afe:	4b15      	ldr	r3, [pc, #84]	@ (10043b54 <HAL_RCCEx_GetPeriphCLKFreq+0x11c>)
10043b00:	617b      	str	r3, [r7, #20]
          break;
10043b02:	e00e      	b.n	10043b22 <HAL_RCCEx_GetPeriphCLKFreq+0xea>
          if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_DIRECT_HSE)
10043b04:	f7ff fea4 	bl	10043850 <LL_RCC_DIRECT_HSE_IsEnabled>
10043b08:	1e03      	subs	r3, r0, #0
10043b0a:	d002      	beq.n	10043b12 <HAL_RCCEx_GetPeriphCLKFreq+0xda>
            frequency = HSE_VALUE / 2;
10043b0c:	4b16      	ldr	r3, [pc, #88]	@ (10043b68 <HAL_RCCEx_GetPeriphCLKFreq+0x130>)
10043b0e:	617b      	str	r3, [r7, #20]
          break;
10043b10:	e007      	b.n	10043b22 <HAL_RCCEx_GetPeriphCLKFreq+0xea>
            frequency = RC64MPLL_VALUE / 2;
10043b12:	4b16      	ldr	r3, [pc, #88]	@ (10043b6c <HAL_RCCEx_GetPeriphCLKFreq+0x134>)
10043b14:	617b      	str	r3, [r7, #20]
          break;
10043b16:	e004      	b.n	10043b22 <HAL_RCCEx_GetPeriphCLKFreq+0xea>
          frequency = HAL_RCC_GetSysClockFreq() ;
10043b18:	f7ff fe90 	bl	1004383c <HAL_RCC_GetSysClockFreq>
10043b1c:	0003      	movs	r3, r0
10043b1e:	617b      	str	r3, [r7, #20]
          break;
10043b20:	46c0      	nop			@ (mov r8, r8)
      break;
10043b22:	e010      	b.n	10043b46 <HAL_RCCEx_GetPeriphCLKFreq+0x10e>
      switch (__HAL_RCC_GET_LPUART1_CLK_CONFIG())
10043b24:	f7ff ff24 	bl	10043970 <LL_RCC_GetLPUARTClockSource>
10043b28:	0002      	movs	r2, r0
10043b2a:	2380      	movs	r3, #128	@ 0x80
10043b2c:	019b      	lsls	r3, r3, #6
10043b2e:	429a      	cmp	r2, r3
10043b30:	d103      	bne.n	10043b3a <HAL_RCCEx_GetPeriphCLKFreq+0x102>
          frequency = LSE_VALUE;
10043b32:	2380      	movs	r3, #128	@ 0x80
10043b34:	021b      	lsls	r3, r3, #8
10043b36:	617b      	str	r3, [r7, #20]
          break;
10043b38:	e002      	b.n	10043b40 <HAL_RCCEx_GetPeriphCLKFreq+0x108>
          frequency = HSE_VALUE / 2;
10043b3a:	4b0b      	ldr	r3, [pc, #44]	@ (10043b68 <HAL_RCCEx_GetPeriphCLKFreq+0x130>)
10043b3c:	617b      	str	r3, [r7, #20]
          break;
10043b3e:	46c0      	nop			@ (mov r8, r8)
      break;
10043b40:	e002      	b.n	10043b48 <HAL_RCCEx_GetPeriphCLKFreq+0x110>
      break;
10043b42:	46c0      	nop			@ (mov r8, r8)
10043b44:	e000      	b.n	10043b48 <HAL_RCCEx_GetPeriphCLKFreq+0x110>
      break;
10043b46:	46c0      	nop			@ (mov r8, r8)
  }
  return (frequency);
10043b48:	697b      	ldr	r3, [r7, #20]
}
10043b4a:	0018      	movs	r0, r3
10043b4c:	46bd      	mov	sp, r7
10043b4e:	b006      	add	sp, #24
10043b50:	bd80      	pop	{r7, pc}
10043b52:	46c0      	nop			@ (mov r8, r8)
10043b54:	00f42400 	.word	0x00f42400
10043b58:	02dc6c00 	.word	0x02dc6c00
10043b5c:	03d09000 	.word	0x03d09000
10043b60:	007a1200 	.word	0x007a1200
10043b64:	003d0900 	.word	0x003d0900
10043b68:	016e3600 	.word	0x016e3600
10043b6c:	01e84800 	.word	0x01e84800

10043b70 <HAL_UART_Init>:
  *        parameters in the UART_InitTypeDef and initialize the associated handle.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
10043b70:	b580      	push	{r7, lr}
10043b72:	b082      	sub	sp, #8
10043b74:	af00      	add	r7, sp, #0
10043b76:	6078      	str	r0, [r7, #4]
  /* Check the UART handle allocation */
  if (huart == NULL)
10043b78:	687b      	ldr	r3, [r7, #4]
10043b7a:	2b00      	cmp	r3, #0
10043b7c:	d101      	bne.n	10043b82 <HAL_UART_Init+0x12>
  {
    return HAL_ERROR;
10043b7e:	2301      	movs	r3, #1
10043b80:	e046      	b.n	10043c10 <HAL_UART_Init+0xa0>
  {
    /* Check the parameters */
    assert_param((IS_UART_INSTANCE(huart->Instance)) || (IS_LPUART_INSTANCE(huart->Instance)));
  }

  if (huart->gState == HAL_UART_STATE_RESET)
10043b82:	687b      	ldr	r3, [r7, #4]
10043b84:	2288      	movs	r2, #136	@ 0x88
10043b86:	589b      	ldr	r3, [r3, r2]
10043b88:	2b00      	cmp	r3, #0
10043b8a:	d107      	bne.n	10043b9c <HAL_UART_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
10043b8c:	687b      	ldr	r3, [r7, #4]
10043b8e:	2284      	movs	r2, #132	@ 0x84
10043b90:	2100      	movs	r1, #0
10043b92:	5499      	strb	r1, [r3, r2]

    /* Init the low level hardware */
    huart->MspInitCallback(huart);
#else
    /* Init the low level hardware : GPIO, CLOCK */
    HAL_UART_MspInit(huart);
10043b94:	687b      	ldr	r3, [r7, #4]
10043b96:	0018      	movs	r0, r3
10043b98:	f000 f840 	bl	10043c1c <HAL_UART_MspInit>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
  }

  huart->gState = HAL_UART_STATE_BUSY;
10043b9c:	687b      	ldr	r3, [r7, #4]
10043b9e:	2288      	movs	r2, #136	@ 0x88
10043ba0:	2124      	movs	r1, #36	@ 0x24
10043ba2:	5099      	str	r1, [r3, r2]

  __HAL_UART_DISABLE(huart);
10043ba4:	687b      	ldr	r3, [r7, #4]
10043ba6:	681b      	ldr	r3, [r3, #0]
10043ba8:	681a      	ldr	r2, [r3, #0]
10043baa:	687b      	ldr	r3, [r7, #4]
10043bac:	681b      	ldr	r3, [r3, #0]
10043bae:	2101      	movs	r1, #1
10043bb0:	438a      	bics	r2, r1
10043bb2:	601a      	str	r2, [r3, #0]

  /* Perform advanced settings configuration */
  /* For some items, configuration requires to be done prior TE and RE bits are set */
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
10043bb4:	687b      	ldr	r3, [r7, #4]
10043bb6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
10043bb8:	2b00      	cmp	r3, #0
10043bba:	d003      	beq.n	10043bc4 <HAL_UART_Init+0x54>
  {
    UART_AdvFeatureConfig(huart);
10043bbc:	687b      	ldr	r3, [r7, #4]
10043bbe:	0018      	movs	r0, r3
10043bc0:	f000 fa4a 	bl	10044058 <UART_AdvFeatureConfig>
  }

  /* Set the UART Communication parameters */
  if (UART_SetConfig(huart) == HAL_ERROR)
10043bc4:	687b      	ldr	r3, [r7, #4]
10043bc6:	0018      	movs	r0, r3
10043bc8:	f000 f8de 	bl	10043d88 <UART_SetConfig>
10043bcc:	0003      	movs	r3, r0
10043bce:	2b01      	cmp	r3, #1
10043bd0:	d101      	bne.n	10043bd6 <HAL_UART_Init+0x66>
  {
    return HAL_ERROR;
10043bd2:	2301      	movs	r3, #1
10043bd4:	e01c      	b.n	10043c10 <HAL_UART_Init+0xa0>
  }

  /* In asynchronous mode, the following bits must be kept cleared:
  - LINEN and CLKEN bits in the USART_CR2 register,
  - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
10043bd6:	687b      	ldr	r3, [r7, #4]
10043bd8:	681b      	ldr	r3, [r3, #0]
10043bda:	685a      	ldr	r2, [r3, #4]
10043bdc:	687b      	ldr	r3, [r7, #4]
10043bde:	681b      	ldr	r3, [r3, #0]
10043be0:	490d      	ldr	r1, [pc, #52]	@ (10043c18 <HAL_UART_Init+0xa8>)
10043be2:	400a      	ands	r2, r1
10043be4:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
10043be6:	687b      	ldr	r3, [r7, #4]
10043be8:	681b      	ldr	r3, [r3, #0]
10043bea:	689a      	ldr	r2, [r3, #8]
10043bec:	687b      	ldr	r3, [r7, #4]
10043bee:	681b      	ldr	r3, [r3, #0]
10043bf0:	212a      	movs	r1, #42	@ 0x2a
10043bf2:	438a      	bics	r2, r1
10043bf4:	609a      	str	r2, [r3, #8]

  __HAL_UART_ENABLE(huart);
10043bf6:	687b      	ldr	r3, [r7, #4]
10043bf8:	681b      	ldr	r3, [r3, #0]
10043bfa:	681a      	ldr	r2, [r3, #0]
10043bfc:	687b      	ldr	r3, [r7, #4]
10043bfe:	681b      	ldr	r3, [r3, #0]
10043c00:	2101      	movs	r1, #1
10043c02:	430a      	orrs	r2, r1
10043c04:	601a      	str	r2, [r3, #0]

  /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
  return (UART_CheckIdleState(huart));
10043c06:	687b      	ldr	r3, [r7, #4]
10043c08:	0018      	movs	r0, r3
10043c0a:	f000 fad9 	bl	100441c0 <UART_CheckIdleState>
10043c0e:	0003      	movs	r3, r0
}
10043c10:	0018      	movs	r0, r3
10043c12:	46bd      	mov	sp, r7
10043c14:	b002      	add	sp, #8
10043c16:	bd80      	pop	{r7, pc}
10043c18:	ffffb7ff 	.word	0xffffb7ff

10043c1c <HAL_UART_MspInit>:
  * @brief Initialize the UART MSP.
  * @param huart UART handle.
  * @retval None
  */
__weak void HAL_UART_MspInit(UART_HandleTypeDef *huart)
{
10043c1c:	b580      	push	{r7, lr}
10043c1e:	b082      	sub	sp, #8
10043c20:	af00      	add	r7, sp, #0
10043c22:	6078      	str	r0, [r7, #4]
  UNUSED(huart);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UART_MspInit can be implemented in the user file
   */
}
10043c24:	46c0      	nop			@ (mov r8, r8)
10043c26:	46bd      	mov	sp, r7
10043c28:	b002      	add	sp, #8
10043c2a:	bd80      	pop	{r7, pc}

10043c2c <HAL_UART_Transmit>:
  * @param Size    Amount of data elements (u8 or u16) to be sent.
  * @param Timeout Timeout duration.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
10043c2c:	b580      	push	{r7, lr}
10043c2e:	b08a      	sub	sp, #40	@ 0x28
10043c30:	af02      	add	r7, sp, #8
10043c32:	60f8      	str	r0, [r7, #12]
10043c34:	60b9      	str	r1, [r7, #8]
10043c36:	603b      	str	r3, [r7, #0]
10043c38:	1dbb      	adds	r3, r7, #6
10043c3a:	801a      	strh	r2, [r3, #0]
  const uint8_t  *pdata8bits;
  const uint16_t *pdata16bits;
  uint32_t tickstart;

  /* Check that a Tx process is not already ongoing */
  if (huart->gState == HAL_UART_STATE_READY)
10043c3c:	68fb      	ldr	r3, [r7, #12]
10043c3e:	2288      	movs	r2, #136	@ 0x88
10043c40:	589b      	ldr	r3, [r3, r2]
10043c42:	2b20      	cmp	r3, #32
10043c44:	d000      	beq.n	10043c48 <HAL_UART_Transmit+0x1c>
10043c46:	e09a      	b.n	10043d7e <HAL_UART_Transmit+0x152>
  {
    if ((pData == NULL) || (Size == 0U))
10043c48:	68bb      	ldr	r3, [r7, #8]
10043c4a:	2b00      	cmp	r3, #0
10043c4c:	d003      	beq.n	10043c56 <HAL_UART_Transmit+0x2a>
10043c4e:	1dbb      	adds	r3, r7, #6
10043c50:	881b      	ldrh	r3, [r3, #0]
10043c52:	2b00      	cmp	r3, #0
10043c54:	d101      	bne.n	10043c5a <HAL_UART_Transmit+0x2e>
    {
      return  HAL_ERROR;
10043c56:	2301      	movs	r3, #1
10043c58:	e092      	b.n	10043d80 <HAL_UART_Transmit+0x154>
    }

    /* In case of 9bits/No Parity transfer, pData buffer provided as input parameter
       should be aligned on a u16 frontier, as data to be filled into TDR will be
       handled through a u16 cast. */
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
10043c5a:	68fb      	ldr	r3, [r7, #12]
10043c5c:	689a      	ldr	r2, [r3, #8]
10043c5e:	2380      	movs	r3, #128	@ 0x80
10043c60:	015b      	lsls	r3, r3, #5
10043c62:	429a      	cmp	r2, r3
10043c64:	d109      	bne.n	10043c7a <HAL_UART_Transmit+0x4e>
10043c66:	68fb      	ldr	r3, [r7, #12]
10043c68:	691b      	ldr	r3, [r3, #16]
10043c6a:	2b00      	cmp	r3, #0
10043c6c:	d105      	bne.n	10043c7a <HAL_UART_Transmit+0x4e>
    {
      if ((((uint32_t)pData) & 1U) != 0U)
10043c6e:	68bb      	ldr	r3, [r7, #8]
10043c70:	2201      	movs	r2, #1
10043c72:	4013      	ands	r3, r2
10043c74:	d001      	beq.n	10043c7a <HAL_UART_Transmit+0x4e>
      {
        return  HAL_ERROR;
10043c76:	2301      	movs	r3, #1
10043c78:	e082      	b.n	10043d80 <HAL_UART_Transmit+0x154>
      }
    }

    huart->ErrorCode = HAL_UART_ERROR_NONE;
10043c7a:	68fb      	ldr	r3, [r7, #12]
10043c7c:	2290      	movs	r2, #144	@ 0x90
10043c7e:	2100      	movs	r1, #0
10043c80:	5099      	str	r1, [r3, r2]
    huart->gState = HAL_UART_STATE_BUSY_TX;
10043c82:	68fb      	ldr	r3, [r7, #12]
10043c84:	2288      	movs	r2, #136	@ 0x88
10043c86:	2121      	movs	r1, #33	@ 0x21
10043c88:	5099      	str	r1, [r3, r2]

    /* Init tickstart for timeout management */
    tickstart = HAL_GetTick();
10043c8a:	f7fd fc8d 	bl	100415a8 <HAL_GetTick>
10043c8e:	0003      	movs	r3, r0
10043c90:	617b      	str	r3, [r7, #20]

    huart->TxXferSize  = Size;
10043c92:	68fb      	ldr	r3, [r7, #12]
10043c94:	1dba      	adds	r2, r7, #6
10043c96:	2154      	movs	r1, #84	@ 0x54
10043c98:	8812      	ldrh	r2, [r2, #0]
10043c9a:	525a      	strh	r2, [r3, r1]
    huart->TxXferCount = Size;
10043c9c:	68fb      	ldr	r3, [r7, #12]
10043c9e:	1dba      	adds	r2, r7, #6
10043ca0:	2156      	movs	r1, #86	@ 0x56
10043ca2:	8812      	ldrh	r2, [r2, #0]
10043ca4:	525a      	strh	r2, [r3, r1]

    /* In case of 9bits/No Parity transfer, pData needs to be handled as a uint16_t pointer */
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
10043ca6:	68fb      	ldr	r3, [r7, #12]
10043ca8:	689a      	ldr	r2, [r3, #8]
10043caa:	2380      	movs	r3, #128	@ 0x80
10043cac:	015b      	lsls	r3, r3, #5
10043cae:	429a      	cmp	r2, r3
10043cb0:	d108      	bne.n	10043cc4 <HAL_UART_Transmit+0x98>
10043cb2:	68fb      	ldr	r3, [r7, #12]
10043cb4:	691b      	ldr	r3, [r3, #16]
10043cb6:	2b00      	cmp	r3, #0
10043cb8:	d104      	bne.n	10043cc4 <HAL_UART_Transmit+0x98>
    {
      pdata8bits  = NULL;
10043cba:	2300      	movs	r3, #0
10043cbc:	61fb      	str	r3, [r7, #28]
      pdata16bits = (const uint16_t *) pData;
10043cbe:	68bb      	ldr	r3, [r7, #8]
10043cc0:	61bb      	str	r3, [r7, #24]
10043cc2:	e003      	b.n	10043ccc <HAL_UART_Transmit+0xa0>
    }
    else
    {
      pdata8bits  = pData;
10043cc4:	68bb      	ldr	r3, [r7, #8]
10043cc6:	61fb      	str	r3, [r7, #28]
      pdata16bits = NULL;
10043cc8:	2300      	movs	r3, #0
10043cca:	61bb      	str	r3, [r7, #24]
    }

    while (huart->TxXferCount > 0U)
10043ccc:	e03a      	b.n	10043d44 <HAL_UART_Transmit+0x118>
    {
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
10043cce:	697a      	ldr	r2, [r7, #20]
10043cd0:	68f8      	ldr	r0, [r7, #12]
10043cd2:	683b      	ldr	r3, [r7, #0]
10043cd4:	9300      	str	r3, [sp, #0]
10043cd6:	0013      	movs	r3, r2
10043cd8:	2200      	movs	r2, #0
10043cda:	2180      	movs	r1, #128	@ 0x80
10043cdc:	f000 fb1a 	bl	10044314 <UART_WaitOnFlagUntilTimeout>
10043ce0:	1e03      	subs	r3, r0, #0
10043ce2:	d005      	beq.n	10043cf0 <HAL_UART_Transmit+0xc4>
      {

        huart->gState = HAL_UART_STATE_READY;
10043ce4:	68fb      	ldr	r3, [r7, #12]
10043ce6:	2288      	movs	r2, #136	@ 0x88
10043ce8:	2120      	movs	r1, #32
10043cea:	5099      	str	r1, [r3, r2]

        return HAL_TIMEOUT;
10043cec:	2303      	movs	r3, #3
10043cee:	e047      	b.n	10043d80 <HAL_UART_Transmit+0x154>
      }
      if (pdata8bits == NULL)
10043cf0:	69fb      	ldr	r3, [r7, #28]
10043cf2:	2b00      	cmp	r3, #0
10043cf4:	d10b      	bne.n	10043d0e <HAL_UART_Transmit+0xe2>
      {
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
10043cf6:	69bb      	ldr	r3, [r7, #24]
10043cf8:	881b      	ldrh	r3, [r3, #0]
10043cfa:	001a      	movs	r2, r3
10043cfc:	68fb      	ldr	r3, [r7, #12]
10043cfe:	681b      	ldr	r3, [r3, #0]
10043d00:	05d2      	lsls	r2, r2, #23
10043d02:	0dd2      	lsrs	r2, r2, #23
10043d04:	629a      	str	r2, [r3, #40]	@ 0x28
        pdata16bits++;
10043d06:	69bb      	ldr	r3, [r7, #24]
10043d08:	3302      	adds	r3, #2
10043d0a:	61bb      	str	r3, [r7, #24]
10043d0c:	e007      	b.n	10043d1e <HAL_UART_Transmit+0xf2>
      }
      else
      {
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
10043d0e:	69fb      	ldr	r3, [r7, #28]
10043d10:	781a      	ldrb	r2, [r3, #0]
10043d12:	68fb      	ldr	r3, [r7, #12]
10043d14:	681b      	ldr	r3, [r3, #0]
10043d16:	629a      	str	r2, [r3, #40]	@ 0x28
        pdata8bits++;
10043d18:	69fb      	ldr	r3, [r7, #28]
10043d1a:	3301      	adds	r3, #1
10043d1c:	61fb      	str	r3, [r7, #28]
      }
      if ((huart->gState & HAL_UART_STATE_BUSY_TX) == HAL_UART_STATE_BUSY_TX)
10043d1e:	68fb      	ldr	r3, [r7, #12]
10043d20:	2288      	movs	r2, #136	@ 0x88
10043d22:	589b      	ldr	r3, [r3, r2]
10043d24:	2221      	movs	r2, #33	@ 0x21
10043d26:	4013      	ands	r3, r2
10043d28:	2b21      	cmp	r3, #33	@ 0x21
10043d2a:	d109      	bne.n	10043d40 <HAL_UART_Transmit+0x114>
      {
        huart->TxXferCount--;
10043d2c:	68fb      	ldr	r3, [r7, #12]
10043d2e:	2256      	movs	r2, #86	@ 0x56
10043d30:	5a9b      	ldrh	r3, [r3, r2]
10043d32:	b29b      	uxth	r3, r3
10043d34:	3b01      	subs	r3, #1
10043d36:	b299      	uxth	r1, r3
10043d38:	68fb      	ldr	r3, [r7, #12]
10043d3a:	2256      	movs	r2, #86	@ 0x56
10043d3c:	5299      	strh	r1, [r3, r2]
10043d3e:	e001      	b.n	10043d44 <HAL_UART_Transmit+0x118>
      }
      else
      {
        /* Process was aborted during the transmission */
        return HAL_ERROR;
10043d40:	2301      	movs	r3, #1
10043d42:	e01d      	b.n	10043d80 <HAL_UART_Transmit+0x154>
    while (huart->TxXferCount > 0U)
10043d44:	68fb      	ldr	r3, [r7, #12]
10043d46:	2256      	movs	r2, #86	@ 0x56
10043d48:	5a9b      	ldrh	r3, [r3, r2]
10043d4a:	b29b      	uxth	r3, r3
10043d4c:	2b00      	cmp	r3, #0
10043d4e:	d1be      	bne.n	10043cce <HAL_UART_Transmit+0xa2>
      }
    }

    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
10043d50:	697a      	ldr	r2, [r7, #20]
10043d52:	68f8      	ldr	r0, [r7, #12]
10043d54:	683b      	ldr	r3, [r7, #0]
10043d56:	9300      	str	r3, [sp, #0]
10043d58:	0013      	movs	r3, r2
10043d5a:	2200      	movs	r2, #0
10043d5c:	2140      	movs	r1, #64	@ 0x40
10043d5e:	f000 fad9 	bl	10044314 <UART_WaitOnFlagUntilTimeout>
10043d62:	1e03      	subs	r3, r0, #0
10043d64:	d005      	beq.n	10043d72 <HAL_UART_Transmit+0x146>
    {
      huart->gState = HAL_UART_STATE_READY;
10043d66:	68fb      	ldr	r3, [r7, #12]
10043d68:	2288      	movs	r2, #136	@ 0x88
10043d6a:	2120      	movs	r1, #32
10043d6c:	5099      	str	r1, [r3, r2]

      return HAL_TIMEOUT;
10043d6e:	2303      	movs	r3, #3
10043d70:	e006      	b.n	10043d80 <HAL_UART_Transmit+0x154>
    }

    /* At end of Tx process, restore huart->gState to Ready */
    huart->gState = HAL_UART_STATE_READY;
10043d72:	68fb      	ldr	r3, [r7, #12]
10043d74:	2288      	movs	r2, #136	@ 0x88
10043d76:	2120      	movs	r1, #32
10043d78:	5099      	str	r1, [r3, r2]

    return HAL_OK;
10043d7a:	2300      	movs	r3, #0
10043d7c:	e000      	b.n	10043d80 <HAL_UART_Transmit+0x154>
  }
  else
  {
    return HAL_BUSY;
10043d7e:	2302      	movs	r3, #2
  }
}
10043d80:	0018      	movs	r0, r3
10043d82:	46bd      	mov	sp, r7
10043d84:	b008      	add	sp, #32
10043d86:	bd80      	pop	{r7, pc}

10043d88 <UART_SetConfig>:
  * @brief Configure the UART peripheral.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
10043d88:	b5b0      	push	{r4, r5, r7, lr}
10043d8a:	b090      	sub	sp, #64	@ 0x40
10043d8c:	af00      	add	r7, sp, #0
10043d8e:	6278      	str	r0, [r7, #36]	@ 0x24
  uint32_t tmpreg;
  uint16_t brrtemp;
  uint32_t usartdiv;
  HAL_StatusTypeDef ret               = HAL_OK;
10043d90:	231b      	movs	r3, #27
10043d92:	2220      	movs	r2, #32
10043d94:	189b      	adds	r3, r3, r2
10043d96:	19db      	adds	r3, r3, r7
10043d98:	2200      	movs	r2, #0
10043d9a:	701a      	strb	r2, [r3, #0]
  *  the UART Word Length, Parity, Mode and oversampling:
  *  set the M bits according to huart->Init.WordLength value
  *  set PCE and PS bits according to huart->Init.Parity value
  *  set TE and RE bits according to huart->Init.Mode value
  *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
10043d9c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10043d9e:	689a      	ldr	r2, [r3, #8]
10043da0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10043da2:	691b      	ldr	r3, [r3, #16]
10043da4:	431a      	orrs	r2, r3
10043da6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10043da8:	695b      	ldr	r3, [r3, #20]
10043daa:	431a      	orrs	r2, r3
10043dac:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10043dae:	69db      	ldr	r3, [r3, #28]
10043db0:	4313      	orrs	r3, r2
10043db2:	63fb      	str	r3, [r7, #60]	@ 0x3c
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
10043db4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10043db6:	681b      	ldr	r3, [r3, #0]
10043db8:	681b      	ldr	r3, [r3, #0]
10043dba:	4aa1      	ldr	r2, [pc, #644]	@ (10044040 <UART_SetConfig+0x2b8>)
10043dbc:	4013      	ands	r3, r2
10043dbe:	0019      	movs	r1, r3
10043dc0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10043dc2:	681a      	ldr	r2, [r3, #0]
10043dc4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
10043dc6:	430b      	orrs	r3, r1
10043dc8:	6013      	str	r3, [r2, #0]

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according
  * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
10043dca:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10043dcc:	681b      	ldr	r3, [r3, #0]
10043dce:	685b      	ldr	r3, [r3, #4]
10043dd0:	4a9c      	ldr	r2, [pc, #624]	@ (10044044 <UART_SetConfig+0x2bc>)
10043dd2:	4013      	ands	r3, r2
10043dd4:	0018      	movs	r0, r3
10043dd6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10043dd8:	68d9      	ldr	r1, [r3, #12]
10043dda:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10043ddc:	681a      	ldr	r2, [r3, #0]
10043dde:	0003      	movs	r3, r0
10043de0:	430b      	orrs	r3, r1
10043de2:	6053      	str	r3, [r2, #4]
  /* Configure
  * - UART HardWare Flow Control: set CTSE and RTSE bits according
  *   to huart->Init.HwFlowCtl value
  * - one-bit sampling method versus three samples' majority rule according
  *   to huart->Init.OneBitSampling (not applicable to LPUART) */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
10043de4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10043de6:	699b      	ldr	r3, [r3, #24]
10043de8:	63fb      	str	r3, [r7, #60]	@ 0x3c

  if (!(UART_INSTANCE_LOWPOWER(huart)))
10043dea:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10043dec:	681b      	ldr	r3, [r3, #0]
10043dee:	4a96      	ldr	r2, [pc, #600]	@ (10044048 <UART_SetConfig+0x2c0>)
10043df0:	4293      	cmp	r3, r2
10043df2:	d004      	beq.n	10043dfe <UART_SetConfig+0x76>
  {
    tmpreg |= huart->Init.OneBitSampling;
10043df4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10043df6:	6a1b      	ldr	r3, [r3, #32]
10043df8:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
10043dfa:	4313      	orrs	r3, r2
10043dfc:	63fb      	str	r3, [r7, #60]	@ 0x3c
  }
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
10043dfe:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10043e00:	681b      	ldr	r3, [r3, #0]
10043e02:	689b      	ldr	r3, [r3, #8]
10043e04:	4a91      	ldr	r2, [pc, #580]	@ (1004404c <UART_SetConfig+0x2c4>)
10043e06:	4013      	ands	r3, r2
10043e08:	0019      	movs	r1, r3
10043e0a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10043e0c:	681a      	ldr	r2, [r3, #0]
10043e0e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
10043e10:	430b      	orrs	r3, r1
10043e12:	6093      	str	r3, [r2, #8]

  /*-------------------------- USART PRESC Configuration -----------------------*/
  /* Configure
  * - UART Clock Prescaler : set PRESCALER according to huart->Init.ClockPrescaler value */
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
10043e14:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10043e16:	681b      	ldr	r3, [r3, #0]
10043e18:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
10043e1a:	220f      	movs	r2, #15
10043e1c:	4393      	bics	r3, r2
10043e1e:	0018      	movs	r0, r3
10043e20:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10043e22:	6a59      	ldr	r1, [r3, #36]	@ 0x24
10043e24:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10043e26:	681a      	ldr	r2, [r3, #0]
10043e28:	0003      	movs	r3, r0
10043e2a:	430b      	orrs	r3, r1
10043e2c:	62d3      	str	r3, [r2, #44]	@ 0x2c

  /*-------------------------- USART BRR Configuration -----------------------*/
  /* Check LPUART instance */
  if (UART_INSTANCE_LOWPOWER(huart))
10043e2e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10043e30:	681b      	ldr	r3, [r3, #0]
10043e32:	4a85      	ldr	r2, [pc, #532]	@ (10044048 <UART_SetConfig+0x2c0>)
10043e34:	4293      	cmp	r3, r2
10043e36:	d16d      	bne.n	10043f14 <UART_SetConfig+0x18c>
  {
    /* Retrieve frequency clock */
    pclk = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_LPUART1);
10043e38:	2010      	movs	r0, #16
10043e3a:	f7ff fdfd 	bl	10043a38 <HAL_RCCEx_GetPeriphCLKFreq>
10043e3e:	0003      	movs	r3, r0
10043e40:	637b      	str	r3, [r7, #52]	@ 0x34

    /* If proper clock source reported */
    if (pclk != 0U)
10043e42:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
10043e44:	2b00      	cmp	r3, #0
10043e46:	d100      	bne.n	10043e4a <UART_SetConfig+0xc2>
10043e48:	e0e3      	b.n	10044012 <UART_SetConfig+0x28a>
    {
      /* Compute clock after Prescaler */
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
10043e4a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10043e4c:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
10043e4e:	4b80      	ldr	r3, [pc, #512]	@ (10044050 <UART_SetConfig+0x2c8>)
10043e50:	0052      	lsls	r2, r2, #1
10043e52:	5ad3      	ldrh	r3, [r2, r3]
10043e54:	0019      	movs	r1, r3
10043e56:	6b78      	ldr	r0, [r7, #52]	@ 0x34
10043e58:	f7fc f93c 	bl	100400d4 <__udivsi3>
10043e5c:	0003      	movs	r3, r0
10043e5e:	62bb      	str	r3, [r7, #40]	@ 0x28

      /* Ensure that Frequency clock is in the range [3 * baudrate, 4096 * baudrate] */
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
10043e60:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10043e62:	685a      	ldr	r2, [r3, #4]
10043e64:	0013      	movs	r3, r2
10043e66:	005b      	lsls	r3, r3, #1
10043e68:	189b      	adds	r3, r3, r2
10043e6a:	6aba      	ldr	r2, [r7, #40]	@ 0x28
10043e6c:	429a      	cmp	r2, r3
10043e6e:	d305      	bcc.n	10043e7c <UART_SetConfig+0xf4>
          (lpuart_ker_ck_pres > (4096U * huart->Init.BaudRate)))
10043e70:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10043e72:	685b      	ldr	r3, [r3, #4]
10043e74:	031b      	lsls	r3, r3, #12
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
10043e76:	6aba      	ldr	r2, [r7, #40]	@ 0x28
10043e78:	429a      	cmp	r2, r3
10043e7a:	d906      	bls.n	10043e8a <UART_SetConfig+0x102>
      {
        ret = HAL_ERROR;
10043e7c:	231b      	movs	r3, #27
10043e7e:	2220      	movs	r2, #32
10043e80:	189b      	adds	r3, r3, r2
10043e82:	19db      	adds	r3, r3, r7
10043e84:	2201      	movs	r2, #1
10043e86:	701a      	strb	r2, [r3, #0]
10043e88:	e0c3      	b.n	10044012 <UART_SetConfig+0x28a>
      }
      else
      {
        /* Check computed UsartDiv value is in allocated range
           (it is forbidden to write values lower than 0x300 in the LPUART_BRR register) */
        usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
10043e8a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
10043e8c:	61bb      	str	r3, [r7, #24]
10043e8e:	2300      	movs	r3, #0
10043e90:	61fb      	str	r3, [r7, #28]
10043e92:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10043e94:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
10043e96:	4b6e      	ldr	r3, [pc, #440]	@ (10044050 <UART_SetConfig+0x2c8>)
10043e98:	0052      	lsls	r2, r2, #1
10043e9a:	5ad3      	ldrh	r3, [r2, r3]
10043e9c:	613b      	str	r3, [r7, #16]
10043e9e:	2300      	movs	r3, #0
10043ea0:	617b      	str	r3, [r7, #20]
10043ea2:	693a      	ldr	r2, [r7, #16]
10043ea4:	697b      	ldr	r3, [r7, #20]
10043ea6:	69b8      	ldr	r0, [r7, #24]
10043ea8:	69f9      	ldr	r1, [r7, #28]
10043eaa:	f7fc fa89 	bl	100403c0 <__aeabi_uldivmod>
10043eae:	0002      	movs	r2, r0
10043eb0:	000b      	movs	r3, r1
10043eb2:	0e11      	lsrs	r1, r2, #24
10043eb4:	021d      	lsls	r5, r3, #8
10043eb6:	430d      	orrs	r5, r1
10043eb8:	0214      	lsls	r4, r2, #8
10043eba:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10043ebc:	685b      	ldr	r3, [r3, #4]
10043ebe:	085b      	lsrs	r3, r3, #1
10043ec0:	60bb      	str	r3, [r7, #8]
10043ec2:	2300      	movs	r3, #0
10043ec4:	60fb      	str	r3, [r7, #12]
10043ec6:	68b8      	ldr	r0, [r7, #8]
10043ec8:	68f9      	ldr	r1, [r7, #12]
10043eca:	1900      	adds	r0, r0, r4
10043ecc:	4169      	adcs	r1, r5
10043ece:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10043ed0:	685b      	ldr	r3, [r3, #4]
10043ed2:	603b      	str	r3, [r7, #0]
10043ed4:	2300      	movs	r3, #0
10043ed6:	607b      	str	r3, [r7, #4]
10043ed8:	683a      	ldr	r2, [r7, #0]
10043eda:	687b      	ldr	r3, [r7, #4]
10043edc:	f7fc fa70 	bl	100403c0 <__aeabi_uldivmod>
10043ee0:	0002      	movs	r2, r0
10043ee2:	000b      	movs	r3, r1
10043ee4:	0013      	movs	r3, r2
10043ee6:	633b      	str	r3, [r7, #48]	@ 0x30
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
10043ee8:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
10043eea:	23c0      	movs	r3, #192	@ 0xc0
10043eec:	009b      	lsls	r3, r3, #2
10043eee:	429a      	cmp	r2, r3
10043ef0:	d309      	bcc.n	10043f06 <UART_SetConfig+0x17e>
10043ef2:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
10043ef4:	2380      	movs	r3, #128	@ 0x80
10043ef6:	035b      	lsls	r3, r3, #13
10043ef8:	429a      	cmp	r2, r3
10043efa:	d204      	bcs.n	10043f06 <UART_SetConfig+0x17e>
        {
          huart->Instance->BRR = usartdiv;
10043efc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10043efe:	681b      	ldr	r3, [r3, #0]
10043f00:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
10043f02:	60da      	str	r2, [r3, #12]
10043f04:	e085      	b.n	10044012 <UART_SetConfig+0x28a>
        }
        else
        {
          ret = HAL_ERROR;
10043f06:	231b      	movs	r3, #27
10043f08:	2220      	movs	r2, #32
10043f0a:	189b      	adds	r3, r3, r2
10043f0c:	19db      	adds	r3, r3, r7
10043f0e:	2201      	movs	r2, #1
10043f10:	701a      	strb	r2, [r3, #0]
10043f12:	e07e      	b.n	10044012 <UART_SetConfig+0x28a>
      } /* if ( (lpuart_ker_ck_pres < (3 * huart->Init.BaudRate) ) ||
                (lpuart_ker_ck_pres > (4096 * huart->Init.BaudRate) )) */
    } /* if (pclk != 0) */
  }
  /* Check UART Over Sampling to set Baud Rate Register */
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
10043f14:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10043f16:	69da      	ldr	r2, [r3, #28]
10043f18:	2380      	movs	r3, #128	@ 0x80
10043f1a:	021b      	lsls	r3, r3, #8
10043f1c:	429a      	cmp	r2, r3
10043f1e:	d148      	bne.n	10043fb2 <UART_SetConfig+0x22a>
  {
    pclk = UART_PERIPHCLK;
10043f20:	4b4c      	ldr	r3, [pc, #304]	@ (10044054 <UART_SetConfig+0x2cc>)
10043f22:	637b      	str	r3, [r7, #52]	@ 0x34

    /* USARTDIV must be greater than or equal to 0d16 */
    if (pclk != 0U)
10043f24:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
10043f26:	2b00      	cmp	r3, #0
10043f28:	d100      	bne.n	10043f2c <UART_SetConfig+0x1a4>
10043f2a:	e072      	b.n	10044012 <UART_SetConfig+0x28a>
    {
      usartdiv = (uint32_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
10043f2c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10043f2e:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
10043f30:	4b47      	ldr	r3, [pc, #284]	@ (10044050 <UART_SetConfig+0x2c8>)
10043f32:	0052      	lsls	r2, r2, #1
10043f34:	5ad3      	ldrh	r3, [r2, r3]
10043f36:	0019      	movs	r1, r3
10043f38:	6b78      	ldr	r0, [r7, #52]	@ 0x34
10043f3a:	f7fc f8cb 	bl	100400d4 <__udivsi3>
10043f3e:	0003      	movs	r3, r0
10043f40:	005a      	lsls	r2, r3, #1
10043f42:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10043f44:	685b      	ldr	r3, [r3, #4]
10043f46:	085b      	lsrs	r3, r3, #1
10043f48:	18d2      	adds	r2, r2, r3
10043f4a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10043f4c:	685b      	ldr	r3, [r3, #4]
10043f4e:	0019      	movs	r1, r3
10043f50:	0010      	movs	r0, r2
10043f52:	f7fc f8bf 	bl	100400d4 <__udivsi3>
10043f56:	0003      	movs	r3, r0
10043f58:	633b      	str	r3, [r7, #48]	@ 0x30
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
10043f5a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
10043f5c:	2b0f      	cmp	r3, #15
10043f5e:	d921      	bls.n	10043fa4 <UART_SetConfig+0x21c>
10043f60:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
10043f62:	2380      	movs	r3, #128	@ 0x80
10043f64:	025b      	lsls	r3, r3, #9
10043f66:	429a      	cmp	r2, r3
10043f68:	d21c      	bcs.n	10043fa4 <UART_SetConfig+0x21c>
      {
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
10043f6a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
10043f6c:	b29a      	uxth	r2, r3
10043f6e:	200e      	movs	r0, #14
10043f70:	2420      	movs	r4, #32
10043f72:	1903      	adds	r3, r0, r4
10043f74:	19db      	adds	r3, r3, r7
10043f76:	210f      	movs	r1, #15
10043f78:	438a      	bics	r2, r1
10043f7a:	801a      	strh	r2, [r3, #0]
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
10043f7c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
10043f7e:	085b      	lsrs	r3, r3, #1
10043f80:	b29b      	uxth	r3, r3
10043f82:	2207      	movs	r2, #7
10043f84:	4013      	ands	r3, r2
10043f86:	b299      	uxth	r1, r3
10043f88:	1903      	adds	r3, r0, r4
10043f8a:	19db      	adds	r3, r3, r7
10043f8c:	1902      	adds	r2, r0, r4
10043f8e:	19d2      	adds	r2, r2, r7
10043f90:	8812      	ldrh	r2, [r2, #0]
10043f92:	430a      	orrs	r2, r1
10043f94:	801a      	strh	r2, [r3, #0]
        huart->Instance->BRR = brrtemp;
10043f96:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10043f98:	681b      	ldr	r3, [r3, #0]
10043f9a:	1902      	adds	r2, r0, r4
10043f9c:	19d2      	adds	r2, r2, r7
10043f9e:	8812      	ldrh	r2, [r2, #0]
10043fa0:	60da      	str	r2, [r3, #12]
10043fa2:	e036      	b.n	10044012 <UART_SetConfig+0x28a>
      }
      else
      {
        ret = HAL_ERROR;
10043fa4:	231b      	movs	r3, #27
10043fa6:	2220      	movs	r2, #32
10043fa8:	189b      	adds	r3, r3, r2
10043faa:	19db      	adds	r3, r3, r7
10043fac:	2201      	movs	r2, #1
10043fae:	701a      	strb	r2, [r3, #0]
10043fb0:	e02f      	b.n	10044012 <UART_SetConfig+0x28a>
      }
    }
  }
  else
  {
    pclk = UART_PERIPHCLK;
10043fb2:	4b28      	ldr	r3, [pc, #160]	@ (10044054 <UART_SetConfig+0x2cc>)
10043fb4:	637b      	str	r3, [r7, #52]	@ 0x34

    if (pclk != 0U)
10043fb6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
10043fb8:	2b00      	cmp	r3, #0
10043fba:	d02a      	beq.n	10044012 <UART_SetConfig+0x28a>
    {
      /* USARTDIV must be greater than or equal to 0d16 */
      usartdiv = (uint32_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
10043fbc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10043fbe:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
10043fc0:	4b23      	ldr	r3, [pc, #140]	@ (10044050 <UART_SetConfig+0x2c8>)
10043fc2:	0052      	lsls	r2, r2, #1
10043fc4:	5ad3      	ldrh	r3, [r2, r3]
10043fc6:	0019      	movs	r1, r3
10043fc8:	6b78      	ldr	r0, [r7, #52]	@ 0x34
10043fca:	f7fc f883 	bl	100400d4 <__udivsi3>
10043fce:	0003      	movs	r3, r0
10043fd0:	001a      	movs	r2, r3
10043fd2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10043fd4:	685b      	ldr	r3, [r3, #4]
10043fd6:	085b      	lsrs	r3, r3, #1
10043fd8:	18d2      	adds	r2, r2, r3
10043fda:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10043fdc:	685b      	ldr	r3, [r3, #4]
10043fde:	0019      	movs	r1, r3
10043fe0:	0010      	movs	r0, r2
10043fe2:	f7fc f877 	bl	100400d4 <__udivsi3>
10043fe6:	0003      	movs	r3, r0
10043fe8:	633b      	str	r3, [r7, #48]	@ 0x30
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
10043fea:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
10043fec:	2b0f      	cmp	r3, #15
10043fee:	d90a      	bls.n	10044006 <UART_SetConfig+0x27e>
10043ff0:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
10043ff2:	2380      	movs	r3, #128	@ 0x80
10043ff4:	025b      	lsls	r3, r3, #9
10043ff6:	429a      	cmp	r2, r3
10043ff8:	d205      	bcs.n	10044006 <UART_SetConfig+0x27e>
      {
        huart->Instance->BRR = (uint16_t)usartdiv;
10043ffa:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
10043ffc:	b29a      	uxth	r2, r3
10043ffe:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10044000:	681b      	ldr	r3, [r3, #0]
10044002:	60da      	str	r2, [r3, #12]
10044004:	e005      	b.n	10044012 <UART_SetConfig+0x28a>
      }
      else
      {
        ret = HAL_ERROR;
10044006:	231b      	movs	r3, #27
10044008:	2220      	movs	r2, #32
1004400a:	189b      	adds	r3, r3, r2
1004400c:	19db      	adds	r3, r3, r7
1004400e:	2201      	movs	r2, #1
10044010:	701a      	strb	r2, [r3, #0]
      }
    }
  }

  /* Initialize the number of data to process during RX/TX ISR execution */
  huart->NbTxDataToProcess = 1;
10044012:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10044014:	226a      	movs	r2, #106	@ 0x6a
10044016:	2101      	movs	r1, #1
10044018:	5299      	strh	r1, [r3, r2]
  huart->NbRxDataToProcess = 1;
1004401a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
1004401c:	2268      	movs	r2, #104	@ 0x68
1004401e:	2101      	movs	r1, #1
10044020:	5299      	strh	r1, [r3, r2]

  /* Clear ISR function pointers */
  huart->RxISR = NULL;
10044022:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10044024:	2200      	movs	r2, #0
10044026:	675a      	str	r2, [r3, #116]	@ 0x74
  huart->TxISR = NULL;
10044028:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
1004402a:	2200      	movs	r2, #0
1004402c:	679a      	str	r2, [r3, #120]	@ 0x78

  return ret;
1004402e:	231b      	movs	r3, #27
10044030:	2220      	movs	r2, #32
10044032:	189b      	adds	r3, r3, r2
10044034:	19db      	adds	r3, r3, r7
10044036:	781b      	ldrb	r3, [r3, #0]
}
10044038:	0018      	movs	r0, r3
1004403a:	46bd      	mov	sp, r7
1004403c:	b010      	add	sp, #64	@ 0x40
1004403e:	bdb0      	pop	{r4, r5, r7, pc}
10044040:	cfff69f3 	.word	0xcfff69f3
10044044:	ffffcfff 	.word	0xffffcfff
10044048:	41005000 	.word	0x41005000
1004404c:	11fff4ff 	.word	0x11fff4ff
10044050:	1004570c 	.word	0x1004570c
10044054:	00f42400 	.word	0x00f42400

10044058 <UART_AdvFeatureConfig>:
  * @brief Configure the UART peripheral advanced features.
  * @param huart UART handle.
  * @retval None
  */
void UART_AdvFeatureConfig(UART_HandleTypeDef *huart)
{
10044058:	b580      	push	{r7, lr}
1004405a:	b082      	sub	sp, #8
1004405c:	af00      	add	r7, sp, #0
1004405e:	6078      	str	r0, [r7, #4]
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure RX/TX pins swap */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
10044060:	687b      	ldr	r3, [r7, #4]
10044062:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
10044064:	2208      	movs	r2, #8
10044066:	4013      	ands	r3, r2
10044068:	d00b      	beq.n	10044082 <UART_AdvFeatureConfig+0x2a>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
1004406a:	687b      	ldr	r3, [r7, #4]
1004406c:	681b      	ldr	r3, [r3, #0]
1004406e:	685b      	ldr	r3, [r3, #4]
10044070:	4a4a      	ldr	r2, [pc, #296]	@ (1004419c <UART_AdvFeatureConfig+0x144>)
10044072:	4013      	ands	r3, r2
10044074:	0019      	movs	r1, r3
10044076:	687b      	ldr	r3, [r7, #4]
10044078:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
1004407a:	687b      	ldr	r3, [r7, #4]
1004407c:	681b      	ldr	r3, [r3, #0]
1004407e:	430a      	orrs	r2, r1
10044080:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure TX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
10044082:	687b      	ldr	r3, [r7, #4]
10044084:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
10044086:	2201      	movs	r2, #1
10044088:	4013      	ands	r3, r2
1004408a:	d00b      	beq.n	100440a4 <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
1004408c:	687b      	ldr	r3, [r7, #4]
1004408e:	681b      	ldr	r3, [r3, #0]
10044090:	685b      	ldr	r3, [r3, #4]
10044092:	4a43      	ldr	r2, [pc, #268]	@ (100441a0 <UART_AdvFeatureConfig+0x148>)
10044094:	4013      	ands	r3, r2
10044096:	0019      	movs	r1, r3
10044098:	687b      	ldr	r3, [r7, #4]
1004409a:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
1004409c:	687b      	ldr	r3, [r7, #4]
1004409e:	681b      	ldr	r3, [r3, #0]
100440a0:	430a      	orrs	r2, r1
100440a2:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
100440a4:	687b      	ldr	r3, [r7, #4]
100440a6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
100440a8:	2202      	movs	r2, #2
100440aa:	4013      	ands	r3, r2
100440ac:	d00b      	beq.n	100440c6 <UART_AdvFeatureConfig+0x6e>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
100440ae:	687b      	ldr	r3, [r7, #4]
100440b0:	681b      	ldr	r3, [r3, #0]
100440b2:	685b      	ldr	r3, [r3, #4]
100440b4:	4a3b      	ldr	r2, [pc, #236]	@ (100441a4 <UART_AdvFeatureConfig+0x14c>)
100440b6:	4013      	ands	r3, r2
100440b8:	0019      	movs	r1, r3
100440ba:	687b      	ldr	r3, [r7, #4]
100440bc:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
100440be:	687b      	ldr	r3, [r7, #4]
100440c0:	681b      	ldr	r3, [r3, #0]
100440c2:	430a      	orrs	r2, r1
100440c4:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure data inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
100440c6:	687b      	ldr	r3, [r7, #4]
100440c8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
100440ca:	2204      	movs	r2, #4
100440cc:	4013      	ands	r3, r2
100440ce:	d00b      	beq.n	100440e8 <UART_AdvFeatureConfig+0x90>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
100440d0:	687b      	ldr	r3, [r7, #4]
100440d2:	681b      	ldr	r3, [r3, #0]
100440d4:	685b      	ldr	r3, [r3, #4]
100440d6:	4a34      	ldr	r2, [pc, #208]	@ (100441a8 <UART_AdvFeatureConfig+0x150>)
100440d8:	4013      	ands	r3, r2
100440da:	0019      	movs	r1, r3
100440dc:	687b      	ldr	r3, [r7, #4]
100440de:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
100440e0:	687b      	ldr	r3, [r7, #4]
100440e2:	681b      	ldr	r3, [r3, #0]
100440e4:	430a      	orrs	r2, r1
100440e6:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
100440e8:	687b      	ldr	r3, [r7, #4]
100440ea:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
100440ec:	2210      	movs	r2, #16
100440ee:	4013      	ands	r3, r2
100440f0:	d00b      	beq.n	1004410a <UART_AdvFeatureConfig+0xb2>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
100440f2:	687b      	ldr	r3, [r7, #4]
100440f4:	681b      	ldr	r3, [r3, #0]
100440f6:	689b      	ldr	r3, [r3, #8]
100440f8:	4a2c      	ldr	r2, [pc, #176]	@ (100441ac <UART_AdvFeatureConfig+0x154>)
100440fa:	4013      	ands	r3, r2
100440fc:	0019      	movs	r1, r3
100440fe:	687b      	ldr	r3, [r7, #4]
10044100:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
10044102:	687b      	ldr	r3, [r7, #4]
10044104:	681b      	ldr	r3, [r3, #0]
10044106:	430a      	orrs	r2, r1
10044108:	609a      	str	r2, [r3, #8]
  }

#if defined(HAL_DMA_MODULE_ENABLED)
  /* if required, configure DMA disabling on reception error */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
1004410a:	687b      	ldr	r3, [r7, #4]
1004410c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
1004410e:	2220      	movs	r2, #32
10044110:	4013      	ands	r3, r2
10044112:	d00b      	beq.n	1004412c <UART_AdvFeatureConfig+0xd4>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
10044114:	687b      	ldr	r3, [r7, #4]
10044116:	681b      	ldr	r3, [r3, #0]
10044118:	689b      	ldr	r3, [r3, #8]
1004411a:	4a25      	ldr	r2, [pc, #148]	@ (100441b0 <UART_AdvFeatureConfig+0x158>)
1004411c:	4013      	ands	r3, r2
1004411e:	0019      	movs	r1, r3
10044120:	687b      	ldr	r3, [r7, #4]
10044122:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
10044124:	687b      	ldr	r3, [r7, #4]
10044126:	681b      	ldr	r3, [r3, #0]
10044128:	430a      	orrs	r2, r1
1004412a:	609a      	str	r2, [r3, #8]
  }
#endif /* HAL_DMA_MODULE_ENABLED */

  /* if required, configure auto Baud rate detection scheme */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
1004412c:	687b      	ldr	r3, [r7, #4]
1004412e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
10044130:	2240      	movs	r2, #64	@ 0x40
10044132:	4013      	ands	r3, r2
10044134:	d01d      	beq.n	10044172 <UART_AdvFeatureConfig+0x11a>
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
10044136:	687b      	ldr	r3, [r7, #4]
10044138:	681b      	ldr	r3, [r3, #0]
1004413a:	685b      	ldr	r3, [r3, #4]
1004413c:	4a1d      	ldr	r2, [pc, #116]	@ (100441b4 <UART_AdvFeatureConfig+0x15c>)
1004413e:	4013      	ands	r3, r2
10044140:	0019      	movs	r1, r3
10044142:	687b      	ldr	r3, [r7, #4]
10044144:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
10044146:	687b      	ldr	r3, [r7, #4]
10044148:	681b      	ldr	r3, [r3, #0]
1004414a:	430a      	orrs	r2, r1
1004414c:	605a      	str	r2, [r3, #4]
    /* set auto Baudrate detection parameters if detection is enabled */
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
1004414e:	687b      	ldr	r3, [r7, #4]
10044150:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
10044152:	2380      	movs	r3, #128	@ 0x80
10044154:	035b      	lsls	r3, r3, #13
10044156:	429a      	cmp	r2, r3
10044158:	d10b      	bne.n	10044172 <UART_AdvFeatureConfig+0x11a>
    {
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
1004415a:	687b      	ldr	r3, [r7, #4]
1004415c:	681b      	ldr	r3, [r3, #0]
1004415e:	685b      	ldr	r3, [r3, #4]
10044160:	4a15      	ldr	r2, [pc, #84]	@ (100441b8 <UART_AdvFeatureConfig+0x160>)
10044162:	4013      	ands	r3, r2
10044164:	0019      	movs	r1, r3
10044166:	687b      	ldr	r3, [r7, #4]
10044168:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
1004416a:	687b      	ldr	r3, [r7, #4]
1004416c:	681b      	ldr	r3, [r3, #0]
1004416e:	430a      	orrs	r2, r1
10044170:	605a      	str	r2, [r3, #4]
    }
  }

  /* if required, configure MSB first on communication line */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
10044172:	687b      	ldr	r3, [r7, #4]
10044174:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
10044176:	2280      	movs	r2, #128	@ 0x80
10044178:	4013      	ands	r3, r2
1004417a:	d00b      	beq.n	10044194 <UART_AdvFeatureConfig+0x13c>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
1004417c:	687b      	ldr	r3, [r7, #4]
1004417e:	681b      	ldr	r3, [r3, #0]
10044180:	685b      	ldr	r3, [r3, #4]
10044182:	4a0e      	ldr	r2, [pc, #56]	@ (100441bc <UART_AdvFeatureConfig+0x164>)
10044184:	4013      	ands	r3, r2
10044186:	0019      	movs	r1, r3
10044188:	687b      	ldr	r3, [r7, #4]
1004418a:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
1004418c:	687b      	ldr	r3, [r7, #4]
1004418e:	681b      	ldr	r3, [r3, #0]
10044190:	430a      	orrs	r2, r1
10044192:	605a      	str	r2, [r3, #4]
  }
}
10044194:	46c0      	nop			@ (mov r8, r8)
10044196:	46bd      	mov	sp, r7
10044198:	b002      	add	sp, #8
1004419a:	bd80      	pop	{r7, pc}
1004419c:	ffff7fff 	.word	0xffff7fff
100441a0:	fffdffff 	.word	0xfffdffff
100441a4:	fffeffff 	.word	0xfffeffff
100441a8:	fffbffff 	.word	0xfffbffff
100441ac:	ffffefff 	.word	0xffffefff
100441b0:	ffffdfff 	.word	0xffffdfff
100441b4:	ffefffff 	.word	0xffefffff
100441b8:	ff9fffff 	.word	0xff9fffff
100441bc:	fff7ffff 	.word	0xfff7ffff

100441c0 <UART_CheckIdleState>:
  * @brief Check the UART Idle State.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
{
100441c0:	b580      	push	{r7, lr}
100441c2:	b092      	sub	sp, #72	@ 0x48
100441c4:	af02      	add	r7, sp, #8
100441c6:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Initialize the UART ErrorCode */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
100441c8:	687b      	ldr	r3, [r7, #4]
100441ca:	2290      	movs	r2, #144	@ 0x90
100441cc:	2100      	movs	r1, #0
100441ce:	5099      	str	r1, [r3, r2]

  /* Init tickstart for timeout management */
  tickstart = HAL_GetTick();
100441d0:	f7fd f9ea 	bl	100415a8 <HAL_GetTick>
100441d4:	0003      	movs	r3, r0
100441d6:	63fb      	str	r3, [r7, #60]	@ 0x3c

  /* Check if the Transmitter is enabled */
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
100441d8:	687b      	ldr	r3, [r7, #4]
100441da:	681b      	ldr	r3, [r3, #0]
100441dc:	681b      	ldr	r3, [r3, #0]
100441de:	2208      	movs	r2, #8
100441e0:	4013      	ands	r3, r2
100441e2:	2b08      	cmp	r3, #8
100441e4:	d12d      	bne.n	10044242 <UART_CheckIdleState+0x82>
  {
    /* Wait until TEACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
100441e6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
100441e8:	2280      	movs	r2, #128	@ 0x80
100441ea:	0391      	lsls	r1, r2, #14
100441ec:	6878      	ldr	r0, [r7, #4]
100441ee:	4a47      	ldr	r2, [pc, #284]	@ (1004430c <UART_CheckIdleState+0x14c>)
100441f0:	9200      	str	r2, [sp, #0]
100441f2:	2200      	movs	r2, #0
100441f4:	f000 f88e 	bl	10044314 <UART_WaitOnFlagUntilTimeout>
100441f8:	1e03      	subs	r3, r0, #0
100441fa:	d022      	beq.n	10044242 <UART_CheckIdleState+0x82>
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
100441fc:	f3ef 8310 	mrs	r3, PRIMASK
10044200:	627b      	str	r3, [r7, #36]	@ 0x24
  return(result);
10044202:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
    {
      /* Disable TXE interrupt for the interrupt process */
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE_TXFNFIE));
10044204:	63bb      	str	r3, [r7, #56]	@ 0x38
10044206:	2301      	movs	r3, #1
10044208:	62bb      	str	r3, [r7, #40]	@ 0x28
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
1004420a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
1004420c:	f383 8810 	msr	PRIMASK, r3
}
10044210:	46c0      	nop			@ (mov r8, r8)
10044212:	687b      	ldr	r3, [r7, #4]
10044214:	681b      	ldr	r3, [r3, #0]
10044216:	681a      	ldr	r2, [r3, #0]
10044218:	687b      	ldr	r3, [r7, #4]
1004421a:	681b      	ldr	r3, [r3, #0]
1004421c:	2180      	movs	r1, #128	@ 0x80
1004421e:	438a      	bics	r2, r1
10044220:	601a      	str	r2, [r3, #0]
10044222:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
10044224:	62fb      	str	r3, [r7, #44]	@ 0x2c
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
10044226:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
10044228:	f383 8810 	msr	PRIMASK, r3
}
1004422c:	46c0      	nop			@ (mov r8, r8)

      huart->gState = HAL_UART_STATE_READY;
1004422e:	687b      	ldr	r3, [r7, #4]
10044230:	2288      	movs	r2, #136	@ 0x88
10044232:	2120      	movs	r1, #32
10044234:	5099      	str	r1, [r3, r2]

      __HAL_UNLOCK(huart);
10044236:	687b      	ldr	r3, [r7, #4]
10044238:	2284      	movs	r2, #132	@ 0x84
1004423a:	2100      	movs	r1, #0
1004423c:	5499      	strb	r1, [r3, r2]

      /* Timeout occurred */
      return HAL_TIMEOUT;
1004423e:	2303      	movs	r3, #3
10044240:	e060      	b.n	10044304 <UART_CheckIdleState+0x144>
    }
  }

  /* Check if the Receiver is enabled */
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
10044242:	687b      	ldr	r3, [r7, #4]
10044244:	681b      	ldr	r3, [r3, #0]
10044246:	681b      	ldr	r3, [r3, #0]
10044248:	2204      	movs	r2, #4
1004424a:	4013      	ands	r3, r2
1004424c:	2b04      	cmp	r3, #4
1004424e:	d146      	bne.n	100442de <UART_CheckIdleState+0x11e>
  {
    /* Wait until REACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
10044250:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
10044252:	2280      	movs	r2, #128	@ 0x80
10044254:	03d1      	lsls	r1, r2, #15
10044256:	6878      	ldr	r0, [r7, #4]
10044258:	4a2c      	ldr	r2, [pc, #176]	@ (1004430c <UART_CheckIdleState+0x14c>)
1004425a:	9200      	str	r2, [sp, #0]
1004425c:	2200      	movs	r2, #0
1004425e:	f000 f859 	bl	10044314 <UART_WaitOnFlagUntilTimeout>
10044262:	1e03      	subs	r3, r0, #0
10044264:	d03b      	beq.n	100442de <UART_CheckIdleState+0x11e>
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
10044266:	f3ef 8310 	mrs	r3, PRIMASK
1004426a:	60fb      	str	r3, [r7, #12]
  return(result);
1004426c:	68fb      	ldr	r3, [r7, #12]
    {
      /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error)
      interrupts for the interrupt process */
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
1004426e:	637b      	str	r3, [r7, #52]	@ 0x34
10044270:	2301      	movs	r3, #1
10044272:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
10044274:	693b      	ldr	r3, [r7, #16]
10044276:	f383 8810 	msr	PRIMASK, r3
}
1004427a:	46c0      	nop			@ (mov r8, r8)
1004427c:	687b      	ldr	r3, [r7, #4]
1004427e:	681b      	ldr	r3, [r3, #0]
10044280:	681a      	ldr	r2, [r3, #0]
10044282:	687b      	ldr	r3, [r7, #4]
10044284:	681b      	ldr	r3, [r3, #0]
10044286:	4922      	ldr	r1, [pc, #136]	@ (10044310 <UART_CheckIdleState+0x150>)
10044288:	400a      	ands	r2, r1
1004428a:	601a      	str	r2, [r3, #0]
1004428c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
1004428e:	617b      	str	r3, [r7, #20]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
10044290:	697b      	ldr	r3, [r7, #20]
10044292:	f383 8810 	msr	PRIMASK, r3
}
10044296:	46c0      	nop			@ (mov r8, r8)
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
10044298:	f3ef 8310 	mrs	r3, PRIMASK
1004429c:	61bb      	str	r3, [r7, #24]
  return(result);
1004429e:	69bb      	ldr	r3, [r7, #24]
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
100442a0:	633b      	str	r3, [r7, #48]	@ 0x30
100442a2:	2301      	movs	r3, #1
100442a4:	61fb      	str	r3, [r7, #28]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
100442a6:	69fb      	ldr	r3, [r7, #28]
100442a8:	f383 8810 	msr	PRIMASK, r3
}
100442ac:	46c0      	nop			@ (mov r8, r8)
100442ae:	687b      	ldr	r3, [r7, #4]
100442b0:	681b      	ldr	r3, [r3, #0]
100442b2:	689a      	ldr	r2, [r3, #8]
100442b4:	687b      	ldr	r3, [r7, #4]
100442b6:	681b      	ldr	r3, [r3, #0]
100442b8:	2101      	movs	r1, #1
100442ba:	438a      	bics	r2, r1
100442bc:	609a      	str	r2, [r3, #8]
100442be:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
100442c0:	623b      	str	r3, [r7, #32]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
100442c2:	6a3b      	ldr	r3, [r7, #32]
100442c4:	f383 8810 	msr	PRIMASK, r3
}
100442c8:	46c0      	nop			@ (mov r8, r8)

      huart->RxState = HAL_UART_STATE_READY;
100442ca:	687b      	ldr	r3, [r7, #4]
100442cc:	228c      	movs	r2, #140	@ 0x8c
100442ce:	2120      	movs	r1, #32
100442d0:	5099      	str	r1, [r3, r2]

      __HAL_UNLOCK(huart);
100442d2:	687b      	ldr	r3, [r7, #4]
100442d4:	2284      	movs	r2, #132	@ 0x84
100442d6:	2100      	movs	r1, #0
100442d8:	5499      	strb	r1, [r3, r2]

      /* Timeout occurred */
      return HAL_TIMEOUT;
100442da:	2303      	movs	r3, #3
100442dc:	e012      	b.n	10044304 <UART_CheckIdleState+0x144>
    }
  }

  /* Initialize the UART State */
  huart->gState = HAL_UART_STATE_READY;
100442de:	687b      	ldr	r3, [r7, #4]
100442e0:	2288      	movs	r2, #136	@ 0x88
100442e2:	2120      	movs	r1, #32
100442e4:	5099      	str	r1, [r3, r2]
  huart->RxState = HAL_UART_STATE_READY;
100442e6:	687b      	ldr	r3, [r7, #4]
100442e8:	228c      	movs	r2, #140	@ 0x8c
100442ea:	2120      	movs	r1, #32
100442ec:	5099      	str	r1, [r3, r2]
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
100442ee:	687b      	ldr	r3, [r7, #4]
100442f0:	2200      	movs	r2, #0
100442f2:	66da      	str	r2, [r3, #108]	@ 0x6c
  huart->RxEventType = HAL_UART_RXEVENT_TC;
100442f4:	687b      	ldr	r3, [r7, #4]
100442f6:	2200      	movs	r2, #0
100442f8:	671a      	str	r2, [r3, #112]	@ 0x70

  __HAL_UNLOCK(huart);
100442fa:	687b      	ldr	r3, [r7, #4]
100442fc:	2284      	movs	r2, #132	@ 0x84
100442fe:	2100      	movs	r1, #0
10044300:	5499      	strb	r1, [r3, r2]

  return HAL_OK;
10044302:	2300      	movs	r3, #0
}
10044304:	0018      	movs	r0, r3
10044306:	46bd      	mov	sp, r7
10044308:	b010      	add	sp, #64	@ 0x40
1004430a:	bd80      	pop	{r7, pc}
1004430c:	01ffffff 	.word	0x01ffffff
10044310:	fffffedf 	.word	0xfffffedf

10044314 <UART_WaitOnFlagUntilTimeout>:
  * @param Timeout   Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status,
                                              uint32_t Tickstart, uint32_t Timeout)
{
10044314:	b580      	push	{r7, lr}
10044316:	b084      	sub	sp, #16
10044318:	af00      	add	r7, sp, #0
1004431a:	60f8      	str	r0, [r7, #12]
1004431c:	60b9      	str	r1, [r7, #8]
1004431e:	603b      	str	r3, [r7, #0]
10044320:	1dfb      	adds	r3, r7, #7
10044322:	701a      	strb	r2, [r3, #0]
  /* Wait until flag is set */
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
10044324:	e051      	b.n	100443ca <UART_WaitOnFlagUntilTimeout+0xb6>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
10044326:	69bb      	ldr	r3, [r7, #24]
10044328:	3301      	adds	r3, #1
1004432a:	d04e      	beq.n	100443ca <UART_WaitOnFlagUntilTimeout+0xb6>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
1004432c:	f7fd f93c 	bl	100415a8 <HAL_GetTick>
10044330:	0002      	movs	r2, r0
10044332:	683b      	ldr	r3, [r7, #0]
10044334:	1ad3      	subs	r3, r2, r3
10044336:	69ba      	ldr	r2, [r7, #24]
10044338:	429a      	cmp	r2, r3
1004433a:	d302      	bcc.n	10044342 <UART_WaitOnFlagUntilTimeout+0x2e>
1004433c:	69bb      	ldr	r3, [r7, #24]
1004433e:	2b00      	cmp	r3, #0
10044340:	d101      	bne.n	10044346 <UART_WaitOnFlagUntilTimeout+0x32>
      {

        return HAL_TIMEOUT;
10044342:	2303      	movs	r3, #3
10044344:	e051      	b.n	100443ea <UART_WaitOnFlagUntilTimeout+0xd6>
      }

      if ((READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U) && (Flag != UART_FLAG_TXE) && (Flag != UART_FLAG_TC))
10044346:	68fb      	ldr	r3, [r7, #12]
10044348:	681b      	ldr	r3, [r3, #0]
1004434a:	681b      	ldr	r3, [r3, #0]
1004434c:	2204      	movs	r2, #4
1004434e:	4013      	ands	r3, r2
10044350:	d03b      	beq.n	100443ca <UART_WaitOnFlagUntilTimeout+0xb6>
10044352:	68bb      	ldr	r3, [r7, #8]
10044354:	2b80      	cmp	r3, #128	@ 0x80
10044356:	d038      	beq.n	100443ca <UART_WaitOnFlagUntilTimeout+0xb6>
10044358:	68bb      	ldr	r3, [r7, #8]
1004435a:	2b40      	cmp	r3, #64	@ 0x40
1004435c:	d035      	beq.n	100443ca <UART_WaitOnFlagUntilTimeout+0xb6>
      {
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_ORE) == SET)
1004435e:	68fb      	ldr	r3, [r7, #12]
10044360:	681b      	ldr	r3, [r3, #0]
10044362:	69db      	ldr	r3, [r3, #28]
10044364:	2208      	movs	r2, #8
10044366:	4013      	ands	r3, r2
10044368:	2b08      	cmp	r3, #8
1004436a:	d111      	bne.n	10044390 <UART_WaitOnFlagUntilTimeout+0x7c>
        {
          /* Clear Overrun Error flag*/
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
1004436c:	68fb      	ldr	r3, [r7, #12]
1004436e:	681b      	ldr	r3, [r3, #0]
10044370:	2208      	movs	r2, #8
10044372:	621a      	str	r2, [r3, #32]

          /* Blocking error : transfer is aborted
          Set the UART state ready to be able to start again the process,
          Disable Rx Interrupts if ongoing */
          UART_EndRxTransfer(huart);
10044374:	68fb      	ldr	r3, [r7, #12]
10044376:	0018      	movs	r0, r3
10044378:	f000 f83c 	bl	100443f4 <UART_EndRxTransfer>

          huart->ErrorCode = HAL_UART_ERROR_ORE;
1004437c:	68fb      	ldr	r3, [r7, #12]
1004437e:	2290      	movs	r2, #144	@ 0x90
10044380:	2108      	movs	r1, #8
10044382:	5099      	str	r1, [r3, r2]

          /* Process Unlocked */
          __HAL_UNLOCK(huart);
10044384:	68fb      	ldr	r3, [r7, #12]
10044386:	2284      	movs	r2, #132	@ 0x84
10044388:	2100      	movs	r1, #0
1004438a:	5499      	strb	r1, [r3, r2]

          return HAL_ERROR;
1004438c:	2301      	movs	r3, #1
1004438e:	e02c      	b.n	100443ea <UART_WaitOnFlagUntilTimeout+0xd6>
        }
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
10044390:	68fb      	ldr	r3, [r7, #12]
10044392:	681b      	ldr	r3, [r3, #0]
10044394:	69da      	ldr	r2, [r3, #28]
10044396:	2380      	movs	r3, #128	@ 0x80
10044398:	011b      	lsls	r3, r3, #4
1004439a:	401a      	ands	r2, r3
1004439c:	2380      	movs	r3, #128	@ 0x80
1004439e:	011b      	lsls	r3, r3, #4
100443a0:	429a      	cmp	r2, r3
100443a2:	d112      	bne.n	100443ca <UART_WaitOnFlagUntilTimeout+0xb6>
        {
          /* Clear Receiver Timeout flag*/
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
100443a4:	68fb      	ldr	r3, [r7, #12]
100443a6:	681b      	ldr	r3, [r3, #0]
100443a8:	2280      	movs	r2, #128	@ 0x80
100443aa:	0112      	lsls	r2, r2, #4
100443ac:	621a      	str	r2, [r3, #32]

          /* Blocking error : transfer is aborted
          Set the UART state ready to be able to start again the process,
          Disable Rx Interrupts if ongoing */
          UART_EndRxTransfer(huart);
100443ae:	68fb      	ldr	r3, [r7, #12]
100443b0:	0018      	movs	r0, r3
100443b2:	f000 f81f 	bl	100443f4 <UART_EndRxTransfer>

          huart->ErrorCode = HAL_UART_ERROR_RTO;
100443b6:	68fb      	ldr	r3, [r7, #12]
100443b8:	2290      	movs	r2, #144	@ 0x90
100443ba:	2120      	movs	r1, #32
100443bc:	5099      	str	r1, [r3, r2]

          /* Process Unlocked */
          __HAL_UNLOCK(huart);
100443be:	68fb      	ldr	r3, [r7, #12]
100443c0:	2284      	movs	r2, #132	@ 0x84
100443c2:	2100      	movs	r1, #0
100443c4:	5499      	strb	r1, [r3, r2]

          return HAL_TIMEOUT;
100443c6:	2303      	movs	r3, #3
100443c8:	e00f      	b.n	100443ea <UART_WaitOnFlagUntilTimeout+0xd6>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
100443ca:	68fb      	ldr	r3, [r7, #12]
100443cc:	681b      	ldr	r3, [r3, #0]
100443ce:	69db      	ldr	r3, [r3, #28]
100443d0:	68ba      	ldr	r2, [r7, #8]
100443d2:	4013      	ands	r3, r2
100443d4:	68ba      	ldr	r2, [r7, #8]
100443d6:	1ad3      	subs	r3, r2, r3
100443d8:	425a      	negs	r2, r3
100443da:	4153      	adcs	r3, r2
100443dc:	b2db      	uxtb	r3, r3
100443de:	001a      	movs	r2, r3
100443e0:	1dfb      	adds	r3, r7, #7
100443e2:	781b      	ldrb	r3, [r3, #0]
100443e4:	429a      	cmp	r2, r3
100443e6:	d09e      	beq.n	10044326 <UART_WaitOnFlagUntilTimeout+0x12>
        }
      }
    }
  }
  return HAL_OK;
100443e8:	2300      	movs	r3, #0
}
100443ea:	0018      	movs	r0, r3
100443ec:	46bd      	mov	sp, r7
100443ee:	b004      	add	sp, #16
100443f0:	bd80      	pop	{r7, pc}
	...

100443f4 <UART_EndRxTransfer>:
  * @brief  End ongoing Rx transfer on UART peripheral (following error detection or Reception completion).
  * @param  huart UART handle.
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
100443f4:	b580      	push	{r7, lr}
100443f6:	b08e      	sub	sp, #56	@ 0x38
100443f8:	af00      	add	r7, sp, #0
100443fa:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
100443fc:	f3ef 8310 	mrs	r3, PRIMASK
10044400:	617b      	str	r3, [r7, #20]
  return(result);
10044402:	697b      	ldr	r3, [r7, #20]
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
10044404:	637b      	str	r3, [r7, #52]	@ 0x34
10044406:	2301      	movs	r3, #1
10044408:	61bb      	str	r3, [r7, #24]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
1004440a:	69bb      	ldr	r3, [r7, #24]
1004440c:	f383 8810 	msr	PRIMASK, r3
}
10044410:	46c0      	nop			@ (mov r8, r8)
10044412:	687b      	ldr	r3, [r7, #4]
10044414:	681b      	ldr	r3, [r3, #0]
10044416:	681a      	ldr	r2, [r3, #0]
10044418:	687b      	ldr	r3, [r7, #4]
1004441a:	681b      	ldr	r3, [r3, #0]
1004441c:	4926      	ldr	r1, [pc, #152]	@ (100444b8 <UART_EndRxTransfer+0xc4>)
1004441e:	400a      	ands	r2, r1
10044420:	601a      	str	r2, [r3, #0]
10044422:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
10044424:	61fb      	str	r3, [r7, #28]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
10044426:	69fb      	ldr	r3, [r7, #28]
10044428:	f383 8810 	msr	PRIMASK, r3
}
1004442c:	46c0      	nop			@ (mov r8, r8)
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
1004442e:	f3ef 8310 	mrs	r3, PRIMASK
10044432:	623b      	str	r3, [r7, #32]
  return(result);
10044434:	6a3b      	ldr	r3, [r7, #32]
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
10044436:	633b      	str	r3, [r7, #48]	@ 0x30
10044438:	2301      	movs	r3, #1
1004443a:	627b      	str	r3, [r7, #36]	@ 0x24
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
1004443c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
1004443e:	f383 8810 	msr	PRIMASK, r3
}
10044442:	46c0      	nop			@ (mov r8, r8)
10044444:	687b      	ldr	r3, [r7, #4]
10044446:	681b      	ldr	r3, [r3, #0]
10044448:	689a      	ldr	r2, [r3, #8]
1004444a:	687b      	ldr	r3, [r7, #4]
1004444c:	681b      	ldr	r3, [r3, #0]
1004444e:	491b      	ldr	r1, [pc, #108]	@ (100444bc <UART_EndRxTransfer+0xc8>)
10044450:	400a      	ands	r2, r1
10044452:	609a      	str	r2, [r3, #8]
10044454:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
10044456:	62bb      	str	r3, [r7, #40]	@ 0x28
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
10044458:	6abb      	ldr	r3, [r7, #40]	@ 0x28
1004445a:	f383 8810 	msr	PRIMASK, r3
}
1004445e:	46c0      	nop			@ (mov r8, r8)

  /* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
10044460:	687b      	ldr	r3, [r7, #4]
10044462:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
10044464:	2b01      	cmp	r3, #1
10044466:	d118      	bne.n	1004449a <UART_EndRxTransfer+0xa6>
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
10044468:	f3ef 8310 	mrs	r3, PRIMASK
1004446c:	60bb      	str	r3, [r7, #8]
  return(result);
1004446e:	68bb      	ldr	r3, [r7, #8]
  {
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
10044470:	62fb      	str	r3, [r7, #44]	@ 0x2c
10044472:	2301      	movs	r3, #1
10044474:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
10044476:	68fb      	ldr	r3, [r7, #12]
10044478:	f383 8810 	msr	PRIMASK, r3
}
1004447c:	46c0      	nop			@ (mov r8, r8)
1004447e:	687b      	ldr	r3, [r7, #4]
10044480:	681b      	ldr	r3, [r3, #0]
10044482:	681a      	ldr	r2, [r3, #0]
10044484:	687b      	ldr	r3, [r7, #4]
10044486:	681b      	ldr	r3, [r3, #0]
10044488:	2110      	movs	r1, #16
1004448a:	438a      	bics	r2, r1
1004448c:	601a      	str	r2, [r3, #0]
1004448e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
10044490:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
10044492:	693b      	ldr	r3, [r7, #16]
10044494:	f383 8810 	msr	PRIMASK, r3
}
10044498:	46c0      	nop			@ (mov r8, r8)
  }

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
1004449a:	687b      	ldr	r3, [r7, #4]
1004449c:	228c      	movs	r2, #140	@ 0x8c
1004449e:	2120      	movs	r1, #32
100444a0:	5099      	str	r1, [r3, r2]
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
100444a2:	687b      	ldr	r3, [r7, #4]
100444a4:	2200      	movs	r2, #0
100444a6:	66da      	str	r2, [r3, #108]	@ 0x6c

  /* Reset RxIsr function pointer */
  huart->RxISR = NULL;
100444a8:	687b      	ldr	r3, [r7, #4]
100444aa:	2200      	movs	r2, #0
100444ac:	675a      	str	r2, [r3, #116]	@ 0x74
}
100444ae:	46c0      	nop			@ (mov r8, r8)
100444b0:	46bd      	mov	sp, r7
100444b2:	b00e      	add	sp, #56	@ 0x38
100444b4:	bd80      	pop	{r7, pc}
100444b6:	46c0      	nop			@ (mov r8, r8)
100444b8:	fffffedf 	.word	0xfffffedf
100444bc:	effffffe 	.word	0xeffffffe

100444c0 <LL_GetXTALFreq>:
/**
  * @brief  This function returns the HSE XTAL frequency expressed in Hz.
  * @retval HSE XTAL frequency frequency.
  */
uint32_t LL_GetXTALFreq(void)
{
100444c0:	b580      	push	{r7, lr}
100444c2:	af00      	add	r7, sp, #0
  return HSE_xtalFrequency;
100444c4:	4b02      	ldr	r3, [pc, #8]	@ (100444d0 <LL_GetXTALFreq+0x10>)
100444c6:	681b      	ldr	r3, [r3, #0]
}
100444c8:	0018      	movs	r0, r3
100444ca:	46bd      	mov	sp, r7
100444cc:	bd80      	pop	{r7, pc}
100444ce:	46c0      	nop			@ (mov r8, r8)
100444d0:	2000068c 	.word	0x2000068c

100444d4 <std>:
100444d4:	2300      	movs	r3, #0
100444d6:	b510      	push	{r4, lr}
100444d8:	0004      	movs	r4, r0
100444da:	6003      	str	r3, [r0, #0]
100444dc:	6043      	str	r3, [r0, #4]
100444de:	6083      	str	r3, [r0, #8]
100444e0:	8181      	strh	r1, [r0, #12]
100444e2:	6643      	str	r3, [r0, #100]	@ 0x64
100444e4:	81c2      	strh	r2, [r0, #14]
100444e6:	6103      	str	r3, [r0, #16]
100444e8:	6143      	str	r3, [r0, #20]
100444ea:	6183      	str	r3, [r0, #24]
100444ec:	0019      	movs	r1, r3
100444ee:	2208      	movs	r2, #8
100444f0:	305c      	adds	r0, #92	@ 0x5c
100444f2:	f000 f9cf 	bl	10044894 <memset>
100444f6:	4b0b      	ldr	r3, [pc, #44]	@ (10044524 <std+0x50>)
100444f8:	6224      	str	r4, [r4, #32]
100444fa:	6263      	str	r3, [r4, #36]	@ 0x24
100444fc:	4b0a      	ldr	r3, [pc, #40]	@ (10044528 <std+0x54>)
100444fe:	62a3      	str	r3, [r4, #40]	@ 0x28
10044500:	4b0a      	ldr	r3, [pc, #40]	@ (1004452c <std+0x58>)
10044502:	62e3      	str	r3, [r4, #44]	@ 0x2c
10044504:	4b0a      	ldr	r3, [pc, #40]	@ (10044530 <std+0x5c>)
10044506:	6323      	str	r3, [r4, #48]	@ 0x30
10044508:	4b0a      	ldr	r3, [pc, #40]	@ (10044534 <std+0x60>)
1004450a:	429c      	cmp	r4, r3
1004450c:	d005      	beq.n	1004451a <std+0x46>
1004450e:	4b0a      	ldr	r3, [pc, #40]	@ (10044538 <std+0x64>)
10044510:	429c      	cmp	r4, r3
10044512:	d002      	beq.n	1004451a <std+0x46>
10044514:	4b09      	ldr	r3, [pc, #36]	@ (1004453c <std+0x68>)
10044516:	429c      	cmp	r4, r3
10044518:	d103      	bne.n	10044522 <std+0x4e>
1004451a:	0020      	movs	r0, r4
1004451c:	3058      	adds	r0, #88	@ 0x58
1004451e:	f000 fa15 	bl	1004494c <__retarget_lock_init_recursive>
10044522:	bd10      	pop	{r4, pc}
10044524:	100447fd 	.word	0x100447fd
10044528:	10044825 	.word	0x10044825
1004452c:	1004485d 	.word	0x1004485d
10044530:	10044889 	.word	0x10044889
10044534:	20000538 	.word	0x20000538
10044538:	200005a0 	.word	0x200005a0
1004453c:	20000608 	.word	0x20000608

10044540 <stdio_exit_handler>:
10044540:	b510      	push	{r4, lr}
10044542:	4a03      	ldr	r2, [pc, #12]	@ (10044550 <stdio_exit_handler+0x10>)
10044544:	4903      	ldr	r1, [pc, #12]	@ (10044554 <stdio_exit_handler+0x14>)
10044546:	4804      	ldr	r0, [pc, #16]	@ (10044558 <stdio_exit_handler+0x18>)
10044548:	f000 f86c 	bl	10044624 <_fwalk_sglue>
1004454c:	bd10      	pop	{r4, pc}
1004454e:	46c0      	nop			@ (mov r8, r8)
10044550:	20000698 	.word	0x20000698
10044554:	100451ed 	.word	0x100451ed
10044558:	200006a8 	.word	0x200006a8

1004455c <cleanup_stdio>:
1004455c:	6841      	ldr	r1, [r0, #4]
1004455e:	4b0b      	ldr	r3, [pc, #44]	@ (1004458c <cleanup_stdio+0x30>)
10044560:	b510      	push	{r4, lr}
10044562:	0004      	movs	r4, r0
10044564:	4299      	cmp	r1, r3
10044566:	d001      	beq.n	1004456c <cleanup_stdio+0x10>
10044568:	f000 fe40 	bl	100451ec <_fflush_r>
1004456c:	68a1      	ldr	r1, [r4, #8]
1004456e:	4b08      	ldr	r3, [pc, #32]	@ (10044590 <cleanup_stdio+0x34>)
10044570:	4299      	cmp	r1, r3
10044572:	d002      	beq.n	1004457a <cleanup_stdio+0x1e>
10044574:	0020      	movs	r0, r4
10044576:	f000 fe39 	bl	100451ec <_fflush_r>
1004457a:	68e1      	ldr	r1, [r4, #12]
1004457c:	4b05      	ldr	r3, [pc, #20]	@ (10044594 <cleanup_stdio+0x38>)
1004457e:	4299      	cmp	r1, r3
10044580:	d002      	beq.n	10044588 <cleanup_stdio+0x2c>
10044582:	0020      	movs	r0, r4
10044584:	f000 fe32 	bl	100451ec <_fflush_r>
10044588:	bd10      	pop	{r4, pc}
1004458a:	46c0      	nop			@ (mov r8, r8)
1004458c:	20000538 	.word	0x20000538
10044590:	200005a0 	.word	0x200005a0
10044594:	20000608 	.word	0x20000608

10044598 <global_stdio_init.part.0>:
10044598:	b510      	push	{r4, lr}
1004459a:	4b09      	ldr	r3, [pc, #36]	@ (100445c0 <global_stdio_init.part.0+0x28>)
1004459c:	4a09      	ldr	r2, [pc, #36]	@ (100445c4 <global_stdio_init.part.0+0x2c>)
1004459e:	2104      	movs	r1, #4
100445a0:	601a      	str	r2, [r3, #0]
100445a2:	4809      	ldr	r0, [pc, #36]	@ (100445c8 <global_stdio_init.part.0+0x30>)
100445a4:	2200      	movs	r2, #0
100445a6:	f7ff ff95 	bl	100444d4 <std>
100445aa:	2201      	movs	r2, #1
100445ac:	2109      	movs	r1, #9
100445ae:	4807      	ldr	r0, [pc, #28]	@ (100445cc <global_stdio_init.part.0+0x34>)
100445b0:	f7ff ff90 	bl	100444d4 <std>
100445b4:	2202      	movs	r2, #2
100445b6:	2112      	movs	r1, #18
100445b8:	4805      	ldr	r0, [pc, #20]	@ (100445d0 <global_stdio_init.part.0+0x38>)
100445ba:	f7ff ff8b 	bl	100444d4 <std>
100445be:	bd10      	pop	{r4, pc}
100445c0:	20000670 	.word	0x20000670
100445c4:	10044541 	.word	0x10044541
100445c8:	20000538 	.word	0x20000538
100445cc:	200005a0 	.word	0x200005a0
100445d0:	20000608 	.word	0x20000608

100445d4 <__sfp_lock_acquire>:
100445d4:	b510      	push	{r4, lr}
100445d6:	4802      	ldr	r0, [pc, #8]	@ (100445e0 <__sfp_lock_acquire+0xc>)
100445d8:	f000 f9b9 	bl	1004494e <__retarget_lock_acquire_recursive>
100445dc:	bd10      	pop	{r4, pc}
100445de:	46c0      	nop			@ (mov r8, r8)
100445e0:	20000679 	.word	0x20000679

100445e4 <__sfp_lock_release>:
100445e4:	b510      	push	{r4, lr}
100445e6:	4802      	ldr	r0, [pc, #8]	@ (100445f0 <__sfp_lock_release+0xc>)
100445e8:	f000 f9b2 	bl	10044950 <__retarget_lock_release_recursive>
100445ec:	bd10      	pop	{r4, pc}
100445ee:	46c0      	nop			@ (mov r8, r8)
100445f0:	20000679 	.word	0x20000679

100445f4 <__sinit>:
100445f4:	b510      	push	{r4, lr}
100445f6:	0004      	movs	r4, r0
100445f8:	f7ff ffec 	bl	100445d4 <__sfp_lock_acquire>
100445fc:	6a23      	ldr	r3, [r4, #32]
100445fe:	2b00      	cmp	r3, #0
10044600:	d002      	beq.n	10044608 <__sinit+0x14>
10044602:	f7ff ffef 	bl	100445e4 <__sfp_lock_release>
10044606:	bd10      	pop	{r4, pc}
10044608:	4b04      	ldr	r3, [pc, #16]	@ (1004461c <__sinit+0x28>)
1004460a:	6223      	str	r3, [r4, #32]
1004460c:	4b04      	ldr	r3, [pc, #16]	@ (10044620 <__sinit+0x2c>)
1004460e:	681b      	ldr	r3, [r3, #0]
10044610:	2b00      	cmp	r3, #0
10044612:	d1f6      	bne.n	10044602 <__sinit+0xe>
10044614:	f7ff ffc0 	bl	10044598 <global_stdio_init.part.0>
10044618:	e7f3      	b.n	10044602 <__sinit+0xe>
1004461a:	46c0      	nop			@ (mov r8, r8)
1004461c:	1004455d 	.word	0x1004455d
10044620:	20000670 	.word	0x20000670

10044624 <_fwalk_sglue>:
10044624:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
10044626:	0014      	movs	r4, r2
10044628:	2600      	movs	r6, #0
1004462a:	9000      	str	r0, [sp, #0]
1004462c:	9101      	str	r1, [sp, #4]
1004462e:	68a5      	ldr	r5, [r4, #8]
10044630:	6867      	ldr	r7, [r4, #4]
10044632:	3f01      	subs	r7, #1
10044634:	d504      	bpl.n	10044640 <_fwalk_sglue+0x1c>
10044636:	6824      	ldr	r4, [r4, #0]
10044638:	2c00      	cmp	r4, #0
1004463a:	d1f8      	bne.n	1004462e <_fwalk_sglue+0xa>
1004463c:	0030      	movs	r0, r6
1004463e:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
10044640:	89ab      	ldrh	r3, [r5, #12]
10044642:	2b01      	cmp	r3, #1
10044644:	d908      	bls.n	10044658 <_fwalk_sglue+0x34>
10044646:	220e      	movs	r2, #14
10044648:	5eab      	ldrsh	r3, [r5, r2]
1004464a:	3301      	adds	r3, #1
1004464c:	d004      	beq.n	10044658 <_fwalk_sglue+0x34>
1004464e:	0029      	movs	r1, r5
10044650:	9800      	ldr	r0, [sp, #0]
10044652:	9b01      	ldr	r3, [sp, #4]
10044654:	4798      	blx	r3
10044656:	4306      	orrs	r6, r0
10044658:	3568      	adds	r5, #104	@ 0x68
1004465a:	e7ea      	b.n	10044632 <_fwalk_sglue+0xe>

1004465c <iprintf>:
1004465c:	b40f      	push	{r0, r1, r2, r3}
1004465e:	b507      	push	{r0, r1, r2, lr}
10044660:	4905      	ldr	r1, [pc, #20]	@ (10044678 <iprintf+0x1c>)
10044662:	ab04      	add	r3, sp, #16
10044664:	6808      	ldr	r0, [r1, #0]
10044666:	cb04      	ldmia	r3!, {r2}
10044668:	6881      	ldr	r1, [r0, #8]
1004466a:	9301      	str	r3, [sp, #4]
1004466c:	f000 faa0 	bl	10044bb0 <_vfiprintf_r>
10044670:	b003      	add	sp, #12
10044672:	bc08      	pop	{r3}
10044674:	b004      	add	sp, #16
10044676:	4718      	bx	r3
10044678:	200006a4 	.word	0x200006a4

1004467c <putchar>:
1004467c:	b510      	push	{r4, lr}
1004467e:	4b03      	ldr	r3, [pc, #12]	@ (1004468c <putchar+0x10>)
10044680:	0001      	movs	r1, r0
10044682:	6818      	ldr	r0, [r3, #0]
10044684:	6882      	ldr	r2, [r0, #8]
10044686:	f000 fe48 	bl	1004531a <_putc_r>
1004468a:	bd10      	pop	{r4, pc}
1004468c:	200006a4 	.word	0x200006a4

10044690 <setvbuf>:
10044690:	b5f0      	push	{r4, r5, r6, r7, lr}
10044692:	001d      	movs	r5, r3
10044694:	4b57      	ldr	r3, [pc, #348]	@ (100447f4 <setvbuf+0x164>)
10044696:	b085      	sub	sp, #20
10044698:	681e      	ldr	r6, [r3, #0]
1004469a:	0004      	movs	r4, r0
1004469c:	000f      	movs	r7, r1
1004469e:	9200      	str	r2, [sp, #0]
100446a0:	2e00      	cmp	r6, #0
100446a2:	d005      	beq.n	100446b0 <setvbuf+0x20>
100446a4:	6a33      	ldr	r3, [r6, #32]
100446a6:	2b00      	cmp	r3, #0
100446a8:	d102      	bne.n	100446b0 <setvbuf+0x20>
100446aa:	0030      	movs	r0, r6
100446ac:	f7ff ffa2 	bl	100445f4 <__sinit>
100446b0:	9b00      	ldr	r3, [sp, #0]
100446b2:	2b02      	cmp	r3, #2
100446b4:	d005      	beq.n	100446c2 <setvbuf+0x32>
100446b6:	2b01      	cmp	r3, #1
100446b8:	d900      	bls.n	100446bc <setvbuf+0x2c>
100446ba:	e097      	b.n	100447ec <setvbuf+0x15c>
100446bc:	2d00      	cmp	r5, #0
100446be:	da00      	bge.n	100446c2 <setvbuf+0x32>
100446c0:	e094      	b.n	100447ec <setvbuf+0x15c>
100446c2:	6e63      	ldr	r3, [r4, #100]	@ 0x64
100446c4:	07db      	lsls	r3, r3, #31
100446c6:	d405      	bmi.n	100446d4 <setvbuf+0x44>
100446c8:	89a3      	ldrh	r3, [r4, #12]
100446ca:	059b      	lsls	r3, r3, #22
100446cc:	d402      	bmi.n	100446d4 <setvbuf+0x44>
100446ce:	6da0      	ldr	r0, [r4, #88]	@ 0x58
100446d0:	f000 f93d 	bl	1004494e <__retarget_lock_acquire_recursive>
100446d4:	0021      	movs	r1, r4
100446d6:	0030      	movs	r0, r6
100446d8:	f000 fd88 	bl	100451ec <_fflush_r>
100446dc:	6b61      	ldr	r1, [r4, #52]	@ 0x34
100446de:	2900      	cmp	r1, #0
100446e0:	d008      	beq.n	100446f4 <setvbuf+0x64>
100446e2:	0023      	movs	r3, r4
100446e4:	3344      	adds	r3, #68	@ 0x44
100446e6:	4299      	cmp	r1, r3
100446e8:	d002      	beq.n	100446f0 <setvbuf+0x60>
100446ea:	0030      	movs	r0, r6
100446ec:	f000 f932 	bl	10044954 <_free_r>
100446f0:	2300      	movs	r3, #0
100446f2:	6363      	str	r3, [r4, #52]	@ 0x34
100446f4:	2300      	movs	r3, #0
100446f6:	61a3      	str	r3, [r4, #24]
100446f8:	6063      	str	r3, [r4, #4]
100446fa:	89a3      	ldrh	r3, [r4, #12]
100446fc:	061b      	lsls	r3, r3, #24
100446fe:	d503      	bpl.n	10044708 <setvbuf+0x78>
10044700:	0030      	movs	r0, r6
10044702:	6921      	ldr	r1, [r4, #16]
10044704:	f000 f926 	bl	10044954 <_free_r>
10044708:	89a3      	ldrh	r3, [r4, #12]
1004470a:	4a3b      	ldr	r2, [pc, #236]	@ (100447f8 <setvbuf+0x168>)
1004470c:	4013      	ands	r3, r2
1004470e:	81a3      	strh	r3, [r4, #12]
10044710:	9b00      	ldr	r3, [sp, #0]
10044712:	2b02      	cmp	r3, #2
10044714:	d060      	beq.n	100447d8 <setvbuf+0x148>
10044716:	ab03      	add	r3, sp, #12
10044718:	0021      	movs	r1, r4
1004471a:	0030      	movs	r0, r6
1004471c:	aa02      	add	r2, sp, #8
1004471e:	f000 fd91 	bl	10045244 <__swhatbuf_r>
10044722:	89a3      	ldrh	r3, [r4, #12]
10044724:	4303      	orrs	r3, r0
10044726:	81a3      	strh	r3, [r4, #12]
10044728:	2d00      	cmp	r5, #0
1004472a:	d124      	bne.n	10044776 <setvbuf+0xe6>
1004472c:	9d02      	ldr	r5, [sp, #8]
1004472e:	0028      	movs	r0, r5
10044730:	f000 f95a 	bl	100449e8 <malloc>
10044734:	9501      	str	r5, [sp, #4]
10044736:	1e07      	subs	r7, r0, #0
10044738:	d148      	bne.n	100447cc <setvbuf+0x13c>
1004473a:	9b02      	ldr	r3, [sp, #8]
1004473c:	9301      	str	r3, [sp, #4]
1004473e:	42ab      	cmp	r3, r5
10044740:	d13f      	bne.n	100447c2 <setvbuf+0x132>
10044742:	2501      	movs	r5, #1
10044744:	426d      	negs	r5, r5
10044746:	220c      	movs	r2, #12
10044748:	5ea3      	ldrsh	r3, [r4, r2]
1004474a:	2202      	movs	r2, #2
1004474c:	431a      	orrs	r2, r3
1004474e:	81a2      	strh	r2, [r4, #12]
10044750:	2200      	movs	r2, #0
10044752:	60a2      	str	r2, [r4, #8]
10044754:	0022      	movs	r2, r4
10044756:	3247      	adds	r2, #71	@ 0x47
10044758:	6022      	str	r2, [r4, #0]
1004475a:	6122      	str	r2, [r4, #16]
1004475c:	2201      	movs	r2, #1
1004475e:	6e61      	ldr	r1, [r4, #100]	@ 0x64
10044760:	6162      	str	r2, [r4, #20]
10044762:	4211      	tst	r1, r2
10044764:	d104      	bne.n	10044770 <setvbuf+0xe0>
10044766:	059b      	lsls	r3, r3, #22
10044768:	d402      	bmi.n	10044770 <setvbuf+0xe0>
1004476a:	6da0      	ldr	r0, [r4, #88]	@ 0x58
1004476c:	f000 f8f0 	bl	10044950 <__retarget_lock_release_recursive>
10044770:	0028      	movs	r0, r5
10044772:	b005      	add	sp, #20
10044774:	bdf0      	pop	{r4, r5, r6, r7, pc}
10044776:	2f00      	cmp	r7, #0
10044778:	d0d9      	beq.n	1004472e <setvbuf+0x9e>
1004477a:	6a33      	ldr	r3, [r6, #32]
1004477c:	2b00      	cmp	r3, #0
1004477e:	d102      	bne.n	10044786 <setvbuf+0xf6>
10044780:	0030      	movs	r0, r6
10044782:	f7ff ff37 	bl	100445f4 <__sinit>
10044786:	9b00      	ldr	r3, [sp, #0]
10044788:	2b01      	cmp	r3, #1
1004478a:	d103      	bne.n	10044794 <setvbuf+0x104>
1004478c:	89a3      	ldrh	r3, [r4, #12]
1004478e:	9a00      	ldr	r2, [sp, #0]
10044790:	431a      	orrs	r2, r3
10044792:	81a2      	strh	r2, [r4, #12]
10044794:	220c      	movs	r2, #12
10044796:	5ea3      	ldrsh	r3, [r4, r2]
10044798:	2208      	movs	r2, #8
1004479a:	0019      	movs	r1, r3
1004479c:	6027      	str	r7, [r4, #0]
1004479e:	6127      	str	r7, [r4, #16]
100447a0:	6165      	str	r5, [r4, #20]
100447a2:	4011      	ands	r1, r2
100447a4:	4213      	tst	r3, r2
100447a6:	d01b      	beq.n	100447e0 <setvbuf+0x150>
100447a8:	07da      	lsls	r2, r3, #31
100447aa:	d517      	bpl.n	100447dc <setvbuf+0x14c>
100447ac:	2200      	movs	r2, #0
100447ae:	426d      	negs	r5, r5
100447b0:	60a2      	str	r2, [r4, #8]
100447b2:	61a5      	str	r5, [r4, #24]
100447b4:	6e62      	ldr	r2, [r4, #100]	@ 0x64
100447b6:	07d2      	lsls	r2, r2, #31
100447b8:	d401      	bmi.n	100447be <setvbuf+0x12e>
100447ba:	059b      	lsls	r3, r3, #22
100447bc:	d512      	bpl.n	100447e4 <setvbuf+0x154>
100447be:	2500      	movs	r5, #0
100447c0:	e7d6      	b.n	10044770 <setvbuf+0xe0>
100447c2:	9801      	ldr	r0, [sp, #4]
100447c4:	f000 f910 	bl	100449e8 <malloc>
100447c8:	1e07      	subs	r7, r0, #0
100447ca:	d0ba      	beq.n	10044742 <setvbuf+0xb2>
100447cc:	2380      	movs	r3, #128	@ 0x80
100447ce:	89a2      	ldrh	r2, [r4, #12]
100447d0:	9d01      	ldr	r5, [sp, #4]
100447d2:	4313      	orrs	r3, r2
100447d4:	81a3      	strh	r3, [r4, #12]
100447d6:	e7d0      	b.n	1004477a <setvbuf+0xea>
100447d8:	2500      	movs	r5, #0
100447da:	e7b4      	b.n	10044746 <setvbuf+0xb6>
100447dc:	60a5      	str	r5, [r4, #8]
100447de:	e7e9      	b.n	100447b4 <setvbuf+0x124>
100447e0:	60a1      	str	r1, [r4, #8]
100447e2:	e7e7      	b.n	100447b4 <setvbuf+0x124>
100447e4:	6da0      	ldr	r0, [r4, #88]	@ 0x58
100447e6:	f000 f8b3 	bl	10044950 <__retarget_lock_release_recursive>
100447ea:	e7e8      	b.n	100447be <setvbuf+0x12e>
100447ec:	2501      	movs	r5, #1
100447ee:	426d      	negs	r5, r5
100447f0:	e7be      	b.n	10044770 <setvbuf+0xe0>
100447f2:	46c0      	nop			@ (mov r8, r8)
100447f4:	200006a4 	.word	0x200006a4
100447f8:	fffff35c 	.word	0xfffff35c

100447fc <__sread>:
100447fc:	b570      	push	{r4, r5, r6, lr}
100447fe:	000c      	movs	r4, r1
10044800:	250e      	movs	r5, #14
10044802:	5f49      	ldrsh	r1, [r1, r5]
10044804:	f000 f874 	bl	100448f0 <_read_r>
10044808:	2800      	cmp	r0, #0
1004480a:	db03      	blt.n	10044814 <__sread+0x18>
1004480c:	6d63      	ldr	r3, [r4, #84]	@ 0x54
1004480e:	181b      	adds	r3, r3, r0
10044810:	6563      	str	r3, [r4, #84]	@ 0x54
10044812:	bd70      	pop	{r4, r5, r6, pc}
10044814:	89a3      	ldrh	r3, [r4, #12]
10044816:	4a02      	ldr	r2, [pc, #8]	@ (10044820 <__sread+0x24>)
10044818:	4013      	ands	r3, r2
1004481a:	81a3      	strh	r3, [r4, #12]
1004481c:	e7f9      	b.n	10044812 <__sread+0x16>
1004481e:	46c0      	nop			@ (mov r8, r8)
10044820:	ffffefff 	.word	0xffffefff

10044824 <__swrite>:
10044824:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
10044826:	001f      	movs	r7, r3
10044828:	898b      	ldrh	r3, [r1, #12]
1004482a:	0005      	movs	r5, r0
1004482c:	000c      	movs	r4, r1
1004482e:	0016      	movs	r6, r2
10044830:	05db      	lsls	r3, r3, #23
10044832:	d505      	bpl.n	10044840 <__swrite+0x1c>
10044834:	230e      	movs	r3, #14
10044836:	5ec9      	ldrsh	r1, [r1, r3]
10044838:	2200      	movs	r2, #0
1004483a:	2302      	movs	r3, #2
1004483c:	f000 f844 	bl	100448c8 <_lseek_r>
10044840:	89a3      	ldrh	r3, [r4, #12]
10044842:	4a05      	ldr	r2, [pc, #20]	@ (10044858 <__swrite+0x34>)
10044844:	0028      	movs	r0, r5
10044846:	4013      	ands	r3, r2
10044848:	81a3      	strh	r3, [r4, #12]
1004484a:	0032      	movs	r2, r6
1004484c:	230e      	movs	r3, #14
1004484e:	5ee1      	ldrsh	r1, [r4, r3]
10044850:	003b      	movs	r3, r7
10044852:	f000 f861 	bl	10044918 <_write_r>
10044856:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
10044858:	ffffefff 	.word	0xffffefff

1004485c <__sseek>:
1004485c:	b570      	push	{r4, r5, r6, lr}
1004485e:	000c      	movs	r4, r1
10044860:	250e      	movs	r5, #14
10044862:	5f49      	ldrsh	r1, [r1, r5]
10044864:	f000 f830 	bl	100448c8 <_lseek_r>
10044868:	89a3      	ldrh	r3, [r4, #12]
1004486a:	1c42      	adds	r2, r0, #1
1004486c:	d103      	bne.n	10044876 <__sseek+0x1a>
1004486e:	4a05      	ldr	r2, [pc, #20]	@ (10044884 <__sseek+0x28>)
10044870:	4013      	ands	r3, r2
10044872:	81a3      	strh	r3, [r4, #12]
10044874:	bd70      	pop	{r4, r5, r6, pc}
10044876:	2280      	movs	r2, #128	@ 0x80
10044878:	0152      	lsls	r2, r2, #5
1004487a:	4313      	orrs	r3, r2
1004487c:	81a3      	strh	r3, [r4, #12]
1004487e:	6560      	str	r0, [r4, #84]	@ 0x54
10044880:	e7f8      	b.n	10044874 <__sseek+0x18>
10044882:	46c0      	nop			@ (mov r8, r8)
10044884:	ffffefff 	.word	0xffffefff

10044888 <__sclose>:
10044888:	b510      	push	{r4, lr}
1004488a:	230e      	movs	r3, #14
1004488c:	5ec9      	ldrsh	r1, [r1, r3]
1004488e:	f000 f809 	bl	100448a4 <_close_r>
10044892:	bd10      	pop	{r4, pc}

10044894 <memset>:
10044894:	0003      	movs	r3, r0
10044896:	1882      	adds	r2, r0, r2
10044898:	4293      	cmp	r3, r2
1004489a:	d100      	bne.n	1004489e <memset+0xa>
1004489c:	4770      	bx	lr
1004489e:	7019      	strb	r1, [r3, #0]
100448a0:	3301      	adds	r3, #1
100448a2:	e7f9      	b.n	10044898 <memset+0x4>

100448a4 <_close_r>:
100448a4:	2300      	movs	r3, #0
100448a6:	b570      	push	{r4, r5, r6, lr}
100448a8:	4d06      	ldr	r5, [pc, #24]	@ (100448c4 <_close_r+0x20>)
100448aa:	0004      	movs	r4, r0
100448ac:	0008      	movs	r0, r1
100448ae:	602b      	str	r3, [r5, #0]
100448b0:	f7fc fada 	bl	10040e68 <_close>
100448b4:	1c43      	adds	r3, r0, #1
100448b6:	d103      	bne.n	100448c0 <_close_r+0x1c>
100448b8:	682b      	ldr	r3, [r5, #0]
100448ba:	2b00      	cmp	r3, #0
100448bc:	d000      	beq.n	100448c0 <_close_r+0x1c>
100448be:	6023      	str	r3, [r4, #0]
100448c0:	bd70      	pop	{r4, r5, r6, pc}
100448c2:	46c0      	nop			@ (mov r8, r8)
100448c4:	20000674 	.word	0x20000674

100448c8 <_lseek_r>:
100448c8:	b570      	push	{r4, r5, r6, lr}
100448ca:	0004      	movs	r4, r0
100448cc:	0008      	movs	r0, r1
100448ce:	0011      	movs	r1, r2
100448d0:	001a      	movs	r2, r3
100448d2:	2300      	movs	r3, #0
100448d4:	4d05      	ldr	r5, [pc, #20]	@ (100448ec <_lseek_r+0x24>)
100448d6:	602b      	str	r3, [r5, #0]
100448d8:	f7fc fae7 	bl	10040eaa <_lseek>
100448dc:	1c43      	adds	r3, r0, #1
100448de:	d103      	bne.n	100448e8 <_lseek_r+0x20>
100448e0:	682b      	ldr	r3, [r5, #0]
100448e2:	2b00      	cmp	r3, #0
100448e4:	d000      	beq.n	100448e8 <_lseek_r+0x20>
100448e6:	6023      	str	r3, [r4, #0]
100448e8:	bd70      	pop	{r4, r5, r6, pc}
100448ea:	46c0      	nop			@ (mov r8, r8)
100448ec:	20000674 	.word	0x20000674

100448f0 <_read_r>:
100448f0:	b570      	push	{r4, r5, r6, lr}
100448f2:	0004      	movs	r4, r0
100448f4:	0008      	movs	r0, r1
100448f6:	0011      	movs	r1, r2
100448f8:	001a      	movs	r2, r3
100448fa:	2300      	movs	r3, #0
100448fc:	4d05      	ldr	r5, [pc, #20]	@ (10044914 <_read_r+0x24>)
100448fe:	602b      	str	r3, [r5, #0]
10044900:	f7fc fa79 	bl	10040df6 <_read>
10044904:	1c43      	adds	r3, r0, #1
10044906:	d103      	bne.n	10044910 <_read_r+0x20>
10044908:	682b      	ldr	r3, [r5, #0]
1004490a:	2b00      	cmp	r3, #0
1004490c:	d000      	beq.n	10044910 <_read_r+0x20>
1004490e:	6023      	str	r3, [r4, #0]
10044910:	bd70      	pop	{r4, r5, r6, pc}
10044912:	46c0      	nop			@ (mov r8, r8)
10044914:	20000674 	.word	0x20000674

10044918 <_write_r>:
10044918:	b570      	push	{r4, r5, r6, lr}
1004491a:	0004      	movs	r4, r0
1004491c:	0008      	movs	r0, r1
1004491e:	0011      	movs	r1, r2
10044920:	001a      	movs	r2, r3
10044922:	2300      	movs	r3, #0
10044924:	4d05      	ldr	r5, [pc, #20]	@ (1004493c <_write_r+0x24>)
10044926:	602b      	str	r3, [r5, #0]
10044928:	f7fc fa82 	bl	10040e30 <_write>
1004492c:	1c43      	adds	r3, r0, #1
1004492e:	d103      	bne.n	10044938 <_write_r+0x20>
10044930:	682b      	ldr	r3, [r5, #0]
10044932:	2b00      	cmp	r3, #0
10044934:	d000      	beq.n	10044938 <_write_r+0x20>
10044936:	6023      	str	r3, [r4, #0]
10044938:	bd70      	pop	{r4, r5, r6, pc}
1004493a:	46c0      	nop			@ (mov r8, r8)
1004493c:	20000674 	.word	0x20000674

10044940 <__errno>:
10044940:	4b01      	ldr	r3, [pc, #4]	@ (10044948 <__errno+0x8>)
10044942:	6818      	ldr	r0, [r3, #0]
10044944:	4770      	bx	lr
10044946:	46c0      	nop			@ (mov r8, r8)
10044948:	200006a4 	.word	0x200006a4

1004494c <__retarget_lock_init_recursive>:
1004494c:	4770      	bx	lr

1004494e <__retarget_lock_acquire_recursive>:
1004494e:	4770      	bx	lr

10044950 <__retarget_lock_release_recursive>:
10044950:	4770      	bx	lr
	...

10044954 <_free_r>:
10044954:	b570      	push	{r4, r5, r6, lr}
10044956:	0005      	movs	r5, r0
10044958:	1e0c      	subs	r4, r1, #0
1004495a:	d010      	beq.n	1004497e <_free_r+0x2a>
1004495c:	3c04      	subs	r4, #4
1004495e:	6823      	ldr	r3, [r4, #0]
10044960:	2b00      	cmp	r3, #0
10044962:	da00      	bge.n	10044966 <_free_r+0x12>
10044964:	18e4      	adds	r4, r4, r3
10044966:	0028      	movs	r0, r5
10044968:	f000 f8ea 	bl	10044b40 <__malloc_lock>
1004496c:	4a1d      	ldr	r2, [pc, #116]	@ (100449e4 <_free_r+0x90>)
1004496e:	6813      	ldr	r3, [r2, #0]
10044970:	2b00      	cmp	r3, #0
10044972:	d105      	bne.n	10044980 <_free_r+0x2c>
10044974:	6063      	str	r3, [r4, #4]
10044976:	6014      	str	r4, [r2, #0]
10044978:	0028      	movs	r0, r5
1004497a:	f000 f8e9 	bl	10044b50 <__malloc_unlock>
1004497e:	bd70      	pop	{r4, r5, r6, pc}
10044980:	42a3      	cmp	r3, r4
10044982:	d908      	bls.n	10044996 <_free_r+0x42>
10044984:	6820      	ldr	r0, [r4, #0]
10044986:	1821      	adds	r1, r4, r0
10044988:	428b      	cmp	r3, r1
1004498a:	d1f3      	bne.n	10044974 <_free_r+0x20>
1004498c:	6819      	ldr	r1, [r3, #0]
1004498e:	685b      	ldr	r3, [r3, #4]
10044990:	1809      	adds	r1, r1, r0
10044992:	6021      	str	r1, [r4, #0]
10044994:	e7ee      	b.n	10044974 <_free_r+0x20>
10044996:	001a      	movs	r2, r3
10044998:	685b      	ldr	r3, [r3, #4]
1004499a:	2b00      	cmp	r3, #0
1004499c:	d001      	beq.n	100449a2 <_free_r+0x4e>
1004499e:	42a3      	cmp	r3, r4
100449a0:	d9f9      	bls.n	10044996 <_free_r+0x42>
100449a2:	6811      	ldr	r1, [r2, #0]
100449a4:	1850      	adds	r0, r2, r1
100449a6:	42a0      	cmp	r0, r4
100449a8:	d10b      	bne.n	100449c2 <_free_r+0x6e>
100449aa:	6820      	ldr	r0, [r4, #0]
100449ac:	1809      	adds	r1, r1, r0
100449ae:	1850      	adds	r0, r2, r1
100449b0:	6011      	str	r1, [r2, #0]
100449b2:	4283      	cmp	r3, r0
100449b4:	d1e0      	bne.n	10044978 <_free_r+0x24>
100449b6:	6818      	ldr	r0, [r3, #0]
100449b8:	685b      	ldr	r3, [r3, #4]
100449ba:	1841      	adds	r1, r0, r1
100449bc:	6011      	str	r1, [r2, #0]
100449be:	6053      	str	r3, [r2, #4]
100449c0:	e7da      	b.n	10044978 <_free_r+0x24>
100449c2:	42a0      	cmp	r0, r4
100449c4:	d902      	bls.n	100449cc <_free_r+0x78>
100449c6:	230c      	movs	r3, #12
100449c8:	602b      	str	r3, [r5, #0]
100449ca:	e7d5      	b.n	10044978 <_free_r+0x24>
100449cc:	6820      	ldr	r0, [r4, #0]
100449ce:	1821      	adds	r1, r4, r0
100449d0:	428b      	cmp	r3, r1
100449d2:	d103      	bne.n	100449dc <_free_r+0x88>
100449d4:	6819      	ldr	r1, [r3, #0]
100449d6:	685b      	ldr	r3, [r3, #4]
100449d8:	1809      	adds	r1, r1, r0
100449da:	6021      	str	r1, [r4, #0]
100449dc:	6063      	str	r3, [r4, #4]
100449de:	6054      	str	r4, [r2, #4]
100449e0:	e7ca      	b.n	10044978 <_free_r+0x24>
100449e2:	46c0      	nop			@ (mov r8, r8)
100449e4:	20000680 	.word	0x20000680

100449e8 <malloc>:
100449e8:	b510      	push	{r4, lr}
100449ea:	4b03      	ldr	r3, [pc, #12]	@ (100449f8 <malloc+0x10>)
100449ec:	0001      	movs	r1, r0
100449ee:	6818      	ldr	r0, [r3, #0]
100449f0:	f000 f826 	bl	10044a40 <_malloc_r>
100449f4:	bd10      	pop	{r4, pc}
100449f6:	46c0      	nop			@ (mov r8, r8)
100449f8:	200006a4 	.word	0x200006a4

100449fc <sbrk_aligned>:
100449fc:	b570      	push	{r4, r5, r6, lr}
100449fe:	4e0f      	ldr	r6, [pc, #60]	@ (10044a3c <sbrk_aligned+0x40>)
10044a00:	000d      	movs	r5, r1
10044a02:	6831      	ldr	r1, [r6, #0]
10044a04:	0004      	movs	r4, r0
10044a06:	2900      	cmp	r1, #0
10044a08:	d102      	bne.n	10044a10 <sbrk_aligned+0x14>
10044a0a:	f000 fd81 	bl	10045510 <_sbrk_r>
10044a0e:	6030      	str	r0, [r6, #0]
10044a10:	0029      	movs	r1, r5
10044a12:	0020      	movs	r0, r4
10044a14:	f000 fd7c 	bl	10045510 <_sbrk_r>
10044a18:	1c43      	adds	r3, r0, #1
10044a1a:	d103      	bne.n	10044a24 <sbrk_aligned+0x28>
10044a1c:	2501      	movs	r5, #1
10044a1e:	426d      	negs	r5, r5
10044a20:	0028      	movs	r0, r5
10044a22:	bd70      	pop	{r4, r5, r6, pc}
10044a24:	2303      	movs	r3, #3
10044a26:	1cc5      	adds	r5, r0, #3
10044a28:	439d      	bics	r5, r3
10044a2a:	42a8      	cmp	r0, r5
10044a2c:	d0f8      	beq.n	10044a20 <sbrk_aligned+0x24>
10044a2e:	1a29      	subs	r1, r5, r0
10044a30:	0020      	movs	r0, r4
10044a32:	f000 fd6d 	bl	10045510 <_sbrk_r>
10044a36:	3001      	adds	r0, #1
10044a38:	d1f2      	bne.n	10044a20 <sbrk_aligned+0x24>
10044a3a:	e7ef      	b.n	10044a1c <sbrk_aligned+0x20>
10044a3c:	2000067c 	.word	0x2000067c

10044a40 <_malloc_r>:
10044a40:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
10044a42:	2203      	movs	r2, #3
10044a44:	1ccb      	adds	r3, r1, #3
10044a46:	4393      	bics	r3, r2
10044a48:	3308      	adds	r3, #8
10044a4a:	0005      	movs	r5, r0
10044a4c:	001f      	movs	r7, r3
10044a4e:	2b0c      	cmp	r3, #12
10044a50:	d234      	bcs.n	10044abc <_malloc_r+0x7c>
10044a52:	270c      	movs	r7, #12
10044a54:	42b9      	cmp	r1, r7
10044a56:	d833      	bhi.n	10044ac0 <_malloc_r+0x80>
10044a58:	0028      	movs	r0, r5
10044a5a:	f000 f871 	bl	10044b40 <__malloc_lock>
10044a5e:	4e37      	ldr	r6, [pc, #220]	@ (10044b3c <_malloc_r+0xfc>)
10044a60:	6833      	ldr	r3, [r6, #0]
10044a62:	001c      	movs	r4, r3
10044a64:	2c00      	cmp	r4, #0
10044a66:	d12f      	bne.n	10044ac8 <_malloc_r+0x88>
10044a68:	0039      	movs	r1, r7
10044a6a:	0028      	movs	r0, r5
10044a6c:	f7ff ffc6 	bl	100449fc <sbrk_aligned>
10044a70:	0004      	movs	r4, r0
10044a72:	1c43      	adds	r3, r0, #1
10044a74:	d15f      	bne.n	10044b36 <_malloc_r+0xf6>
10044a76:	6834      	ldr	r4, [r6, #0]
10044a78:	9400      	str	r4, [sp, #0]
10044a7a:	9b00      	ldr	r3, [sp, #0]
10044a7c:	2b00      	cmp	r3, #0
10044a7e:	d14a      	bne.n	10044b16 <_malloc_r+0xd6>
10044a80:	2c00      	cmp	r4, #0
10044a82:	d052      	beq.n	10044b2a <_malloc_r+0xea>
10044a84:	6823      	ldr	r3, [r4, #0]
10044a86:	0028      	movs	r0, r5
10044a88:	18e3      	adds	r3, r4, r3
10044a8a:	9900      	ldr	r1, [sp, #0]
10044a8c:	9301      	str	r3, [sp, #4]
10044a8e:	f000 fd3f 	bl	10045510 <_sbrk_r>
10044a92:	9b01      	ldr	r3, [sp, #4]
10044a94:	4283      	cmp	r3, r0
10044a96:	d148      	bne.n	10044b2a <_malloc_r+0xea>
10044a98:	6823      	ldr	r3, [r4, #0]
10044a9a:	0028      	movs	r0, r5
10044a9c:	1aff      	subs	r7, r7, r3
10044a9e:	0039      	movs	r1, r7
10044aa0:	f7ff ffac 	bl	100449fc <sbrk_aligned>
10044aa4:	3001      	adds	r0, #1
10044aa6:	d040      	beq.n	10044b2a <_malloc_r+0xea>
10044aa8:	6823      	ldr	r3, [r4, #0]
10044aaa:	19db      	adds	r3, r3, r7
10044aac:	6023      	str	r3, [r4, #0]
10044aae:	6833      	ldr	r3, [r6, #0]
10044ab0:	685a      	ldr	r2, [r3, #4]
10044ab2:	2a00      	cmp	r2, #0
10044ab4:	d133      	bne.n	10044b1e <_malloc_r+0xde>
10044ab6:	9b00      	ldr	r3, [sp, #0]
10044ab8:	6033      	str	r3, [r6, #0]
10044aba:	e019      	b.n	10044af0 <_malloc_r+0xb0>
10044abc:	2b00      	cmp	r3, #0
10044abe:	dac9      	bge.n	10044a54 <_malloc_r+0x14>
10044ac0:	230c      	movs	r3, #12
10044ac2:	602b      	str	r3, [r5, #0]
10044ac4:	2000      	movs	r0, #0
10044ac6:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
10044ac8:	6821      	ldr	r1, [r4, #0]
10044aca:	1bc9      	subs	r1, r1, r7
10044acc:	d420      	bmi.n	10044b10 <_malloc_r+0xd0>
10044ace:	290b      	cmp	r1, #11
10044ad0:	d90a      	bls.n	10044ae8 <_malloc_r+0xa8>
10044ad2:	19e2      	adds	r2, r4, r7
10044ad4:	6027      	str	r7, [r4, #0]
10044ad6:	42a3      	cmp	r3, r4
10044ad8:	d104      	bne.n	10044ae4 <_malloc_r+0xa4>
10044ada:	6032      	str	r2, [r6, #0]
10044adc:	6863      	ldr	r3, [r4, #4]
10044ade:	6011      	str	r1, [r2, #0]
10044ae0:	6053      	str	r3, [r2, #4]
10044ae2:	e005      	b.n	10044af0 <_malloc_r+0xb0>
10044ae4:	605a      	str	r2, [r3, #4]
10044ae6:	e7f9      	b.n	10044adc <_malloc_r+0x9c>
10044ae8:	6862      	ldr	r2, [r4, #4]
10044aea:	42a3      	cmp	r3, r4
10044aec:	d10e      	bne.n	10044b0c <_malloc_r+0xcc>
10044aee:	6032      	str	r2, [r6, #0]
10044af0:	0028      	movs	r0, r5
10044af2:	f000 f82d 	bl	10044b50 <__malloc_unlock>
10044af6:	0020      	movs	r0, r4
10044af8:	2207      	movs	r2, #7
10044afa:	300b      	adds	r0, #11
10044afc:	1d23      	adds	r3, r4, #4
10044afe:	4390      	bics	r0, r2
10044b00:	1ac2      	subs	r2, r0, r3
10044b02:	4298      	cmp	r0, r3
10044b04:	d0df      	beq.n	10044ac6 <_malloc_r+0x86>
10044b06:	1a1b      	subs	r3, r3, r0
10044b08:	50a3      	str	r3, [r4, r2]
10044b0a:	e7dc      	b.n	10044ac6 <_malloc_r+0x86>
10044b0c:	605a      	str	r2, [r3, #4]
10044b0e:	e7ef      	b.n	10044af0 <_malloc_r+0xb0>
10044b10:	0023      	movs	r3, r4
10044b12:	6864      	ldr	r4, [r4, #4]
10044b14:	e7a6      	b.n	10044a64 <_malloc_r+0x24>
10044b16:	9c00      	ldr	r4, [sp, #0]
10044b18:	6863      	ldr	r3, [r4, #4]
10044b1a:	9300      	str	r3, [sp, #0]
10044b1c:	e7ad      	b.n	10044a7a <_malloc_r+0x3a>
10044b1e:	001a      	movs	r2, r3
10044b20:	685b      	ldr	r3, [r3, #4]
10044b22:	42a3      	cmp	r3, r4
10044b24:	d1fb      	bne.n	10044b1e <_malloc_r+0xde>
10044b26:	2300      	movs	r3, #0
10044b28:	e7da      	b.n	10044ae0 <_malloc_r+0xa0>
10044b2a:	230c      	movs	r3, #12
10044b2c:	0028      	movs	r0, r5
10044b2e:	602b      	str	r3, [r5, #0]
10044b30:	f000 f80e 	bl	10044b50 <__malloc_unlock>
10044b34:	e7c6      	b.n	10044ac4 <_malloc_r+0x84>
10044b36:	6007      	str	r7, [r0, #0]
10044b38:	e7da      	b.n	10044af0 <_malloc_r+0xb0>
10044b3a:	46c0      	nop			@ (mov r8, r8)
10044b3c:	20000680 	.word	0x20000680

10044b40 <__malloc_lock>:
10044b40:	b510      	push	{r4, lr}
10044b42:	4802      	ldr	r0, [pc, #8]	@ (10044b4c <__malloc_lock+0xc>)
10044b44:	f7ff ff03 	bl	1004494e <__retarget_lock_acquire_recursive>
10044b48:	bd10      	pop	{r4, pc}
10044b4a:	46c0      	nop			@ (mov r8, r8)
10044b4c:	20000678 	.word	0x20000678

10044b50 <__malloc_unlock>:
10044b50:	b510      	push	{r4, lr}
10044b52:	4802      	ldr	r0, [pc, #8]	@ (10044b5c <__malloc_unlock+0xc>)
10044b54:	f7ff fefc 	bl	10044950 <__retarget_lock_release_recursive>
10044b58:	bd10      	pop	{r4, pc}
10044b5a:	46c0      	nop			@ (mov r8, r8)
10044b5c:	20000678 	.word	0x20000678

10044b60 <__sfputc_r>:
10044b60:	6893      	ldr	r3, [r2, #8]
10044b62:	b510      	push	{r4, lr}
10044b64:	3b01      	subs	r3, #1
10044b66:	6093      	str	r3, [r2, #8]
10044b68:	2b00      	cmp	r3, #0
10044b6a:	da04      	bge.n	10044b76 <__sfputc_r+0x16>
10044b6c:	6994      	ldr	r4, [r2, #24]
10044b6e:	42a3      	cmp	r3, r4
10044b70:	db07      	blt.n	10044b82 <__sfputc_r+0x22>
10044b72:	290a      	cmp	r1, #10
10044b74:	d005      	beq.n	10044b82 <__sfputc_r+0x22>
10044b76:	6813      	ldr	r3, [r2, #0]
10044b78:	1c58      	adds	r0, r3, #1
10044b7a:	6010      	str	r0, [r2, #0]
10044b7c:	7019      	strb	r1, [r3, #0]
10044b7e:	0008      	movs	r0, r1
10044b80:	bd10      	pop	{r4, pc}
10044b82:	f000 fc00 	bl	10045386 <__swbuf_r>
10044b86:	0001      	movs	r1, r0
10044b88:	e7f9      	b.n	10044b7e <__sfputc_r+0x1e>

10044b8a <__sfputs_r>:
10044b8a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
10044b8c:	0006      	movs	r6, r0
10044b8e:	000f      	movs	r7, r1
10044b90:	0014      	movs	r4, r2
10044b92:	18d5      	adds	r5, r2, r3
10044b94:	42ac      	cmp	r4, r5
10044b96:	d101      	bne.n	10044b9c <__sfputs_r+0x12>
10044b98:	2000      	movs	r0, #0
10044b9a:	e007      	b.n	10044bac <__sfputs_r+0x22>
10044b9c:	7821      	ldrb	r1, [r4, #0]
10044b9e:	003a      	movs	r2, r7
10044ba0:	0030      	movs	r0, r6
10044ba2:	f7ff ffdd 	bl	10044b60 <__sfputc_r>
10044ba6:	3401      	adds	r4, #1
10044ba8:	1c43      	adds	r3, r0, #1
10044baa:	d1f3      	bne.n	10044b94 <__sfputs_r+0xa>
10044bac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

10044bb0 <_vfiprintf_r>:
10044bb0:	b5f0      	push	{r4, r5, r6, r7, lr}
10044bb2:	b0a1      	sub	sp, #132	@ 0x84
10044bb4:	000f      	movs	r7, r1
10044bb6:	0015      	movs	r5, r2
10044bb8:	001e      	movs	r6, r3
10044bba:	9003      	str	r0, [sp, #12]
10044bbc:	2800      	cmp	r0, #0
10044bbe:	d004      	beq.n	10044bca <_vfiprintf_r+0x1a>
10044bc0:	6a03      	ldr	r3, [r0, #32]
10044bc2:	2b00      	cmp	r3, #0
10044bc4:	d101      	bne.n	10044bca <_vfiprintf_r+0x1a>
10044bc6:	f7ff fd15 	bl	100445f4 <__sinit>
10044bca:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
10044bcc:	07db      	lsls	r3, r3, #31
10044bce:	d405      	bmi.n	10044bdc <_vfiprintf_r+0x2c>
10044bd0:	89bb      	ldrh	r3, [r7, #12]
10044bd2:	059b      	lsls	r3, r3, #22
10044bd4:	d402      	bmi.n	10044bdc <_vfiprintf_r+0x2c>
10044bd6:	6db8      	ldr	r0, [r7, #88]	@ 0x58
10044bd8:	f7ff feb9 	bl	1004494e <__retarget_lock_acquire_recursive>
10044bdc:	89bb      	ldrh	r3, [r7, #12]
10044bde:	071b      	lsls	r3, r3, #28
10044be0:	d502      	bpl.n	10044be8 <_vfiprintf_r+0x38>
10044be2:	693b      	ldr	r3, [r7, #16]
10044be4:	2b00      	cmp	r3, #0
10044be6:	d113      	bne.n	10044c10 <_vfiprintf_r+0x60>
10044be8:	0039      	movs	r1, r7
10044bea:	9803      	ldr	r0, [sp, #12]
10044bec:	f000 fc0e 	bl	1004540c <__swsetup_r>
10044bf0:	2800      	cmp	r0, #0
10044bf2:	d00d      	beq.n	10044c10 <_vfiprintf_r+0x60>
10044bf4:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
10044bf6:	07db      	lsls	r3, r3, #31
10044bf8:	d503      	bpl.n	10044c02 <_vfiprintf_r+0x52>
10044bfa:	2001      	movs	r0, #1
10044bfc:	4240      	negs	r0, r0
10044bfe:	b021      	add	sp, #132	@ 0x84
10044c00:	bdf0      	pop	{r4, r5, r6, r7, pc}
10044c02:	89bb      	ldrh	r3, [r7, #12]
10044c04:	059b      	lsls	r3, r3, #22
10044c06:	d4f8      	bmi.n	10044bfa <_vfiprintf_r+0x4a>
10044c08:	6db8      	ldr	r0, [r7, #88]	@ 0x58
10044c0a:	f7ff fea1 	bl	10044950 <__retarget_lock_release_recursive>
10044c0e:	e7f4      	b.n	10044bfa <_vfiprintf_r+0x4a>
10044c10:	2300      	movs	r3, #0
10044c12:	ac08      	add	r4, sp, #32
10044c14:	6163      	str	r3, [r4, #20]
10044c16:	3320      	adds	r3, #32
10044c18:	7663      	strb	r3, [r4, #25]
10044c1a:	3310      	adds	r3, #16
10044c1c:	76a3      	strb	r3, [r4, #26]
10044c1e:	9607      	str	r6, [sp, #28]
10044c20:	002e      	movs	r6, r5
10044c22:	7833      	ldrb	r3, [r6, #0]
10044c24:	2b00      	cmp	r3, #0
10044c26:	d001      	beq.n	10044c2c <_vfiprintf_r+0x7c>
10044c28:	2b25      	cmp	r3, #37	@ 0x25
10044c2a:	d148      	bne.n	10044cbe <_vfiprintf_r+0x10e>
10044c2c:	1b73      	subs	r3, r6, r5
10044c2e:	9305      	str	r3, [sp, #20]
10044c30:	42ae      	cmp	r6, r5
10044c32:	d00b      	beq.n	10044c4c <_vfiprintf_r+0x9c>
10044c34:	002a      	movs	r2, r5
10044c36:	0039      	movs	r1, r7
10044c38:	9803      	ldr	r0, [sp, #12]
10044c3a:	f7ff ffa6 	bl	10044b8a <__sfputs_r>
10044c3e:	3001      	adds	r0, #1
10044c40:	d100      	bne.n	10044c44 <_vfiprintf_r+0x94>
10044c42:	e0ae      	b.n	10044da2 <_vfiprintf_r+0x1f2>
10044c44:	6963      	ldr	r3, [r4, #20]
10044c46:	9a05      	ldr	r2, [sp, #20]
10044c48:	189b      	adds	r3, r3, r2
10044c4a:	6163      	str	r3, [r4, #20]
10044c4c:	7833      	ldrb	r3, [r6, #0]
10044c4e:	2b00      	cmp	r3, #0
10044c50:	d100      	bne.n	10044c54 <_vfiprintf_r+0xa4>
10044c52:	e0a6      	b.n	10044da2 <_vfiprintf_r+0x1f2>
10044c54:	2201      	movs	r2, #1
10044c56:	2300      	movs	r3, #0
10044c58:	4252      	negs	r2, r2
10044c5a:	6062      	str	r2, [r4, #4]
10044c5c:	a904      	add	r1, sp, #16
10044c5e:	3254      	adds	r2, #84	@ 0x54
10044c60:	1852      	adds	r2, r2, r1
10044c62:	1c75      	adds	r5, r6, #1
10044c64:	6023      	str	r3, [r4, #0]
10044c66:	60e3      	str	r3, [r4, #12]
10044c68:	60a3      	str	r3, [r4, #8]
10044c6a:	7013      	strb	r3, [r2, #0]
10044c6c:	65a3      	str	r3, [r4, #88]	@ 0x58
10044c6e:	4b59      	ldr	r3, [pc, #356]	@ (10044dd4 <_vfiprintf_r+0x224>)
10044c70:	2205      	movs	r2, #5
10044c72:	0018      	movs	r0, r3
10044c74:	7829      	ldrb	r1, [r5, #0]
10044c76:	9305      	str	r3, [sp, #20]
10044c78:	f000 fc5c 	bl	10045534 <memchr>
10044c7c:	1c6e      	adds	r6, r5, #1
10044c7e:	2800      	cmp	r0, #0
10044c80:	d11f      	bne.n	10044cc2 <_vfiprintf_r+0x112>
10044c82:	6822      	ldr	r2, [r4, #0]
10044c84:	06d3      	lsls	r3, r2, #27
10044c86:	d504      	bpl.n	10044c92 <_vfiprintf_r+0xe2>
10044c88:	2353      	movs	r3, #83	@ 0x53
10044c8a:	a904      	add	r1, sp, #16
10044c8c:	185b      	adds	r3, r3, r1
10044c8e:	2120      	movs	r1, #32
10044c90:	7019      	strb	r1, [r3, #0]
10044c92:	0713      	lsls	r3, r2, #28
10044c94:	d504      	bpl.n	10044ca0 <_vfiprintf_r+0xf0>
10044c96:	2353      	movs	r3, #83	@ 0x53
10044c98:	a904      	add	r1, sp, #16
10044c9a:	185b      	adds	r3, r3, r1
10044c9c:	212b      	movs	r1, #43	@ 0x2b
10044c9e:	7019      	strb	r1, [r3, #0]
10044ca0:	782b      	ldrb	r3, [r5, #0]
10044ca2:	2b2a      	cmp	r3, #42	@ 0x2a
10044ca4:	d016      	beq.n	10044cd4 <_vfiprintf_r+0x124>
10044ca6:	002e      	movs	r6, r5
10044ca8:	2100      	movs	r1, #0
10044caa:	200a      	movs	r0, #10
10044cac:	68e3      	ldr	r3, [r4, #12]
10044cae:	7832      	ldrb	r2, [r6, #0]
10044cb0:	1c75      	adds	r5, r6, #1
10044cb2:	3a30      	subs	r2, #48	@ 0x30
10044cb4:	2a09      	cmp	r2, #9
10044cb6:	d950      	bls.n	10044d5a <_vfiprintf_r+0x1aa>
10044cb8:	2900      	cmp	r1, #0
10044cba:	d111      	bne.n	10044ce0 <_vfiprintf_r+0x130>
10044cbc:	e017      	b.n	10044cee <_vfiprintf_r+0x13e>
10044cbe:	3601      	adds	r6, #1
10044cc0:	e7af      	b.n	10044c22 <_vfiprintf_r+0x72>
10044cc2:	9b05      	ldr	r3, [sp, #20]
10044cc4:	6822      	ldr	r2, [r4, #0]
10044cc6:	1ac0      	subs	r0, r0, r3
10044cc8:	2301      	movs	r3, #1
10044cca:	4083      	lsls	r3, r0
10044ccc:	4313      	orrs	r3, r2
10044cce:	0035      	movs	r5, r6
10044cd0:	6023      	str	r3, [r4, #0]
10044cd2:	e7cc      	b.n	10044c6e <_vfiprintf_r+0xbe>
10044cd4:	9b07      	ldr	r3, [sp, #28]
10044cd6:	1d19      	adds	r1, r3, #4
10044cd8:	681b      	ldr	r3, [r3, #0]
10044cda:	9107      	str	r1, [sp, #28]
10044cdc:	2b00      	cmp	r3, #0
10044cde:	db01      	blt.n	10044ce4 <_vfiprintf_r+0x134>
10044ce0:	930b      	str	r3, [sp, #44]	@ 0x2c
10044ce2:	e004      	b.n	10044cee <_vfiprintf_r+0x13e>
10044ce4:	425b      	negs	r3, r3
10044ce6:	60e3      	str	r3, [r4, #12]
10044ce8:	2302      	movs	r3, #2
10044cea:	4313      	orrs	r3, r2
10044cec:	6023      	str	r3, [r4, #0]
10044cee:	7833      	ldrb	r3, [r6, #0]
10044cf0:	2b2e      	cmp	r3, #46	@ 0x2e
10044cf2:	d10c      	bne.n	10044d0e <_vfiprintf_r+0x15e>
10044cf4:	7873      	ldrb	r3, [r6, #1]
10044cf6:	2b2a      	cmp	r3, #42	@ 0x2a
10044cf8:	d134      	bne.n	10044d64 <_vfiprintf_r+0x1b4>
10044cfa:	9b07      	ldr	r3, [sp, #28]
10044cfc:	3602      	adds	r6, #2
10044cfe:	1d1a      	adds	r2, r3, #4
10044d00:	681b      	ldr	r3, [r3, #0]
10044d02:	9207      	str	r2, [sp, #28]
10044d04:	2b00      	cmp	r3, #0
10044d06:	da01      	bge.n	10044d0c <_vfiprintf_r+0x15c>
10044d08:	2301      	movs	r3, #1
10044d0a:	425b      	negs	r3, r3
10044d0c:	9309      	str	r3, [sp, #36]	@ 0x24
10044d0e:	4d32      	ldr	r5, [pc, #200]	@ (10044dd8 <_vfiprintf_r+0x228>)
10044d10:	2203      	movs	r2, #3
10044d12:	0028      	movs	r0, r5
10044d14:	7831      	ldrb	r1, [r6, #0]
10044d16:	f000 fc0d 	bl	10045534 <memchr>
10044d1a:	2800      	cmp	r0, #0
10044d1c:	d006      	beq.n	10044d2c <_vfiprintf_r+0x17c>
10044d1e:	2340      	movs	r3, #64	@ 0x40
10044d20:	1b40      	subs	r0, r0, r5
10044d22:	4083      	lsls	r3, r0
10044d24:	6822      	ldr	r2, [r4, #0]
10044d26:	3601      	adds	r6, #1
10044d28:	4313      	orrs	r3, r2
10044d2a:	6023      	str	r3, [r4, #0]
10044d2c:	7831      	ldrb	r1, [r6, #0]
10044d2e:	2206      	movs	r2, #6
10044d30:	482a      	ldr	r0, [pc, #168]	@ (10044ddc <_vfiprintf_r+0x22c>)
10044d32:	1c75      	adds	r5, r6, #1
10044d34:	7621      	strb	r1, [r4, #24]
10044d36:	f000 fbfd 	bl	10045534 <memchr>
10044d3a:	2800      	cmp	r0, #0
10044d3c:	d040      	beq.n	10044dc0 <_vfiprintf_r+0x210>
10044d3e:	4b28      	ldr	r3, [pc, #160]	@ (10044de0 <_vfiprintf_r+0x230>)
10044d40:	2b00      	cmp	r3, #0
10044d42:	d122      	bne.n	10044d8a <_vfiprintf_r+0x1da>
10044d44:	2207      	movs	r2, #7
10044d46:	9b07      	ldr	r3, [sp, #28]
10044d48:	3307      	adds	r3, #7
10044d4a:	4393      	bics	r3, r2
10044d4c:	3308      	adds	r3, #8
10044d4e:	9307      	str	r3, [sp, #28]
10044d50:	6963      	ldr	r3, [r4, #20]
10044d52:	9a04      	ldr	r2, [sp, #16]
10044d54:	189b      	adds	r3, r3, r2
10044d56:	6163      	str	r3, [r4, #20]
10044d58:	e762      	b.n	10044c20 <_vfiprintf_r+0x70>
10044d5a:	4343      	muls	r3, r0
10044d5c:	002e      	movs	r6, r5
10044d5e:	2101      	movs	r1, #1
10044d60:	189b      	adds	r3, r3, r2
10044d62:	e7a4      	b.n	10044cae <_vfiprintf_r+0xfe>
10044d64:	2300      	movs	r3, #0
10044d66:	200a      	movs	r0, #10
10044d68:	0019      	movs	r1, r3
10044d6a:	3601      	adds	r6, #1
10044d6c:	6063      	str	r3, [r4, #4]
10044d6e:	7832      	ldrb	r2, [r6, #0]
10044d70:	1c75      	adds	r5, r6, #1
10044d72:	3a30      	subs	r2, #48	@ 0x30
10044d74:	2a09      	cmp	r2, #9
10044d76:	d903      	bls.n	10044d80 <_vfiprintf_r+0x1d0>
10044d78:	2b00      	cmp	r3, #0
10044d7a:	d0c8      	beq.n	10044d0e <_vfiprintf_r+0x15e>
10044d7c:	9109      	str	r1, [sp, #36]	@ 0x24
10044d7e:	e7c6      	b.n	10044d0e <_vfiprintf_r+0x15e>
10044d80:	4341      	muls	r1, r0
10044d82:	002e      	movs	r6, r5
10044d84:	2301      	movs	r3, #1
10044d86:	1889      	adds	r1, r1, r2
10044d88:	e7f1      	b.n	10044d6e <_vfiprintf_r+0x1be>
10044d8a:	aa07      	add	r2, sp, #28
10044d8c:	9200      	str	r2, [sp, #0]
10044d8e:	0021      	movs	r1, r4
10044d90:	003a      	movs	r2, r7
10044d92:	4b14      	ldr	r3, [pc, #80]	@ (10044de4 <_vfiprintf_r+0x234>)
10044d94:	9803      	ldr	r0, [sp, #12]
10044d96:	e000      	b.n	10044d9a <_vfiprintf_r+0x1ea>
10044d98:	bf00      	nop
10044d9a:	9004      	str	r0, [sp, #16]
10044d9c:	9b04      	ldr	r3, [sp, #16]
10044d9e:	3301      	adds	r3, #1
10044da0:	d1d6      	bne.n	10044d50 <_vfiprintf_r+0x1a0>
10044da2:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
10044da4:	07db      	lsls	r3, r3, #31
10044da6:	d405      	bmi.n	10044db4 <_vfiprintf_r+0x204>
10044da8:	89bb      	ldrh	r3, [r7, #12]
10044daa:	059b      	lsls	r3, r3, #22
10044dac:	d402      	bmi.n	10044db4 <_vfiprintf_r+0x204>
10044dae:	6db8      	ldr	r0, [r7, #88]	@ 0x58
10044db0:	f7ff fdce 	bl	10044950 <__retarget_lock_release_recursive>
10044db4:	89bb      	ldrh	r3, [r7, #12]
10044db6:	065b      	lsls	r3, r3, #25
10044db8:	d500      	bpl.n	10044dbc <_vfiprintf_r+0x20c>
10044dba:	e71e      	b.n	10044bfa <_vfiprintf_r+0x4a>
10044dbc:	980d      	ldr	r0, [sp, #52]	@ 0x34
10044dbe:	e71e      	b.n	10044bfe <_vfiprintf_r+0x4e>
10044dc0:	aa07      	add	r2, sp, #28
10044dc2:	9200      	str	r2, [sp, #0]
10044dc4:	0021      	movs	r1, r4
10044dc6:	003a      	movs	r2, r7
10044dc8:	4b06      	ldr	r3, [pc, #24]	@ (10044de4 <_vfiprintf_r+0x234>)
10044dca:	9803      	ldr	r0, [sp, #12]
10044dcc:	f000 f87c 	bl	10044ec8 <_printf_i>
10044dd0:	e7e3      	b.n	10044d9a <_vfiprintf_r+0x1ea>
10044dd2:	46c0      	nop			@ (mov r8, r8)
10044dd4:	10045724 	.word	0x10045724
10044dd8:	1004572a 	.word	0x1004572a
10044ddc:	1004572e 	.word	0x1004572e
10044de0:	00000000 	.word	0x00000000
10044de4:	10044b8b 	.word	0x10044b8b

10044de8 <_printf_common>:
10044de8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
10044dea:	0016      	movs	r6, r2
10044dec:	9301      	str	r3, [sp, #4]
10044dee:	688a      	ldr	r2, [r1, #8]
10044df0:	690b      	ldr	r3, [r1, #16]
10044df2:	000c      	movs	r4, r1
10044df4:	9000      	str	r0, [sp, #0]
10044df6:	4293      	cmp	r3, r2
10044df8:	da00      	bge.n	10044dfc <_printf_common+0x14>
10044dfa:	0013      	movs	r3, r2
10044dfc:	0022      	movs	r2, r4
10044dfe:	6033      	str	r3, [r6, #0]
10044e00:	3243      	adds	r2, #67	@ 0x43
10044e02:	7812      	ldrb	r2, [r2, #0]
10044e04:	2a00      	cmp	r2, #0
10044e06:	d001      	beq.n	10044e0c <_printf_common+0x24>
10044e08:	3301      	adds	r3, #1
10044e0a:	6033      	str	r3, [r6, #0]
10044e0c:	6823      	ldr	r3, [r4, #0]
10044e0e:	069b      	lsls	r3, r3, #26
10044e10:	d502      	bpl.n	10044e18 <_printf_common+0x30>
10044e12:	6833      	ldr	r3, [r6, #0]
10044e14:	3302      	adds	r3, #2
10044e16:	6033      	str	r3, [r6, #0]
10044e18:	6822      	ldr	r2, [r4, #0]
10044e1a:	2306      	movs	r3, #6
10044e1c:	0015      	movs	r5, r2
10044e1e:	401d      	ands	r5, r3
10044e20:	421a      	tst	r2, r3
10044e22:	d027      	beq.n	10044e74 <_printf_common+0x8c>
10044e24:	0023      	movs	r3, r4
10044e26:	3343      	adds	r3, #67	@ 0x43
10044e28:	781b      	ldrb	r3, [r3, #0]
10044e2a:	1e5a      	subs	r2, r3, #1
10044e2c:	4193      	sbcs	r3, r2
10044e2e:	6822      	ldr	r2, [r4, #0]
10044e30:	0692      	lsls	r2, r2, #26
10044e32:	d430      	bmi.n	10044e96 <_printf_common+0xae>
10044e34:	0022      	movs	r2, r4
10044e36:	9901      	ldr	r1, [sp, #4]
10044e38:	9800      	ldr	r0, [sp, #0]
10044e3a:	9d08      	ldr	r5, [sp, #32]
10044e3c:	3243      	adds	r2, #67	@ 0x43
10044e3e:	47a8      	blx	r5
10044e40:	3001      	adds	r0, #1
10044e42:	d025      	beq.n	10044e90 <_printf_common+0xa8>
10044e44:	2206      	movs	r2, #6
10044e46:	6823      	ldr	r3, [r4, #0]
10044e48:	2500      	movs	r5, #0
10044e4a:	4013      	ands	r3, r2
10044e4c:	2b04      	cmp	r3, #4
10044e4e:	d105      	bne.n	10044e5c <_printf_common+0x74>
10044e50:	6833      	ldr	r3, [r6, #0]
10044e52:	68e5      	ldr	r5, [r4, #12]
10044e54:	1aed      	subs	r5, r5, r3
10044e56:	43eb      	mvns	r3, r5
10044e58:	17db      	asrs	r3, r3, #31
10044e5a:	401d      	ands	r5, r3
10044e5c:	68a3      	ldr	r3, [r4, #8]
10044e5e:	6922      	ldr	r2, [r4, #16]
10044e60:	4293      	cmp	r3, r2
10044e62:	dd01      	ble.n	10044e68 <_printf_common+0x80>
10044e64:	1a9b      	subs	r3, r3, r2
10044e66:	18ed      	adds	r5, r5, r3
10044e68:	2600      	movs	r6, #0
10044e6a:	42b5      	cmp	r5, r6
10044e6c:	d120      	bne.n	10044eb0 <_printf_common+0xc8>
10044e6e:	2000      	movs	r0, #0
10044e70:	e010      	b.n	10044e94 <_printf_common+0xac>
10044e72:	3501      	adds	r5, #1
10044e74:	68e3      	ldr	r3, [r4, #12]
10044e76:	6832      	ldr	r2, [r6, #0]
10044e78:	1a9b      	subs	r3, r3, r2
10044e7a:	42ab      	cmp	r3, r5
10044e7c:	ddd2      	ble.n	10044e24 <_printf_common+0x3c>
10044e7e:	0022      	movs	r2, r4
10044e80:	2301      	movs	r3, #1
10044e82:	9901      	ldr	r1, [sp, #4]
10044e84:	9800      	ldr	r0, [sp, #0]
10044e86:	9f08      	ldr	r7, [sp, #32]
10044e88:	3219      	adds	r2, #25
10044e8a:	47b8      	blx	r7
10044e8c:	3001      	adds	r0, #1
10044e8e:	d1f0      	bne.n	10044e72 <_printf_common+0x8a>
10044e90:	2001      	movs	r0, #1
10044e92:	4240      	negs	r0, r0
10044e94:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
10044e96:	2030      	movs	r0, #48	@ 0x30
10044e98:	18e1      	adds	r1, r4, r3
10044e9a:	3143      	adds	r1, #67	@ 0x43
10044e9c:	7008      	strb	r0, [r1, #0]
10044e9e:	0021      	movs	r1, r4
10044ea0:	1c5a      	adds	r2, r3, #1
10044ea2:	3145      	adds	r1, #69	@ 0x45
10044ea4:	7809      	ldrb	r1, [r1, #0]
10044ea6:	18a2      	adds	r2, r4, r2
10044ea8:	3243      	adds	r2, #67	@ 0x43
10044eaa:	3302      	adds	r3, #2
10044eac:	7011      	strb	r1, [r2, #0]
10044eae:	e7c1      	b.n	10044e34 <_printf_common+0x4c>
10044eb0:	0022      	movs	r2, r4
10044eb2:	2301      	movs	r3, #1
10044eb4:	9901      	ldr	r1, [sp, #4]
10044eb6:	9800      	ldr	r0, [sp, #0]
10044eb8:	9f08      	ldr	r7, [sp, #32]
10044eba:	321a      	adds	r2, #26
10044ebc:	47b8      	blx	r7
10044ebe:	3001      	adds	r0, #1
10044ec0:	d0e6      	beq.n	10044e90 <_printf_common+0xa8>
10044ec2:	3601      	adds	r6, #1
10044ec4:	e7d1      	b.n	10044e6a <_printf_common+0x82>
	...

10044ec8 <_printf_i>:
10044ec8:	b5f0      	push	{r4, r5, r6, r7, lr}
10044eca:	b08b      	sub	sp, #44	@ 0x2c
10044ecc:	9206      	str	r2, [sp, #24]
10044ece:	000a      	movs	r2, r1
10044ed0:	3243      	adds	r2, #67	@ 0x43
10044ed2:	9307      	str	r3, [sp, #28]
10044ed4:	9005      	str	r0, [sp, #20]
10044ed6:	9203      	str	r2, [sp, #12]
10044ed8:	7e0a      	ldrb	r2, [r1, #24]
10044eda:	000c      	movs	r4, r1
10044edc:	9b10      	ldr	r3, [sp, #64]	@ 0x40
10044ede:	2a78      	cmp	r2, #120	@ 0x78
10044ee0:	d809      	bhi.n	10044ef6 <_printf_i+0x2e>
10044ee2:	2a62      	cmp	r2, #98	@ 0x62
10044ee4:	d80b      	bhi.n	10044efe <_printf_i+0x36>
10044ee6:	2a00      	cmp	r2, #0
10044ee8:	d100      	bne.n	10044eec <_printf_i+0x24>
10044eea:	e0ba      	b.n	10045062 <_printf_i+0x19a>
10044eec:	497a      	ldr	r1, [pc, #488]	@ (100450d8 <_printf_i+0x210>)
10044eee:	9104      	str	r1, [sp, #16]
10044ef0:	2a58      	cmp	r2, #88	@ 0x58
10044ef2:	d100      	bne.n	10044ef6 <_printf_i+0x2e>
10044ef4:	e08e      	b.n	10045014 <_printf_i+0x14c>
10044ef6:	0025      	movs	r5, r4
10044ef8:	3542      	adds	r5, #66	@ 0x42
10044efa:	702a      	strb	r2, [r5, #0]
10044efc:	e022      	b.n	10044f44 <_printf_i+0x7c>
10044efe:	0010      	movs	r0, r2
10044f00:	3863      	subs	r0, #99	@ 0x63
10044f02:	2815      	cmp	r0, #21
10044f04:	d8f7      	bhi.n	10044ef6 <_printf_i+0x2e>
10044f06:	f7fb f8db 	bl	100400c0 <__gnu_thumb1_case_shi>
10044f0a:	0016      	.short	0x0016
10044f0c:	fff6001f 	.word	0xfff6001f
10044f10:	fff6fff6 	.word	0xfff6fff6
10044f14:	001ffff6 	.word	0x001ffff6
10044f18:	fff6fff6 	.word	0xfff6fff6
10044f1c:	fff6fff6 	.word	0xfff6fff6
10044f20:	0036009f 	.word	0x0036009f
10044f24:	fff6007e 	.word	0xfff6007e
10044f28:	00b0fff6 	.word	0x00b0fff6
10044f2c:	0036fff6 	.word	0x0036fff6
10044f30:	fff6fff6 	.word	0xfff6fff6
10044f34:	0082      	.short	0x0082
10044f36:	0025      	movs	r5, r4
10044f38:	681a      	ldr	r2, [r3, #0]
10044f3a:	3542      	adds	r5, #66	@ 0x42
10044f3c:	1d11      	adds	r1, r2, #4
10044f3e:	6019      	str	r1, [r3, #0]
10044f40:	6813      	ldr	r3, [r2, #0]
10044f42:	702b      	strb	r3, [r5, #0]
10044f44:	2301      	movs	r3, #1
10044f46:	e09e      	b.n	10045086 <_printf_i+0x1be>
10044f48:	6818      	ldr	r0, [r3, #0]
10044f4a:	6809      	ldr	r1, [r1, #0]
10044f4c:	1d02      	adds	r2, r0, #4
10044f4e:	060d      	lsls	r5, r1, #24
10044f50:	d50b      	bpl.n	10044f6a <_printf_i+0xa2>
10044f52:	6806      	ldr	r6, [r0, #0]
10044f54:	601a      	str	r2, [r3, #0]
10044f56:	2e00      	cmp	r6, #0
10044f58:	da03      	bge.n	10044f62 <_printf_i+0x9a>
10044f5a:	232d      	movs	r3, #45	@ 0x2d
10044f5c:	9a03      	ldr	r2, [sp, #12]
10044f5e:	4276      	negs	r6, r6
10044f60:	7013      	strb	r3, [r2, #0]
10044f62:	4b5d      	ldr	r3, [pc, #372]	@ (100450d8 <_printf_i+0x210>)
10044f64:	270a      	movs	r7, #10
10044f66:	9304      	str	r3, [sp, #16]
10044f68:	e018      	b.n	10044f9c <_printf_i+0xd4>
10044f6a:	6806      	ldr	r6, [r0, #0]
10044f6c:	601a      	str	r2, [r3, #0]
10044f6e:	0649      	lsls	r1, r1, #25
10044f70:	d5f1      	bpl.n	10044f56 <_printf_i+0x8e>
10044f72:	b236      	sxth	r6, r6
10044f74:	e7ef      	b.n	10044f56 <_printf_i+0x8e>
10044f76:	6808      	ldr	r0, [r1, #0]
10044f78:	6819      	ldr	r1, [r3, #0]
10044f7a:	c940      	ldmia	r1!, {r6}
10044f7c:	0605      	lsls	r5, r0, #24
10044f7e:	d402      	bmi.n	10044f86 <_printf_i+0xbe>
10044f80:	0640      	lsls	r0, r0, #25
10044f82:	d500      	bpl.n	10044f86 <_printf_i+0xbe>
10044f84:	b2b6      	uxth	r6, r6
10044f86:	6019      	str	r1, [r3, #0]
10044f88:	4b53      	ldr	r3, [pc, #332]	@ (100450d8 <_printf_i+0x210>)
10044f8a:	270a      	movs	r7, #10
10044f8c:	9304      	str	r3, [sp, #16]
10044f8e:	2a6f      	cmp	r2, #111	@ 0x6f
10044f90:	d100      	bne.n	10044f94 <_printf_i+0xcc>
10044f92:	3f02      	subs	r7, #2
10044f94:	0023      	movs	r3, r4
10044f96:	2200      	movs	r2, #0
10044f98:	3343      	adds	r3, #67	@ 0x43
10044f9a:	701a      	strb	r2, [r3, #0]
10044f9c:	6863      	ldr	r3, [r4, #4]
10044f9e:	60a3      	str	r3, [r4, #8]
10044fa0:	2b00      	cmp	r3, #0
10044fa2:	db06      	blt.n	10044fb2 <_printf_i+0xea>
10044fa4:	2104      	movs	r1, #4
10044fa6:	6822      	ldr	r2, [r4, #0]
10044fa8:	9d03      	ldr	r5, [sp, #12]
10044faa:	438a      	bics	r2, r1
10044fac:	6022      	str	r2, [r4, #0]
10044fae:	4333      	orrs	r3, r6
10044fb0:	d00c      	beq.n	10044fcc <_printf_i+0x104>
10044fb2:	9d03      	ldr	r5, [sp, #12]
10044fb4:	0030      	movs	r0, r6
10044fb6:	0039      	movs	r1, r7
10044fb8:	f7fb f912 	bl	100401e0 <__aeabi_uidivmod>
10044fbc:	9b04      	ldr	r3, [sp, #16]
10044fbe:	3d01      	subs	r5, #1
10044fc0:	5c5b      	ldrb	r3, [r3, r1]
10044fc2:	702b      	strb	r3, [r5, #0]
10044fc4:	0033      	movs	r3, r6
10044fc6:	0006      	movs	r6, r0
10044fc8:	429f      	cmp	r7, r3
10044fca:	d9f3      	bls.n	10044fb4 <_printf_i+0xec>
10044fcc:	2f08      	cmp	r7, #8
10044fce:	d109      	bne.n	10044fe4 <_printf_i+0x11c>
10044fd0:	6823      	ldr	r3, [r4, #0]
10044fd2:	07db      	lsls	r3, r3, #31
10044fd4:	d506      	bpl.n	10044fe4 <_printf_i+0x11c>
10044fd6:	6862      	ldr	r2, [r4, #4]
10044fd8:	6923      	ldr	r3, [r4, #16]
10044fda:	429a      	cmp	r2, r3
10044fdc:	dc02      	bgt.n	10044fe4 <_printf_i+0x11c>
10044fde:	2330      	movs	r3, #48	@ 0x30
10044fe0:	3d01      	subs	r5, #1
10044fe2:	702b      	strb	r3, [r5, #0]
10044fe4:	9b03      	ldr	r3, [sp, #12]
10044fe6:	1b5b      	subs	r3, r3, r5
10044fe8:	6123      	str	r3, [r4, #16]
10044fea:	9b07      	ldr	r3, [sp, #28]
10044fec:	0021      	movs	r1, r4
10044fee:	9300      	str	r3, [sp, #0]
10044ff0:	9805      	ldr	r0, [sp, #20]
10044ff2:	9b06      	ldr	r3, [sp, #24]
10044ff4:	aa09      	add	r2, sp, #36	@ 0x24
10044ff6:	f7ff fef7 	bl	10044de8 <_printf_common>
10044ffa:	3001      	adds	r0, #1
10044ffc:	d148      	bne.n	10045090 <_printf_i+0x1c8>
10044ffe:	2001      	movs	r0, #1
10045000:	4240      	negs	r0, r0
10045002:	b00b      	add	sp, #44	@ 0x2c
10045004:	bdf0      	pop	{r4, r5, r6, r7, pc}
10045006:	2220      	movs	r2, #32
10045008:	6809      	ldr	r1, [r1, #0]
1004500a:	430a      	orrs	r2, r1
1004500c:	6022      	str	r2, [r4, #0]
1004500e:	2278      	movs	r2, #120	@ 0x78
10045010:	4932      	ldr	r1, [pc, #200]	@ (100450dc <_printf_i+0x214>)
10045012:	9104      	str	r1, [sp, #16]
10045014:	0021      	movs	r1, r4
10045016:	3145      	adds	r1, #69	@ 0x45
10045018:	700a      	strb	r2, [r1, #0]
1004501a:	6819      	ldr	r1, [r3, #0]
1004501c:	6822      	ldr	r2, [r4, #0]
1004501e:	c940      	ldmia	r1!, {r6}
10045020:	0610      	lsls	r0, r2, #24
10045022:	d402      	bmi.n	1004502a <_printf_i+0x162>
10045024:	0650      	lsls	r0, r2, #25
10045026:	d500      	bpl.n	1004502a <_printf_i+0x162>
10045028:	b2b6      	uxth	r6, r6
1004502a:	6019      	str	r1, [r3, #0]
1004502c:	07d3      	lsls	r3, r2, #31
1004502e:	d502      	bpl.n	10045036 <_printf_i+0x16e>
10045030:	2320      	movs	r3, #32
10045032:	4313      	orrs	r3, r2
10045034:	6023      	str	r3, [r4, #0]
10045036:	2e00      	cmp	r6, #0
10045038:	d001      	beq.n	1004503e <_printf_i+0x176>
1004503a:	2710      	movs	r7, #16
1004503c:	e7aa      	b.n	10044f94 <_printf_i+0xcc>
1004503e:	2220      	movs	r2, #32
10045040:	6823      	ldr	r3, [r4, #0]
10045042:	4393      	bics	r3, r2
10045044:	6023      	str	r3, [r4, #0]
10045046:	e7f8      	b.n	1004503a <_printf_i+0x172>
10045048:	681a      	ldr	r2, [r3, #0]
1004504a:	680d      	ldr	r5, [r1, #0]
1004504c:	1d10      	adds	r0, r2, #4
1004504e:	6949      	ldr	r1, [r1, #20]
10045050:	6018      	str	r0, [r3, #0]
10045052:	6813      	ldr	r3, [r2, #0]
10045054:	062e      	lsls	r6, r5, #24
10045056:	d501      	bpl.n	1004505c <_printf_i+0x194>
10045058:	6019      	str	r1, [r3, #0]
1004505a:	e002      	b.n	10045062 <_printf_i+0x19a>
1004505c:	066d      	lsls	r5, r5, #25
1004505e:	d5fb      	bpl.n	10045058 <_printf_i+0x190>
10045060:	8019      	strh	r1, [r3, #0]
10045062:	2300      	movs	r3, #0
10045064:	9d03      	ldr	r5, [sp, #12]
10045066:	6123      	str	r3, [r4, #16]
10045068:	e7bf      	b.n	10044fea <_printf_i+0x122>
1004506a:	681a      	ldr	r2, [r3, #0]
1004506c:	1d11      	adds	r1, r2, #4
1004506e:	6019      	str	r1, [r3, #0]
10045070:	6815      	ldr	r5, [r2, #0]
10045072:	2100      	movs	r1, #0
10045074:	0028      	movs	r0, r5
10045076:	6862      	ldr	r2, [r4, #4]
10045078:	f000 fa5c 	bl	10045534 <memchr>
1004507c:	2800      	cmp	r0, #0
1004507e:	d001      	beq.n	10045084 <_printf_i+0x1bc>
10045080:	1b40      	subs	r0, r0, r5
10045082:	6060      	str	r0, [r4, #4]
10045084:	6863      	ldr	r3, [r4, #4]
10045086:	6123      	str	r3, [r4, #16]
10045088:	2300      	movs	r3, #0
1004508a:	9a03      	ldr	r2, [sp, #12]
1004508c:	7013      	strb	r3, [r2, #0]
1004508e:	e7ac      	b.n	10044fea <_printf_i+0x122>
10045090:	002a      	movs	r2, r5
10045092:	6923      	ldr	r3, [r4, #16]
10045094:	9906      	ldr	r1, [sp, #24]
10045096:	9805      	ldr	r0, [sp, #20]
10045098:	9d07      	ldr	r5, [sp, #28]
1004509a:	47a8      	blx	r5
1004509c:	3001      	adds	r0, #1
1004509e:	d0ae      	beq.n	10044ffe <_printf_i+0x136>
100450a0:	6823      	ldr	r3, [r4, #0]
100450a2:	079b      	lsls	r3, r3, #30
100450a4:	d415      	bmi.n	100450d2 <_printf_i+0x20a>
100450a6:	9b09      	ldr	r3, [sp, #36]	@ 0x24
100450a8:	68e0      	ldr	r0, [r4, #12]
100450aa:	4298      	cmp	r0, r3
100450ac:	daa9      	bge.n	10045002 <_printf_i+0x13a>
100450ae:	0018      	movs	r0, r3
100450b0:	e7a7      	b.n	10045002 <_printf_i+0x13a>
100450b2:	0022      	movs	r2, r4
100450b4:	2301      	movs	r3, #1
100450b6:	9906      	ldr	r1, [sp, #24]
100450b8:	9805      	ldr	r0, [sp, #20]
100450ba:	9e07      	ldr	r6, [sp, #28]
100450bc:	3219      	adds	r2, #25
100450be:	47b0      	blx	r6
100450c0:	3001      	adds	r0, #1
100450c2:	d09c      	beq.n	10044ffe <_printf_i+0x136>
100450c4:	3501      	adds	r5, #1
100450c6:	68e3      	ldr	r3, [r4, #12]
100450c8:	9a09      	ldr	r2, [sp, #36]	@ 0x24
100450ca:	1a9b      	subs	r3, r3, r2
100450cc:	42ab      	cmp	r3, r5
100450ce:	dcf0      	bgt.n	100450b2 <_printf_i+0x1ea>
100450d0:	e7e9      	b.n	100450a6 <_printf_i+0x1de>
100450d2:	2500      	movs	r5, #0
100450d4:	e7f7      	b.n	100450c6 <_printf_i+0x1fe>
100450d6:	46c0      	nop			@ (mov r8, r8)
100450d8:	10045735 	.word	0x10045735
100450dc:	10045746 	.word	0x10045746

100450e0 <__sflush_r>:
100450e0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
100450e2:	220c      	movs	r2, #12
100450e4:	5e8b      	ldrsh	r3, [r1, r2]
100450e6:	0005      	movs	r5, r0
100450e8:	000c      	movs	r4, r1
100450ea:	071a      	lsls	r2, r3, #28
100450ec:	d456      	bmi.n	1004519c <__sflush_r+0xbc>
100450ee:	684a      	ldr	r2, [r1, #4]
100450f0:	2a00      	cmp	r2, #0
100450f2:	dc02      	bgt.n	100450fa <__sflush_r+0x1a>
100450f4:	6c0a      	ldr	r2, [r1, #64]	@ 0x40
100450f6:	2a00      	cmp	r2, #0
100450f8:	dd4e      	ble.n	10045198 <__sflush_r+0xb8>
100450fa:	6ae7      	ldr	r7, [r4, #44]	@ 0x2c
100450fc:	2f00      	cmp	r7, #0
100450fe:	d04b      	beq.n	10045198 <__sflush_r+0xb8>
10045100:	2200      	movs	r2, #0
10045102:	2080      	movs	r0, #128	@ 0x80
10045104:	682e      	ldr	r6, [r5, #0]
10045106:	602a      	str	r2, [r5, #0]
10045108:	001a      	movs	r2, r3
1004510a:	0140      	lsls	r0, r0, #5
1004510c:	6a21      	ldr	r1, [r4, #32]
1004510e:	4002      	ands	r2, r0
10045110:	4203      	tst	r3, r0
10045112:	d033      	beq.n	1004517c <__sflush_r+0x9c>
10045114:	6d62      	ldr	r2, [r4, #84]	@ 0x54
10045116:	89a3      	ldrh	r3, [r4, #12]
10045118:	075b      	lsls	r3, r3, #29
1004511a:	d506      	bpl.n	1004512a <__sflush_r+0x4a>
1004511c:	6863      	ldr	r3, [r4, #4]
1004511e:	1ad2      	subs	r2, r2, r3
10045120:	6b63      	ldr	r3, [r4, #52]	@ 0x34
10045122:	2b00      	cmp	r3, #0
10045124:	d001      	beq.n	1004512a <__sflush_r+0x4a>
10045126:	6c23      	ldr	r3, [r4, #64]	@ 0x40
10045128:	1ad2      	subs	r2, r2, r3
1004512a:	2300      	movs	r3, #0
1004512c:	0028      	movs	r0, r5
1004512e:	6ae7      	ldr	r7, [r4, #44]	@ 0x2c
10045130:	6a21      	ldr	r1, [r4, #32]
10045132:	47b8      	blx	r7
10045134:	89a2      	ldrh	r2, [r4, #12]
10045136:	1c43      	adds	r3, r0, #1
10045138:	d106      	bne.n	10045148 <__sflush_r+0x68>
1004513a:	6829      	ldr	r1, [r5, #0]
1004513c:	291d      	cmp	r1, #29
1004513e:	d846      	bhi.n	100451ce <__sflush_r+0xee>
10045140:	4b29      	ldr	r3, [pc, #164]	@ (100451e8 <__sflush_r+0x108>)
10045142:	40cb      	lsrs	r3, r1
10045144:	07db      	lsls	r3, r3, #31
10045146:	d542      	bpl.n	100451ce <__sflush_r+0xee>
10045148:	2300      	movs	r3, #0
1004514a:	6063      	str	r3, [r4, #4]
1004514c:	6923      	ldr	r3, [r4, #16]
1004514e:	6023      	str	r3, [r4, #0]
10045150:	04d2      	lsls	r2, r2, #19
10045152:	d505      	bpl.n	10045160 <__sflush_r+0x80>
10045154:	1c43      	adds	r3, r0, #1
10045156:	d102      	bne.n	1004515e <__sflush_r+0x7e>
10045158:	682b      	ldr	r3, [r5, #0]
1004515a:	2b00      	cmp	r3, #0
1004515c:	d100      	bne.n	10045160 <__sflush_r+0x80>
1004515e:	6560      	str	r0, [r4, #84]	@ 0x54
10045160:	6b61      	ldr	r1, [r4, #52]	@ 0x34
10045162:	602e      	str	r6, [r5, #0]
10045164:	2900      	cmp	r1, #0
10045166:	d017      	beq.n	10045198 <__sflush_r+0xb8>
10045168:	0023      	movs	r3, r4
1004516a:	3344      	adds	r3, #68	@ 0x44
1004516c:	4299      	cmp	r1, r3
1004516e:	d002      	beq.n	10045176 <__sflush_r+0x96>
10045170:	0028      	movs	r0, r5
10045172:	f7ff fbef 	bl	10044954 <_free_r>
10045176:	2300      	movs	r3, #0
10045178:	6363      	str	r3, [r4, #52]	@ 0x34
1004517a:	e00d      	b.n	10045198 <__sflush_r+0xb8>
1004517c:	2301      	movs	r3, #1
1004517e:	0028      	movs	r0, r5
10045180:	47b8      	blx	r7
10045182:	0002      	movs	r2, r0
10045184:	1c43      	adds	r3, r0, #1
10045186:	d1c6      	bne.n	10045116 <__sflush_r+0x36>
10045188:	682b      	ldr	r3, [r5, #0]
1004518a:	2b00      	cmp	r3, #0
1004518c:	d0c3      	beq.n	10045116 <__sflush_r+0x36>
1004518e:	2b1d      	cmp	r3, #29
10045190:	d001      	beq.n	10045196 <__sflush_r+0xb6>
10045192:	2b16      	cmp	r3, #22
10045194:	d11a      	bne.n	100451cc <__sflush_r+0xec>
10045196:	602e      	str	r6, [r5, #0]
10045198:	2000      	movs	r0, #0
1004519a:	e01e      	b.n	100451da <__sflush_r+0xfa>
1004519c:	690e      	ldr	r6, [r1, #16]
1004519e:	2e00      	cmp	r6, #0
100451a0:	d0fa      	beq.n	10045198 <__sflush_r+0xb8>
100451a2:	680f      	ldr	r7, [r1, #0]
100451a4:	600e      	str	r6, [r1, #0]
100451a6:	1bba      	subs	r2, r7, r6
100451a8:	9201      	str	r2, [sp, #4]
100451aa:	2200      	movs	r2, #0
100451ac:	079b      	lsls	r3, r3, #30
100451ae:	d100      	bne.n	100451b2 <__sflush_r+0xd2>
100451b0:	694a      	ldr	r2, [r1, #20]
100451b2:	60a2      	str	r2, [r4, #8]
100451b4:	9b01      	ldr	r3, [sp, #4]
100451b6:	2b00      	cmp	r3, #0
100451b8:	ddee      	ble.n	10045198 <__sflush_r+0xb8>
100451ba:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
100451bc:	0032      	movs	r2, r6
100451be:	001f      	movs	r7, r3
100451c0:	0028      	movs	r0, r5
100451c2:	9b01      	ldr	r3, [sp, #4]
100451c4:	6a21      	ldr	r1, [r4, #32]
100451c6:	47b8      	blx	r7
100451c8:	2800      	cmp	r0, #0
100451ca:	dc07      	bgt.n	100451dc <__sflush_r+0xfc>
100451cc:	89a2      	ldrh	r2, [r4, #12]
100451ce:	2340      	movs	r3, #64	@ 0x40
100451d0:	2001      	movs	r0, #1
100451d2:	4313      	orrs	r3, r2
100451d4:	b21b      	sxth	r3, r3
100451d6:	81a3      	strh	r3, [r4, #12]
100451d8:	4240      	negs	r0, r0
100451da:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
100451dc:	9b01      	ldr	r3, [sp, #4]
100451de:	1836      	adds	r6, r6, r0
100451e0:	1a1b      	subs	r3, r3, r0
100451e2:	9301      	str	r3, [sp, #4]
100451e4:	e7e6      	b.n	100451b4 <__sflush_r+0xd4>
100451e6:	46c0      	nop			@ (mov r8, r8)
100451e8:	20400001 	.word	0x20400001

100451ec <_fflush_r>:
100451ec:	690b      	ldr	r3, [r1, #16]
100451ee:	b570      	push	{r4, r5, r6, lr}
100451f0:	0005      	movs	r5, r0
100451f2:	000c      	movs	r4, r1
100451f4:	2b00      	cmp	r3, #0
100451f6:	d102      	bne.n	100451fe <_fflush_r+0x12>
100451f8:	2500      	movs	r5, #0
100451fa:	0028      	movs	r0, r5
100451fc:	bd70      	pop	{r4, r5, r6, pc}
100451fe:	2800      	cmp	r0, #0
10045200:	d004      	beq.n	1004520c <_fflush_r+0x20>
10045202:	6a03      	ldr	r3, [r0, #32]
10045204:	2b00      	cmp	r3, #0
10045206:	d101      	bne.n	1004520c <_fflush_r+0x20>
10045208:	f7ff f9f4 	bl	100445f4 <__sinit>
1004520c:	220c      	movs	r2, #12
1004520e:	5ea3      	ldrsh	r3, [r4, r2]
10045210:	2b00      	cmp	r3, #0
10045212:	d0f1      	beq.n	100451f8 <_fflush_r+0xc>
10045214:	6e62      	ldr	r2, [r4, #100]	@ 0x64
10045216:	07d2      	lsls	r2, r2, #31
10045218:	d404      	bmi.n	10045224 <_fflush_r+0x38>
1004521a:	059b      	lsls	r3, r3, #22
1004521c:	d402      	bmi.n	10045224 <_fflush_r+0x38>
1004521e:	6da0      	ldr	r0, [r4, #88]	@ 0x58
10045220:	f7ff fb95 	bl	1004494e <__retarget_lock_acquire_recursive>
10045224:	0028      	movs	r0, r5
10045226:	0021      	movs	r1, r4
10045228:	f7ff ff5a 	bl	100450e0 <__sflush_r>
1004522c:	6e63      	ldr	r3, [r4, #100]	@ 0x64
1004522e:	0005      	movs	r5, r0
10045230:	07db      	lsls	r3, r3, #31
10045232:	d4e2      	bmi.n	100451fa <_fflush_r+0xe>
10045234:	89a3      	ldrh	r3, [r4, #12]
10045236:	059b      	lsls	r3, r3, #22
10045238:	d4df      	bmi.n	100451fa <_fflush_r+0xe>
1004523a:	6da0      	ldr	r0, [r4, #88]	@ 0x58
1004523c:	f7ff fb88 	bl	10044950 <__retarget_lock_release_recursive>
10045240:	e7db      	b.n	100451fa <_fflush_r+0xe>
	...

10045244 <__swhatbuf_r>:
10045244:	b570      	push	{r4, r5, r6, lr}
10045246:	000e      	movs	r6, r1
10045248:	001d      	movs	r5, r3
1004524a:	230e      	movs	r3, #14
1004524c:	5ec9      	ldrsh	r1, [r1, r3]
1004524e:	0014      	movs	r4, r2
10045250:	b096      	sub	sp, #88	@ 0x58
10045252:	2900      	cmp	r1, #0
10045254:	da0c      	bge.n	10045270 <__swhatbuf_r+0x2c>
10045256:	89b2      	ldrh	r2, [r6, #12]
10045258:	2380      	movs	r3, #128	@ 0x80
1004525a:	0011      	movs	r1, r2
1004525c:	4019      	ands	r1, r3
1004525e:	421a      	tst	r2, r3
10045260:	d114      	bne.n	1004528c <__swhatbuf_r+0x48>
10045262:	2380      	movs	r3, #128	@ 0x80
10045264:	00db      	lsls	r3, r3, #3
10045266:	2000      	movs	r0, #0
10045268:	6029      	str	r1, [r5, #0]
1004526a:	6023      	str	r3, [r4, #0]
1004526c:	b016      	add	sp, #88	@ 0x58
1004526e:	bd70      	pop	{r4, r5, r6, pc}
10045270:	466a      	mov	r2, sp
10045272:	f000 f929 	bl	100454c8 <_fstat_r>
10045276:	2800      	cmp	r0, #0
10045278:	dbed      	blt.n	10045256 <__swhatbuf_r+0x12>
1004527a:	23f0      	movs	r3, #240	@ 0xf0
1004527c:	9901      	ldr	r1, [sp, #4]
1004527e:	021b      	lsls	r3, r3, #8
10045280:	4019      	ands	r1, r3
10045282:	4b04      	ldr	r3, [pc, #16]	@ (10045294 <__swhatbuf_r+0x50>)
10045284:	18c9      	adds	r1, r1, r3
10045286:	424b      	negs	r3, r1
10045288:	4159      	adcs	r1, r3
1004528a:	e7ea      	b.n	10045262 <__swhatbuf_r+0x1e>
1004528c:	2100      	movs	r1, #0
1004528e:	2340      	movs	r3, #64	@ 0x40
10045290:	e7e9      	b.n	10045266 <__swhatbuf_r+0x22>
10045292:	46c0      	nop			@ (mov r8, r8)
10045294:	ffffe000 	.word	0xffffe000

10045298 <__smakebuf_r>:
10045298:	b5f0      	push	{r4, r5, r6, r7, lr}
1004529a:	2602      	movs	r6, #2
1004529c:	898b      	ldrh	r3, [r1, #12]
1004529e:	0005      	movs	r5, r0
100452a0:	000c      	movs	r4, r1
100452a2:	b085      	sub	sp, #20
100452a4:	4233      	tst	r3, r6
100452a6:	d007      	beq.n	100452b8 <__smakebuf_r+0x20>
100452a8:	0023      	movs	r3, r4
100452aa:	3347      	adds	r3, #71	@ 0x47
100452ac:	6023      	str	r3, [r4, #0]
100452ae:	6123      	str	r3, [r4, #16]
100452b0:	2301      	movs	r3, #1
100452b2:	6163      	str	r3, [r4, #20]
100452b4:	b005      	add	sp, #20
100452b6:	bdf0      	pop	{r4, r5, r6, r7, pc}
100452b8:	ab03      	add	r3, sp, #12
100452ba:	aa02      	add	r2, sp, #8
100452bc:	f7ff ffc2 	bl	10045244 <__swhatbuf_r>
100452c0:	9f02      	ldr	r7, [sp, #8]
100452c2:	9001      	str	r0, [sp, #4]
100452c4:	0039      	movs	r1, r7
100452c6:	0028      	movs	r0, r5
100452c8:	f7ff fbba 	bl	10044a40 <_malloc_r>
100452cc:	2800      	cmp	r0, #0
100452ce:	d108      	bne.n	100452e2 <__smakebuf_r+0x4a>
100452d0:	220c      	movs	r2, #12
100452d2:	5ea3      	ldrsh	r3, [r4, r2]
100452d4:	059a      	lsls	r2, r3, #22
100452d6:	d4ed      	bmi.n	100452b4 <__smakebuf_r+0x1c>
100452d8:	2203      	movs	r2, #3
100452da:	4393      	bics	r3, r2
100452dc:	431e      	orrs	r6, r3
100452de:	81a6      	strh	r6, [r4, #12]
100452e0:	e7e2      	b.n	100452a8 <__smakebuf_r+0x10>
100452e2:	2380      	movs	r3, #128	@ 0x80
100452e4:	89a2      	ldrh	r2, [r4, #12]
100452e6:	6020      	str	r0, [r4, #0]
100452e8:	4313      	orrs	r3, r2
100452ea:	81a3      	strh	r3, [r4, #12]
100452ec:	9b03      	ldr	r3, [sp, #12]
100452ee:	6120      	str	r0, [r4, #16]
100452f0:	6167      	str	r7, [r4, #20]
100452f2:	2b00      	cmp	r3, #0
100452f4:	d00c      	beq.n	10045310 <__smakebuf_r+0x78>
100452f6:	0028      	movs	r0, r5
100452f8:	230e      	movs	r3, #14
100452fa:	5ee1      	ldrsh	r1, [r4, r3]
100452fc:	f000 f8f6 	bl	100454ec <_isatty_r>
10045300:	2800      	cmp	r0, #0
10045302:	d005      	beq.n	10045310 <__smakebuf_r+0x78>
10045304:	2303      	movs	r3, #3
10045306:	89a2      	ldrh	r2, [r4, #12]
10045308:	439a      	bics	r2, r3
1004530a:	3b02      	subs	r3, #2
1004530c:	4313      	orrs	r3, r2
1004530e:	81a3      	strh	r3, [r4, #12]
10045310:	89a3      	ldrh	r3, [r4, #12]
10045312:	9a01      	ldr	r2, [sp, #4]
10045314:	4313      	orrs	r3, r2
10045316:	81a3      	strh	r3, [r4, #12]
10045318:	e7cc      	b.n	100452b4 <__smakebuf_r+0x1c>

1004531a <_putc_r>:
1004531a:	b570      	push	{r4, r5, r6, lr}
1004531c:	0006      	movs	r6, r0
1004531e:	000d      	movs	r5, r1
10045320:	0014      	movs	r4, r2
10045322:	2800      	cmp	r0, #0
10045324:	d004      	beq.n	10045330 <_putc_r+0x16>
10045326:	6a03      	ldr	r3, [r0, #32]
10045328:	2b00      	cmp	r3, #0
1004532a:	d101      	bne.n	10045330 <_putc_r+0x16>
1004532c:	f7ff f962 	bl	100445f4 <__sinit>
10045330:	6e63      	ldr	r3, [r4, #100]	@ 0x64
10045332:	07db      	lsls	r3, r3, #31
10045334:	d405      	bmi.n	10045342 <_putc_r+0x28>
10045336:	89a3      	ldrh	r3, [r4, #12]
10045338:	059b      	lsls	r3, r3, #22
1004533a:	d402      	bmi.n	10045342 <_putc_r+0x28>
1004533c:	6da0      	ldr	r0, [r4, #88]	@ 0x58
1004533e:	f7ff fb06 	bl	1004494e <__retarget_lock_acquire_recursive>
10045342:	68a3      	ldr	r3, [r4, #8]
10045344:	3b01      	subs	r3, #1
10045346:	60a3      	str	r3, [r4, #8]
10045348:	2b00      	cmp	r3, #0
1004534a:	da05      	bge.n	10045358 <_putc_r+0x3e>
1004534c:	69a2      	ldr	r2, [r4, #24]
1004534e:	4293      	cmp	r3, r2
10045350:	db12      	blt.n	10045378 <_putc_r+0x5e>
10045352:	b2eb      	uxtb	r3, r5
10045354:	2b0a      	cmp	r3, #10
10045356:	d00f      	beq.n	10045378 <_putc_r+0x5e>
10045358:	6823      	ldr	r3, [r4, #0]
1004535a:	1c5a      	adds	r2, r3, #1
1004535c:	6022      	str	r2, [r4, #0]
1004535e:	701d      	strb	r5, [r3, #0]
10045360:	b2ed      	uxtb	r5, r5
10045362:	6e63      	ldr	r3, [r4, #100]	@ 0x64
10045364:	07db      	lsls	r3, r3, #31
10045366:	d405      	bmi.n	10045374 <_putc_r+0x5a>
10045368:	89a3      	ldrh	r3, [r4, #12]
1004536a:	059b      	lsls	r3, r3, #22
1004536c:	d402      	bmi.n	10045374 <_putc_r+0x5a>
1004536e:	6da0      	ldr	r0, [r4, #88]	@ 0x58
10045370:	f7ff faee 	bl	10044950 <__retarget_lock_release_recursive>
10045374:	0028      	movs	r0, r5
10045376:	bd70      	pop	{r4, r5, r6, pc}
10045378:	0029      	movs	r1, r5
1004537a:	0022      	movs	r2, r4
1004537c:	0030      	movs	r0, r6
1004537e:	f000 f802 	bl	10045386 <__swbuf_r>
10045382:	0005      	movs	r5, r0
10045384:	e7ed      	b.n	10045362 <_putc_r+0x48>

10045386 <__swbuf_r>:
10045386:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
10045388:	0006      	movs	r6, r0
1004538a:	000d      	movs	r5, r1
1004538c:	0014      	movs	r4, r2
1004538e:	2800      	cmp	r0, #0
10045390:	d004      	beq.n	1004539c <__swbuf_r+0x16>
10045392:	6a03      	ldr	r3, [r0, #32]
10045394:	2b00      	cmp	r3, #0
10045396:	d101      	bne.n	1004539c <__swbuf_r+0x16>
10045398:	f7ff f92c 	bl	100445f4 <__sinit>
1004539c:	69a3      	ldr	r3, [r4, #24]
1004539e:	60a3      	str	r3, [r4, #8]
100453a0:	89a3      	ldrh	r3, [r4, #12]
100453a2:	071b      	lsls	r3, r3, #28
100453a4:	d502      	bpl.n	100453ac <__swbuf_r+0x26>
100453a6:	6923      	ldr	r3, [r4, #16]
100453a8:	2b00      	cmp	r3, #0
100453aa:	d109      	bne.n	100453c0 <__swbuf_r+0x3a>
100453ac:	0021      	movs	r1, r4
100453ae:	0030      	movs	r0, r6
100453b0:	f000 f82c 	bl	1004540c <__swsetup_r>
100453b4:	2800      	cmp	r0, #0
100453b6:	d003      	beq.n	100453c0 <__swbuf_r+0x3a>
100453b8:	2501      	movs	r5, #1
100453ba:	426d      	negs	r5, r5
100453bc:	0028      	movs	r0, r5
100453be:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
100453c0:	6923      	ldr	r3, [r4, #16]
100453c2:	6820      	ldr	r0, [r4, #0]
100453c4:	b2ef      	uxtb	r7, r5
100453c6:	1ac0      	subs	r0, r0, r3
100453c8:	6963      	ldr	r3, [r4, #20]
100453ca:	b2ed      	uxtb	r5, r5
100453cc:	4283      	cmp	r3, r0
100453ce:	dc05      	bgt.n	100453dc <__swbuf_r+0x56>
100453d0:	0021      	movs	r1, r4
100453d2:	0030      	movs	r0, r6
100453d4:	f7ff ff0a 	bl	100451ec <_fflush_r>
100453d8:	2800      	cmp	r0, #0
100453da:	d1ed      	bne.n	100453b8 <__swbuf_r+0x32>
100453dc:	68a3      	ldr	r3, [r4, #8]
100453de:	3001      	adds	r0, #1
100453e0:	3b01      	subs	r3, #1
100453e2:	60a3      	str	r3, [r4, #8]
100453e4:	6823      	ldr	r3, [r4, #0]
100453e6:	1c5a      	adds	r2, r3, #1
100453e8:	6022      	str	r2, [r4, #0]
100453ea:	701f      	strb	r7, [r3, #0]
100453ec:	6963      	ldr	r3, [r4, #20]
100453ee:	4283      	cmp	r3, r0
100453f0:	d004      	beq.n	100453fc <__swbuf_r+0x76>
100453f2:	89a3      	ldrh	r3, [r4, #12]
100453f4:	07db      	lsls	r3, r3, #31
100453f6:	d5e1      	bpl.n	100453bc <__swbuf_r+0x36>
100453f8:	2d0a      	cmp	r5, #10
100453fa:	d1df      	bne.n	100453bc <__swbuf_r+0x36>
100453fc:	0021      	movs	r1, r4
100453fe:	0030      	movs	r0, r6
10045400:	f7ff fef4 	bl	100451ec <_fflush_r>
10045404:	2800      	cmp	r0, #0
10045406:	d0d9      	beq.n	100453bc <__swbuf_r+0x36>
10045408:	e7d6      	b.n	100453b8 <__swbuf_r+0x32>
	...

1004540c <__swsetup_r>:
1004540c:	4b2d      	ldr	r3, [pc, #180]	@ (100454c4 <__swsetup_r+0xb8>)
1004540e:	b570      	push	{r4, r5, r6, lr}
10045410:	0005      	movs	r5, r0
10045412:	6818      	ldr	r0, [r3, #0]
10045414:	000c      	movs	r4, r1
10045416:	2800      	cmp	r0, #0
10045418:	d004      	beq.n	10045424 <__swsetup_r+0x18>
1004541a:	6a03      	ldr	r3, [r0, #32]
1004541c:	2b00      	cmp	r3, #0
1004541e:	d101      	bne.n	10045424 <__swsetup_r+0x18>
10045420:	f7ff f8e8 	bl	100445f4 <__sinit>
10045424:	220c      	movs	r2, #12
10045426:	5ea3      	ldrsh	r3, [r4, r2]
10045428:	071a      	lsls	r2, r3, #28
1004542a:	d423      	bmi.n	10045474 <__swsetup_r+0x68>
1004542c:	06da      	lsls	r2, r3, #27
1004542e:	d407      	bmi.n	10045440 <__swsetup_r+0x34>
10045430:	2209      	movs	r2, #9
10045432:	602a      	str	r2, [r5, #0]
10045434:	2240      	movs	r2, #64	@ 0x40
10045436:	2001      	movs	r0, #1
10045438:	4313      	orrs	r3, r2
1004543a:	81a3      	strh	r3, [r4, #12]
1004543c:	4240      	negs	r0, r0
1004543e:	e03a      	b.n	100454b6 <__swsetup_r+0xaa>
10045440:	075b      	lsls	r3, r3, #29
10045442:	d513      	bpl.n	1004546c <__swsetup_r+0x60>
10045444:	6b61      	ldr	r1, [r4, #52]	@ 0x34
10045446:	2900      	cmp	r1, #0
10045448:	d008      	beq.n	1004545c <__swsetup_r+0x50>
1004544a:	0023      	movs	r3, r4
1004544c:	3344      	adds	r3, #68	@ 0x44
1004544e:	4299      	cmp	r1, r3
10045450:	d002      	beq.n	10045458 <__swsetup_r+0x4c>
10045452:	0028      	movs	r0, r5
10045454:	f7ff fa7e 	bl	10044954 <_free_r>
10045458:	2300      	movs	r3, #0
1004545a:	6363      	str	r3, [r4, #52]	@ 0x34
1004545c:	2224      	movs	r2, #36	@ 0x24
1004545e:	89a3      	ldrh	r3, [r4, #12]
10045460:	4393      	bics	r3, r2
10045462:	81a3      	strh	r3, [r4, #12]
10045464:	2300      	movs	r3, #0
10045466:	6063      	str	r3, [r4, #4]
10045468:	6923      	ldr	r3, [r4, #16]
1004546a:	6023      	str	r3, [r4, #0]
1004546c:	2308      	movs	r3, #8
1004546e:	89a2      	ldrh	r2, [r4, #12]
10045470:	4313      	orrs	r3, r2
10045472:	81a3      	strh	r3, [r4, #12]
10045474:	6923      	ldr	r3, [r4, #16]
10045476:	2b00      	cmp	r3, #0
10045478:	d10b      	bne.n	10045492 <__swsetup_r+0x86>
1004547a:	21a0      	movs	r1, #160	@ 0xa0
1004547c:	2280      	movs	r2, #128	@ 0x80
1004547e:	89a3      	ldrh	r3, [r4, #12]
10045480:	0089      	lsls	r1, r1, #2
10045482:	0092      	lsls	r2, r2, #2
10045484:	400b      	ands	r3, r1
10045486:	4293      	cmp	r3, r2
10045488:	d003      	beq.n	10045492 <__swsetup_r+0x86>
1004548a:	0021      	movs	r1, r4
1004548c:	0028      	movs	r0, r5
1004548e:	f7ff ff03 	bl	10045298 <__smakebuf_r>
10045492:	220c      	movs	r2, #12
10045494:	5ea3      	ldrsh	r3, [r4, r2]
10045496:	2101      	movs	r1, #1
10045498:	001a      	movs	r2, r3
1004549a:	400a      	ands	r2, r1
1004549c:	420b      	tst	r3, r1
1004549e:	d00b      	beq.n	100454b8 <__swsetup_r+0xac>
100454a0:	2200      	movs	r2, #0
100454a2:	60a2      	str	r2, [r4, #8]
100454a4:	6962      	ldr	r2, [r4, #20]
100454a6:	4252      	negs	r2, r2
100454a8:	61a2      	str	r2, [r4, #24]
100454aa:	2000      	movs	r0, #0
100454ac:	6922      	ldr	r2, [r4, #16]
100454ae:	4282      	cmp	r2, r0
100454b0:	d101      	bne.n	100454b6 <__swsetup_r+0xaa>
100454b2:	061a      	lsls	r2, r3, #24
100454b4:	d4be      	bmi.n	10045434 <__swsetup_r+0x28>
100454b6:	bd70      	pop	{r4, r5, r6, pc}
100454b8:	0799      	lsls	r1, r3, #30
100454ba:	d400      	bmi.n	100454be <__swsetup_r+0xb2>
100454bc:	6962      	ldr	r2, [r4, #20]
100454be:	60a2      	str	r2, [r4, #8]
100454c0:	e7f3      	b.n	100454aa <__swsetup_r+0x9e>
100454c2:	46c0      	nop			@ (mov r8, r8)
100454c4:	200006a4 	.word	0x200006a4

100454c8 <_fstat_r>:
100454c8:	2300      	movs	r3, #0
100454ca:	b570      	push	{r4, r5, r6, lr}
100454cc:	4d06      	ldr	r5, [pc, #24]	@ (100454e8 <_fstat_r+0x20>)
100454ce:	0004      	movs	r4, r0
100454d0:	0008      	movs	r0, r1
100454d2:	0011      	movs	r1, r2
100454d4:	602b      	str	r3, [r5, #0]
100454d6:	f7fb fcd1 	bl	10040e7c <_fstat>
100454da:	1c43      	adds	r3, r0, #1
100454dc:	d103      	bne.n	100454e6 <_fstat_r+0x1e>
100454de:	682b      	ldr	r3, [r5, #0]
100454e0:	2b00      	cmp	r3, #0
100454e2:	d000      	beq.n	100454e6 <_fstat_r+0x1e>
100454e4:	6023      	str	r3, [r4, #0]
100454e6:	bd70      	pop	{r4, r5, r6, pc}
100454e8:	20000674 	.word	0x20000674

100454ec <_isatty_r>:
100454ec:	2300      	movs	r3, #0
100454ee:	b570      	push	{r4, r5, r6, lr}
100454f0:	4d06      	ldr	r5, [pc, #24]	@ (1004550c <_isatty_r+0x20>)
100454f2:	0004      	movs	r4, r0
100454f4:	0008      	movs	r0, r1
100454f6:	602b      	str	r3, [r5, #0]
100454f8:	f7fb fcce 	bl	10040e98 <_isatty>
100454fc:	1c43      	adds	r3, r0, #1
100454fe:	d103      	bne.n	10045508 <_isatty_r+0x1c>
10045500:	682b      	ldr	r3, [r5, #0]
10045502:	2b00      	cmp	r3, #0
10045504:	d000      	beq.n	10045508 <_isatty_r+0x1c>
10045506:	6023      	str	r3, [r4, #0]
10045508:	bd70      	pop	{r4, r5, r6, pc}
1004550a:	46c0      	nop			@ (mov r8, r8)
1004550c:	20000674 	.word	0x20000674

10045510 <_sbrk_r>:
10045510:	2300      	movs	r3, #0
10045512:	b570      	push	{r4, r5, r6, lr}
10045514:	4d06      	ldr	r5, [pc, #24]	@ (10045530 <_sbrk_r+0x20>)
10045516:	0004      	movs	r4, r0
10045518:	0008      	movs	r0, r1
1004551a:	602b      	str	r3, [r5, #0]
1004551c:	f7fb fcd0 	bl	10040ec0 <_sbrk>
10045520:	1c43      	adds	r3, r0, #1
10045522:	d103      	bne.n	1004552c <_sbrk_r+0x1c>
10045524:	682b      	ldr	r3, [r5, #0]
10045526:	2b00      	cmp	r3, #0
10045528:	d000      	beq.n	1004552c <_sbrk_r+0x1c>
1004552a:	6023      	str	r3, [r4, #0]
1004552c:	bd70      	pop	{r4, r5, r6, pc}
1004552e:	46c0      	nop			@ (mov r8, r8)
10045530:	20000674 	.word	0x20000674

10045534 <memchr>:
10045534:	b2c9      	uxtb	r1, r1
10045536:	1882      	adds	r2, r0, r2
10045538:	4290      	cmp	r0, r2
1004553a:	d101      	bne.n	10045540 <memchr+0xc>
1004553c:	2000      	movs	r0, #0
1004553e:	4770      	bx	lr
10045540:	7803      	ldrb	r3, [r0, #0]
10045542:	428b      	cmp	r3, r1
10045544:	d0fb      	beq.n	1004553e <memchr+0xa>
10045546:	3001      	adds	r0, #1
10045548:	e7f6      	b.n	10045538 <memchr+0x4>
1004554a:	0000      	movs	r0, r0
1004554c:	334d5453 	.word	0x334d5453
10045550:	334c5732 	.word	0x334c5732
10045554:	61684320 	.word	0x61684320
10045558:	70412074 	.word	0x70412074
1004555c:	63696c70 	.word	0x63696c70
10045560:	6f697461 	.word	0x6f697461
10045564:	0d0a2e6e 	.word	0x0d0a2e6e
10045568:	00000000 	.word	0x00000000
1004556c:	003e7874 	.word	0x003e7874
10045570:	78720d0a 	.word	0x78720d0a
10045574:	0000003e 	.word	0x0000003e
10045578:	78740d0a 	.word	0x78740d0a
1004557c:	0000003e 	.word	0x0000003e

10045580 <s_Channel_Filter_Bandwidth>:
10045580:	00186a00 00170a70 0015b2b0 00145320     .j..p....... S..
10045590:	0012fb60 00119bd0 00104410 000ee480     `........D......
100455a0:	000d8cc0 000c3500 000b8538 000ad958     .....5..8...X...
100455b0:	000a2990 00097db0 0008cde8 00082208     .)...}......."..
100455c0:	00077240 0006c660 00061a80 0005c0a8     @r..`...........
100455d0:	00056ab8 000514c8 0004bed8 00046500     .j...........e..
100455e0:	00040f10 0003b920 00036330 00030d40     .... ...0c..@...
100455f0:	0002de60 0002b750 00028870 00025d78     `...P...p...x]..
10045600:	00023280 00020788 0001dc90 0001b198     .2..............
10045610:	000186a0 000170c0 00015b44 00014564     .....p..D[..dE..
10045620:	00012fe8 00011a08 0001048c 0000eeac     ./..............
10045630:	0000d930 0000c350 0000b860 0000ad70     0...P...`...p...
10045640:	0000a280 000097f4 00008d04 00008214     ................
10045650:	00007724 00006c98 000061a8 00005c30     $w...l...a..0\..
10045660:	000056b8 00005140 00004bc8 000046b4     .V..@Q...K...F..
10045670:	000040d8 00003bc4 0000364c 000030d4     .@...;..L6...0..
10045680:	00002e18 00002b5c 000028a0 000025e4     ....\+...(...%..
10045690:	00002328 0000206c 00001db0 00001af4     (#..l ..........
100456a0:	000017ed 00001716 000015ae 00001450     ............P...
100456b0:	00001306 00001194 00001004 00000ed8     ................
100456c0:	00000dac 00000c35 00000b7c 00000adc     ....5...|.......
100456d0:	00000a28 00000960 00000898 00000834     (...`.......4...
100456e0:	0000076c 000006a4 00000000 00000000     l...............
	...

1004570c <UARTPrescTable>:
1004570c:	00020001 00060004 000a0008 0010000c     ................
1004571c:	00400020 01000080 2b302d23 6c680020      .@.....#-0+ .hl
1004572c:	6665004c 47464567 32313000 36353433     L.efgEFG.0123456
1004573c:	41393837 45444342 31300046 35343332     789ABCDEF.012345
1004574c:	39383736 64636261 00006665              6789abcdef..

Disassembly of section .init:

10045758 <_init>:
10045758:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
1004575a:	46c0      	nop			@ (mov r8, r8)

Disassembly of section .fini:

1004575c <_fini>:
1004575c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
1004575e:	46c0      	nop			@ (mov r8, r8)
