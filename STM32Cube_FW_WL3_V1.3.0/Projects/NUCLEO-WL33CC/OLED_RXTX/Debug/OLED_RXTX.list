
OLED_RXTX.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .intvec       000000c0  10040000  10040000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000045a8  100400c0  100400c0  000010c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .init         00000004  10044668  10044668  00005668  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .fini         00000004  1004466c  1004466c  0000566c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .ARM.exidx    00000008  10044670  10044670  00005670  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .data         0000003c  20000338  10044678  00006338  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .ram_preamble 0000002c  20000004  10044678  00006004  2**2
                  ALLOC
  7 .bss          00000304  20000034  20000034  00007034  2**2
                  ALLOC
  8 .noinit       00000000  20000374  100446b4  00000000  2**0
                  ALLOC
  9 .heap         00000000  20000374  20000374  00006374  2**0
                  CONTENTS
 10 CSTACK        00000c00  20007400  20007400  00006400  2**0
                  ALLOC
 11 .rom_info     00000000  10000000  10000000  00006374  2**0
                  CONTENTS
 12 .ARM.attributes 00000028  00000000  00000000  00006374  2**0
                  CONTENTS, READONLY
 13 .debug_info   0000f2a5  00000000  00000000  0000639c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_abbrev 000024f2  00000000  00000000  00015641  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_aranges 00000e38  00000000  00000000  00017b38  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_rnglists 00000aeb  00000000  00000000  00018970  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_macro  0001da09  00000000  00000000  0001945b  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_line   000111af  00000000  00000000  00036e64  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_str    000cfe94  00000000  00000000  00048013  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .comment      00000043  00000000  00000000  00117ea7  2**0
                  CONTENTS, READONLY
 21 .debug_frame  000032ac  00000000  00000000  00117eec  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 22 .debug_line_str 00000081  00000000  00000000  0011b198  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

100400c0 <__udivsi3>:
100400c0:	2200      	movs	r2, #0
100400c2:	0843      	lsrs	r3, r0, #1
100400c4:	428b      	cmp	r3, r1
100400c6:	d374      	bcc.n	100401b2 <__udivsi3+0xf2>
100400c8:	0903      	lsrs	r3, r0, #4
100400ca:	428b      	cmp	r3, r1
100400cc:	d35f      	bcc.n	1004018e <__udivsi3+0xce>
100400ce:	0a03      	lsrs	r3, r0, #8
100400d0:	428b      	cmp	r3, r1
100400d2:	d344      	bcc.n	1004015e <__udivsi3+0x9e>
100400d4:	0b03      	lsrs	r3, r0, #12
100400d6:	428b      	cmp	r3, r1
100400d8:	d328      	bcc.n	1004012c <__udivsi3+0x6c>
100400da:	0c03      	lsrs	r3, r0, #16
100400dc:	428b      	cmp	r3, r1
100400de:	d30d      	bcc.n	100400fc <__udivsi3+0x3c>
100400e0:	22ff      	movs	r2, #255	@ 0xff
100400e2:	0209      	lsls	r1, r1, #8
100400e4:	ba12      	rev	r2, r2
100400e6:	0c03      	lsrs	r3, r0, #16
100400e8:	428b      	cmp	r3, r1
100400ea:	d302      	bcc.n	100400f2 <__udivsi3+0x32>
100400ec:	1212      	asrs	r2, r2, #8
100400ee:	0209      	lsls	r1, r1, #8
100400f0:	d065      	beq.n	100401be <__udivsi3+0xfe>
100400f2:	0b03      	lsrs	r3, r0, #12
100400f4:	428b      	cmp	r3, r1
100400f6:	d319      	bcc.n	1004012c <__udivsi3+0x6c>
100400f8:	e000      	b.n	100400fc <__udivsi3+0x3c>
100400fa:	0a09      	lsrs	r1, r1, #8
100400fc:	0bc3      	lsrs	r3, r0, #15
100400fe:	428b      	cmp	r3, r1
10040100:	d301      	bcc.n	10040106 <__udivsi3+0x46>
10040102:	03cb      	lsls	r3, r1, #15
10040104:	1ac0      	subs	r0, r0, r3
10040106:	4152      	adcs	r2, r2
10040108:	0b83      	lsrs	r3, r0, #14
1004010a:	428b      	cmp	r3, r1
1004010c:	d301      	bcc.n	10040112 <__udivsi3+0x52>
1004010e:	038b      	lsls	r3, r1, #14
10040110:	1ac0      	subs	r0, r0, r3
10040112:	4152      	adcs	r2, r2
10040114:	0b43      	lsrs	r3, r0, #13
10040116:	428b      	cmp	r3, r1
10040118:	d301      	bcc.n	1004011e <__udivsi3+0x5e>
1004011a:	034b      	lsls	r3, r1, #13
1004011c:	1ac0      	subs	r0, r0, r3
1004011e:	4152      	adcs	r2, r2
10040120:	0b03      	lsrs	r3, r0, #12
10040122:	428b      	cmp	r3, r1
10040124:	d301      	bcc.n	1004012a <__udivsi3+0x6a>
10040126:	030b      	lsls	r3, r1, #12
10040128:	1ac0      	subs	r0, r0, r3
1004012a:	4152      	adcs	r2, r2
1004012c:	0ac3      	lsrs	r3, r0, #11
1004012e:	428b      	cmp	r3, r1
10040130:	d301      	bcc.n	10040136 <__udivsi3+0x76>
10040132:	02cb      	lsls	r3, r1, #11
10040134:	1ac0      	subs	r0, r0, r3
10040136:	4152      	adcs	r2, r2
10040138:	0a83      	lsrs	r3, r0, #10
1004013a:	428b      	cmp	r3, r1
1004013c:	d301      	bcc.n	10040142 <__udivsi3+0x82>
1004013e:	028b      	lsls	r3, r1, #10
10040140:	1ac0      	subs	r0, r0, r3
10040142:	4152      	adcs	r2, r2
10040144:	0a43      	lsrs	r3, r0, #9
10040146:	428b      	cmp	r3, r1
10040148:	d301      	bcc.n	1004014e <__udivsi3+0x8e>
1004014a:	024b      	lsls	r3, r1, #9
1004014c:	1ac0      	subs	r0, r0, r3
1004014e:	4152      	adcs	r2, r2
10040150:	0a03      	lsrs	r3, r0, #8
10040152:	428b      	cmp	r3, r1
10040154:	d301      	bcc.n	1004015a <__udivsi3+0x9a>
10040156:	020b      	lsls	r3, r1, #8
10040158:	1ac0      	subs	r0, r0, r3
1004015a:	4152      	adcs	r2, r2
1004015c:	d2cd      	bcs.n	100400fa <__udivsi3+0x3a>
1004015e:	09c3      	lsrs	r3, r0, #7
10040160:	428b      	cmp	r3, r1
10040162:	d301      	bcc.n	10040168 <__udivsi3+0xa8>
10040164:	01cb      	lsls	r3, r1, #7
10040166:	1ac0      	subs	r0, r0, r3
10040168:	4152      	adcs	r2, r2
1004016a:	0983      	lsrs	r3, r0, #6
1004016c:	428b      	cmp	r3, r1
1004016e:	d301      	bcc.n	10040174 <__udivsi3+0xb4>
10040170:	018b      	lsls	r3, r1, #6
10040172:	1ac0      	subs	r0, r0, r3
10040174:	4152      	adcs	r2, r2
10040176:	0943      	lsrs	r3, r0, #5
10040178:	428b      	cmp	r3, r1
1004017a:	d301      	bcc.n	10040180 <__udivsi3+0xc0>
1004017c:	014b      	lsls	r3, r1, #5
1004017e:	1ac0      	subs	r0, r0, r3
10040180:	4152      	adcs	r2, r2
10040182:	0903      	lsrs	r3, r0, #4
10040184:	428b      	cmp	r3, r1
10040186:	d301      	bcc.n	1004018c <__udivsi3+0xcc>
10040188:	010b      	lsls	r3, r1, #4
1004018a:	1ac0      	subs	r0, r0, r3
1004018c:	4152      	adcs	r2, r2
1004018e:	08c3      	lsrs	r3, r0, #3
10040190:	428b      	cmp	r3, r1
10040192:	d301      	bcc.n	10040198 <__udivsi3+0xd8>
10040194:	00cb      	lsls	r3, r1, #3
10040196:	1ac0      	subs	r0, r0, r3
10040198:	4152      	adcs	r2, r2
1004019a:	0883      	lsrs	r3, r0, #2
1004019c:	428b      	cmp	r3, r1
1004019e:	d301      	bcc.n	100401a4 <__udivsi3+0xe4>
100401a0:	008b      	lsls	r3, r1, #2
100401a2:	1ac0      	subs	r0, r0, r3
100401a4:	4152      	adcs	r2, r2
100401a6:	0843      	lsrs	r3, r0, #1
100401a8:	428b      	cmp	r3, r1
100401aa:	d301      	bcc.n	100401b0 <__udivsi3+0xf0>
100401ac:	004b      	lsls	r3, r1, #1
100401ae:	1ac0      	subs	r0, r0, r3
100401b0:	4152      	adcs	r2, r2
100401b2:	1a41      	subs	r1, r0, r1
100401b4:	d200      	bcs.n	100401b8 <__udivsi3+0xf8>
100401b6:	4601      	mov	r1, r0
100401b8:	4152      	adcs	r2, r2
100401ba:	4610      	mov	r0, r2
100401bc:	4770      	bx	lr
100401be:	e7ff      	b.n	100401c0 <__udivsi3+0x100>
100401c0:	b501      	push	{r0, lr}
100401c2:	2000      	movs	r0, #0
100401c4:	f000 f8f0 	bl	100403a8 <__aeabi_idiv0>
100401c8:	bd02      	pop	{r1, pc}
100401ca:	46c0      	nop			@ (mov r8, r8)

100401cc <__aeabi_uidivmod>:
100401cc:	2900      	cmp	r1, #0
100401ce:	d0f7      	beq.n	100401c0 <__udivsi3+0x100>
100401d0:	e776      	b.n	100400c0 <__udivsi3>
100401d2:	4770      	bx	lr

100401d4 <__divsi3>:
100401d4:	4603      	mov	r3, r0
100401d6:	430b      	orrs	r3, r1
100401d8:	d47f      	bmi.n	100402da <__divsi3+0x106>
100401da:	2200      	movs	r2, #0
100401dc:	0843      	lsrs	r3, r0, #1
100401de:	428b      	cmp	r3, r1
100401e0:	d374      	bcc.n	100402cc <__divsi3+0xf8>
100401e2:	0903      	lsrs	r3, r0, #4
100401e4:	428b      	cmp	r3, r1
100401e6:	d35f      	bcc.n	100402a8 <__divsi3+0xd4>
100401e8:	0a03      	lsrs	r3, r0, #8
100401ea:	428b      	cmp	r3, r1
100401ec:	d344      	bcc.n	10040278 <__divsi3+0xa4>
100401ee:	0b03      	lsrs	r3, r0, #12
100401f0:	428b      	cmp	r3, r1
100401f2:	d328      	bcc.n	10040246 <__divsi3+0x72>
100401f4:	0c03      	lsrs	r3, r0, #16
100401f6:	428b      	cmp	r3, r1
100401f8:	d30d      	bcc.n	10040216 <__divsi3+0x42>
100401fa:	22ff      	movs	r2, #255	@ 0xff
100401fc:	0209      	lsls	r1, r1, #8
100401fe:	ba12      	rev	r2, r2
10040200:	0c03      	lsrs	r3, r0, #16
10040202:	428b      	cmp	r3, r1
10040204:	d302      	bcc.n	1004020c <__divsi3+0x38>
10040206:	1212      	asrs	r2, r2, #8
10040208:	0209      	lsls	r1, r1, #8
1004020a:	d065      	beq.n	100402d8 <__divsi3+0x104>
1004020c:	0b03      	lsrs	r3, r0, #12
1004020e:	428b      	cmp	r3, r1
10040210:	d319      	bcc.n	10040246 <__divsi3+0x72>
10040212:	e000      	b.n	10040216 <__divsi3+0x42>
10040214:	0a09      	lsrs	r1, r1, #8
10040216:	0bc3      	lsrs	r3, r0, #15
10040218:	428b      	cmp	r3, r1
1004021a:	d301      	bcc.n	10040220 <__divsi3+0x4c>
1004021c:	03cb      	lsls	r3, r1, #15
1004021e:	1ac0      	subs	r0, r0, r3
10040220:	4152      	adcs	r2, r2
10040222:	0b83      	lsrs	r3, r0, #14
10040224:	428b      	cmp	r3, r1
10040226:	d301      	bcc.n	1004022c <__divsi3+0x58>
10040228:	038b      	lsls	r3, r1, #14
1004022a:	1ac0      	subs	r0, r0, r3
1004022c:	4152      	adcs	r2, r2
1004022e:	0b43      	lsrs	r3, r0, #13
10040230:	428b      	cmp	r3, r1
10040232:	d301      	bcc.n	10040238 <__divsi3+0x64>
10040234:	034b      	lsls	r3, r1, #13
10040236:	1ac0      	subs	r0, r0, r3
10040238:	4152      	adcs	r2, r2
1004023a:	0b03      	lsrs	r3, r0, #12
1004023c:	428b      	cmp	r3, r1
1004023e:	d301      	bcc.n	10040244 <__divsi3+0x70>
10040240:	030b      	lsls	r3, r1, #12
10040242:	1ac0      	subs	r0, r0, r3
10040244:	4152      	adcs	r2, r2
10040246:	0ac3      	lsrs	r3, r0, #11
10040248:	428b      	cmp	r3, r1
1004024a:	d301      	bcc.n	10040250 <__divsi3+0x7c>
1004024c:	02cb      	lsls	r3, r1, #11
1004024e:	1ac0      	subs	r0, r0, r3
10040250:	4152      	adcs	r2, r2
10040252:	0a83      	lsrs	r3, r0, #10
10040254:	428b      	cmp	r3, r1
10040256:	d301      	bcc.n	1004025c <__divsi3+0x88>
10040258:	028b      	lsls	r3, r1, #10
1004025a:	1ac0      	subs	r0, r0, r3
1004025c:	4152      	adcs	r2, r2
1004025e:	0a43      	lsrs	r3, r0, #9
10040260:	428b      	cmp	r3, r1
10040262:	d301      	bcc.n	10040268 <__divsi3+0x94>
10040264:	024b      	lsls	r3, r1, #9
10040266:	1ac0      	subs	r0, r0, r3
10040268:	4152      	adcs	r2, r2
1004026a:	0a03      	lsrs	r3, r0, #8
1004026c:	428b      	cmp	r3, r1
1004026e:	d301      	bcc.n	10040274 <__divsi3+0xa0>
10040270:	020b      	lsls	r3, r1, #8
10040272:	1ac0      	subs	r0, r0, r3
10040274:	4152      	adcs	r2, r2
10040276:	d2cd      	bcs.n	10040214 <__divsi3+0x40>
10040278:	09c3      	lsrs	r3, r0, #7
1004027a:	428b      	cmp	r3, r1
1004027c:	d301      	bcc.n	10040282 <__divsi3+0xae>
1004027e:	01cb      	lsls	r3, r1, #7
10040280:	1ac0      	subs	r0, r0, r3
10040282:	4152      	adcs	r2, r2
10040284:	0983      	lsrs	r3, r0, #6
10040286:	428b      	cmp	r3, r1
10040288:	d301      	bcc.n	1004028e <__divsi3+0xba>
1004028a:	018b      	lsls	r3, r1, #6
1004028c:	1ac0      	subs	r0, r0, r3
1004028e:	4152      	adcs	r2, r2
10040290:	0943      	lsrs	r3, r0, #5
10040292:	428b      	cmp	r3, r1
10040294:	d301      	bcc.n	1004029a <__divsi3+0xc6>
10040296:	014b      	lsls	r3, r1, #5
10040298:	1ac0      	subs	r0, r0, r3
1004029a:	4152      	adcs	r2, r2
1004029c:	0903      	lsrs	r3, r0, #4
1004029e:	428b      	cmp	r3, r1
100402a0:	d301      	bcc.n	100402a6 <__divsi3+0xd2>
100402a2:	010b      	lsls	r3, r1, #4
100402a4:	1ac0      	subs	r0, r0, r3
100402a6:	4152      	adcs	r2, r2
100402a8:	08c3      	lsrs	r3, r0, #3
100402aa:	428b      	cmp	r3, r1
100402ac:	d301      	bcc.n	100402b2 <__divsi3+0xde>
100402ae:	00cb      	lsls	r3, r1, #3
100402b0:	1ac0      	subs	r0, r0, r3
100402b2:	4152      	adcs	r2, r2
100402b4:	0883      	lsrs	r3, r0, #2
100402b6:	428b      	cmp	r3, r1
100402b8:	d301      	bcc.n	100402be <__divsi3+0xea>
100402ba:	008b      	lsls	r3, r1, #2
100402bc:	1ac0      	subs	r0, r0, r3
100402be:	4152      	adcs	r2, r2
100402c0:	0843      	lsrs	r3, r0, #1
100402c2:	428b      	cmp	r3, r1
100402c4:	d301      	bcc.n	100402ca <__divsi3+0xf6>
100402c6:	004b      	lsls	r3, r1, #1
100402c8:	1ac0      	subs	r0, r0, r3
100402ca:	4152      	adcs	r2, r2
100402cc:	1a41      	subs	r1, r0, r1
100402ce:	d200      	bcs.n	100402d2 <__divsi3+0xfe>
100402d0:	4601      	mov	r1, r0
100402d2:	4152      	adcs	r2, r2
100402d4:	4610      	mov	r0, r2
100402d6:	4770      	bx	lr
100402d8:	e05d      	b.n	10040396 <__divsi3+0x1c2>
100402da:	0fca      	lsrs	r2, r1, #31
100402dc:	d000      	beq.n	100402e0 <__divsi3+0x10c>
100402de:	4249      	negs	r1, r1
100402e0:	1003      	asrs	r3, r0, #32
100402e2:	d300      	bcc.n	100402e6 <__divsi3+0x112>
100402e4:	4240      	negs	r0, r0
100402e6:	4053      	eors	r3, r2
100402e8:	2200      	movs	r2, #0
100402ea:	469c      	mov	ip, r3
100402ec:	0903      	lsrs	r3, r0, #4
100402ee:	428b      	cmp	r3, r1
100402f0:	d32d      	bcc.n	1004034e <__divsi3+0x17a>
100402f2:	0a03      	lsrs	r3, r0, #8
100402f4:	428b      	cmp	r3, r1
100402f6:	d312      	bcc.n	1004031e <__divsi3+0x14a>
100402f8:	22fc      	movs	r2, #252	@ 0xfc
100402fa:	0189      	lsls	r1, r1, #6
100402fc:	ba12      	rev	r2, r2
100402fe:	0a03      	lsrs	r3, r0, #8
10040300:	428b      	cmp	r3, r1
10040302:	d30c      	bcc.n	1004031e <__divsi3+0x14a>
10040304:	0189      	lsls	r1, r1, #6
10040306:	1192      	asrs	r2, r2, #6
10040308:	428b      	cmp	r3, r1
1004030a:	d308      	bcc.n	1004031e <__divsi3+0x14a>
1004030c:	0189      	lsls	r1, r1, #6
1004030e:	1192      	asrs	r2, r2, #6
10040310:	428b      	cmp	r3, r1
10040312:	d304      	bcc.n	1004031e <__divsi3+0x14a>
10040314:	0189      	lsls	r1, r1, #6
10040316:	d03a      	beq.n	1004038e <__divsi3+0x1ba>
10040318:	1192      	asrs	r2, r2, #6
1004031a:	e000      	b.n	1004031e <__divsi3+0x14a>
1004031c:	0989      	lsrs	r1, r1, #6
1004031e:	09c3      	lsrs	r3, r0, #7
10040320:	428b      	cmp	r3, r1
10040322:	d301      	bcc.n	10040328 <__divsi3+0x154>
10040324:	01cb      	lsls	r3, r1, #7
10040326:	1ac0      	subs	r0, r0, r3
10040328:	4152      	adcs	r2, r2
1004032a:	0983      	lsrs	r3, r0, #6
1004032c:	428b      	cmp	r3, r1
1004032e:	d301      	bcc.n	10040334 <__divsi3+0x160>
10040330:	018b      	lsls	r3, r1, #6
10040332:	1ac0      	subs	r0, r0, r3
10040334:	4152      	adcs	r2, r2
10040336:	0943      	lsrs	r3, r0, #5
10040338:	428b      	cmp	r3, r1
1004033a:	d301      	bcc.n	10040340 <__divsi3+0x16c>
1004033c:	014b      	lsls	r3, r1, #5
1004033e:	1ac0      	subs	r0, r0, r3
10040340:	4152      	adcs	r2, r2
10040342:	0903      	lsrs	r3, r0, #4
10040344:	428b      	cmp	r3, r1
10040346:	d301      	bcc.n	1004034c <__divsi3+0x178>
10040348:	010b      	lsls	r3, r1, #4
1004034a:	1ac0      	subs	r0, r0, r3
1004034c:	4152      	adcs	r2, r2
1004034e:	08c3      	lsrs	r3, r0, #3
10040350:	428b      	cmp	r3, r1
10040352:	d301      	bcc.n	10040358 <__divsi3+0x184>
10040354:	00cb      	lsls	r3, r1, #3
10040356:	1ac0      	subs	r0, r0, r3
10040358:	4152      	adcs	r2, r2
1004035a:	0883      	lsrs	r3, r0, #2
1004035c:	428b      	cmp	r3, r1
1004035e:	d301      	bcc.n	10040364 <__divsi3+0x190>
10040360:	008b      	lsls	r3, r1, #2
10040362:	1ac0      	subs	r0, r0, r3
10040364:	4152      	adcs	r2, r2
10040366:	d2d9      	bcs.n	1004031c <__divsi3+0x148>
10040368:	0843      	lsrs	r3, r0, #1
1004036a:	428b      	cmp	r3, r1
1004036c:	d301      	bcc.n	10040372 <__divsi3+0x19e>
1004036e:	004b      	lsls	r3, r1, #1
10040370:	1ac0      	subs	r0, r0, r3
10040372:	4152      	adcs	r2, r2
10040374:	1a41      	subs	r1, r0, r1
10040376:	d200      	bcs.n	1004037a <__divsi3+0x1a6>
10040378:	4601      	mov	r1, r0
1004037a:	4663      	mov	r3, ip
1004037c:	4152      	adcs	r2, r2
1004037e:	105b      	asrs	r3, r3, #1
10040380:	4610      	mov	r0, r2
10040382:	d301      	bcc.n	10040388 <__divsi3+0x1b4>
10040384:	4240      	negs	r0, r0
10040386:	2b00      	cmp	r3, #0
10040388:	d500      	bpl.n	1004038c <__divsi3+0x1b8>
1004038a:	4249      	negs	r1, r1
1004038c:	4770      	bx	lr
1004038e:	4663      	mov	r3, ip
10040390:	105b      	asrs	r3, r3, #1
10040392:	d300      	bcc.n	10040396 <__divsi3+0x1c2>
10040394:	4240      	negs	r0, r0
10040396:	b501      	push	{r0, lr}
10040398:	2000      	movs	r0, #0
1004039a:	f000 f805 	bl	100403a8 <__aeabi_idiv0>
1004039e:	bd02      	pop	{r1, pc}

100403a0 <__aeabi_idivmod>:
100403a0:	2900      	cmp	r1, #0
100403a2:	d0f8      	beq.n	10040396 <__divsi3+0x1c2>
100403a4:	e716      	b.n	100401d4 <__divsi3>
100403a6:	4770      	bx	lr

100403a8 <__aeabi_idiv0>:
100403a8:	4770      	bx	lr
100403aa:	46c0      	nop			@ (mov r8, r8)

100403ac <__aeabi_uldivmod>:
100403ac:	2b00      	cmp	r3, #0
100403ae:	d111      	bne.n	100403d4 <__aeabi_uldivmod+0x28>
100403b0:	2a00      	cmp	r2, #0
100403b2:	d10f      	bne.n	100403d4 <__aeabi_uldivmod+0x28>
100403b4:	2900      	cmp	r1, #0
100403b6:	d100      	bne.n	100403ba <__aeabi_uldivmod+0xe>
100403b8:	2800      	cmp	r0, #0
100403ba:	d002      	beq.n	100403c2 <__aeabi_uldivmod+0x16>
100403bc:	2100      	movs	r1, #0
100403be:	43c9      	mvns	r1, r1
100403c0:	0008      	movs	r0, r1
100403c2:	b407      	push	{r0, r1, r2}
100403c4:	4802      	ldr	r0, [pc, #8]	@ (100403d0 <__aeabi_uldivmod+0x24>)
100403c6:	a102      	add	r1, pc, #8	@ (adr r1, 100403d0 <__aeabi_uldivmod+0x24>)
100403c8:	1840      	adds	r0, r0, r1
100403ca:	9002      	str	r0, [sp, #8]
100403cc:	bd03      	pop	{r0, r1, pc}
100403ce:	46c0      	nop			@ (mov r8, r8)
100403d0:	ffffffd9 	.word	0xffffffd9
100403d4:	b403      	push	{r0, r1}
100403d6:	4668      	mov	r0, sp
100403d8:	b501      	push	{r0, lr}
100403da:	9802      	ldr	r0, [sp, #8]
100403dc:	f000 f806 	bl	100403ec <__udivmoddi4>
100403e0:	9b01      	ldr	r3, [sp, #4]
100403e2:	469e      	mov	lr, r3
100403e4:	b002      	add	sp, #8
100403e6:	bc0c      	pop	{r2, r3}
100403e8:	4770      	bx	lr
100403ea:	46c0      	nop			@ (mov r8, r8)

100403ec <__udivmoddi4>:
100403ec:	b5f0      	push	{r4, r5, r6, r7, lr}
100403ee:	4657      	mov	r7, sl
100403f0:	464e      	mov	r6, r9
100403f2:	4645      	mov	r5, r8
100403f4:	46de      	mov	lr, fp
100403f6:	b5e0      	push	{r5, r6, r7, lr}
100403f8:	0004      	movs	r4, r0
100403fa:	000d      	movs	r5, r1
100403fc:	4692      	mov	sl, r2
100403fe:	4699      	mov	r9, r3
10040400:	b083      	sub	sp, #12
10040402:	428b      	cmp	r3, r1
10040404:	d830      	bhi.n	10040468 <__udivmoddi4+0x7c>
10040406:	d02d      	beq.n	10040464 <__udivmoddi4+0x78>
10040408:	4649      	mov	r1, r9
1004040a:	4650      	mov	r0, sl
1004040c:	f000 f8d8 	bl	100405c0 <__clzdi2>
10040410:	0029      	movs	r1, r5
10040412:	0006      	movs	r6, r0
10040414:	0020      	movs	r0, r4
10040416:	f000 f8d3 	bl	100405c0 <__clzdi2>
1004041a:	1a33      	subs	r3, r6, r0
1004041c:	4698      	mov	r8, r3
1004041e:	3b20      	subs	r3, #32
10040420:	d434      	bmi.n	1004048c <__udivmoddi4+0xa0>
10040422:	469b      	mov	fp, r3
10040424:	4653      	mov	r3, sl
10040426:	465a      	mov	r2, fp
10040428:	4093      	lsls	r3, r2
1004042a:	4642      	mov	r2, r8
1004042c:	001f      	movs	r7, r3
1004042e:	4653      	mov	r3, sl
10040430:	4093      	lsls	r3, r2
10040432:	001e      	movs	r6, r3
10040434:	42af      	cmp	r7, r5
10040436:	d83b      	bhi.n	100404b0 <__udivmoddi4+0xc4>
10040438:	42af      	cmp	r7, r5
1004043a:	d100      	bne.n	1004043e <__udivmoddi4+0x52>
1004043c:	e079      	b.n	10040532 <__udivmoddi4+0x146>
1004043e:	465b      	mov	r3, fp
10040440:	1ba4      	subs	r4, r4, r6
10040442:	41bd      	sbcs	r5, r7
10040444:	2b00      	cmp	r3, #0
10040446:	da00      	bge.n	1004044a <__udivmoddi4+0x5e>
10040448:	e076      	b.n	10040538 <__udivmoddi4+0x14c>
1004044a:	2200      	movs	r2, #0
1004044c:	2300      	movs	r3, #0
1004044e:	9200      	str	r2, [sp, #0]
10040450:	9301      	str	r3, [sp, #4]
10040452:	2301      	movs	r3, #1
10040454:	465a      	mov	r2, fp
10040456:	4093      	lsls	r3, r2
10040458:	9301      	str	r3, [sp, #4]
1004045a:	2301      	movs	r3, #1
1004045c:	4642      	mov	r2, r8
1004045e:	4093      	lsls	r3, r2
10040460:	9300      	str	r3, [sp, #0]
10040462:	e029      	b.n	100404b8 <__udivmoddi4+0xcc>
10040464:	4282      	cmp	r2, r0
10040466:	d9cf      	bls.n	10040408 <__udivmoddi4+0x1c>
10040468:	2200      	movs	r2, #0
1004046a:	2300      	movs	r3, #0
1004046c:	9200      	str	r2, [sp, #0]
1004046e:	9301      	str	r3, [sp, #4]
10040470:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
10040472:	2b00      	cmp	r3, #0
10040474:	d001      	beq.n	1004047a <__udivmoddi4+0x8e>
10040476:	601c      	str	r4, [r3, #0]
10040478:	605d      	str	r5, [r3, #4]
1004047a:	9800      	ldr	r0, [sp, #0]
1004047c:	9901      	ldr	r1, [sp, #4]
1004047e:	b003      	add	sp, #12
10040480:	bcf0      	pop	{r4, r5, r6, r7}
10040482:	46bb      	mov	fp, r7
10040484:	46b2      	mov	sl, r6
10040486:	46a9      	mov	r9, r5
10040488:	46a0      	mov	r8, r4
1004048a:	bdf0      	pop	{r4, r5, r6, r7, pc}
1004048c:	4642      	mov	r2, r8
1004048e:	469b      	mov	fp, r3
10040490:	2320      	movs	r3, #32
10040492:	1a9b      	subs	r3, r3, r2
10040494:	4652      	mov	r2, sl
10040496:	40da      	lsrs	r2, r3
10040498:	4641      	mov	r1, r8
1004049a:	0013      	movs	r3, r2
1004049c:	464a      	mov	r2, r9
1004049e:	408a      	lsls	r2, r1
100404a0:	0017      	movs	r7, r2
100404a2:	4642      	mov	r2, r8
100404a4:	431f      	orrs	r7, r3
100404a6:	4653      	mov	r3, sl
100404a8:	4093      	lsls	r3, r2
100404aa:	001e      	movs	r6, r3
100404ac:	42af      	cmp	r7, r5
100404ae:	d9c3      	bls.n	10040438 <__udivmoddi4+0x4c>
100404b0:	2200      	movs	r2, #0
100404b2:	2300      	movs	r3, #0
100404b4:	9200      	str	r2, [sp, #0]
100404b6:	9301      	str	r3, [sp, #4]
100404b8:	4643      	mov	r3, r8
100404ba:	2b00      	cmp	r3, #0
100404bc:	d0d8      	beq.n	10040470 <__udivmoddi4+0x84>
100404be:	07fb      	lsls	r3, r7, #31
100404c0:	0872      	lsrs	r2, r6, #1
100404c2:	431a      	orrs	r2, r3
100404c4:	4646      	mov	r6, r8
100404c6:	087b      	lsrs	r3, r7, #1
100404c8:	e00e      	b.n	100404e8 <__udivmoddi4+0xfc>
100404ca:	42ab      	cmp	r3, r5
100404cc:	d101      	bne.n	100404d2 <__udivmoddi4+0xe6>
100404ce:	42a2      	cmp	r2, r4
100404d0:	d80c      	bhi.n	100404ec <__udivmoddi4+0x100>
100404d2:	1aa4      	subs	r4, r4, r2
100404d4:	419d      	sbcs	r5, r3
100404d6:	2001      	movs	r0, #1
100404d8:	1924      	adds	r4, r4, r4
100404da:	416d      	adcs	r5, r5
100404dc:	2100      	movs	r1, #0
100404de:	3e01      	subs	r6, #1
100404e0:	1824      	adds	r4, r4, r0
100404e2:	414d      	adcs	r5, r1
100404e4:	2e00      	cmp	r6, #0
100404e6:	d006      	beq.n	100404f6 <__udivmoddi4+0x10a>
100404e8:	42ab      	cmp	r3, r5
100404ea:	d9ee      	bls.n	100404ca <__udivmoddi4+0xde>
100404ec:	3e01      	subs	r6, #1
100404ee:	1924      	adds	r4, r4, r4
100404f0:	416d      	adcs	r5, r5
100404f2:	2e00      	cmp	r6, #0
100404f4:	d1f8      	bne.n	100404e8 <__udivmoddi4+0xfc>
100404f6:	9800      	ldr	r0, [sp, #0]
100404f8:	9901      	ldr	r1, [sp, #4]
100404fa:	465b      	mov	r3, fp
100404fc:	1900      	adds	r0, r0, r4
100404fe:	4169      	adcs	r1, r5
10040500:	2b00      	cmp	r3, #0
10040502:	db24      	blt.n	1004054e <__udivmoddi4+0x162>
10040504:	002b      	movs	r3, r5
10040506:	465a      	mov	r2, fp
10040508:	4644      	mov	r4, r8
1004050a:	40d3      	lsrs	r3, r2
1004050c:	002a      	movs	r2, r5
1004050e:	40e2      	lsrs	r2, r4
10040510:	001c      	movs	r4, r3
10040512:	465b      	mov	r3, fp
10040514:	0015      	movs	r5, r2
10040516:	2b00      	cmp	r3, #0
10040518:	db2a      	blt.n	10040570 <__udivmoddi4+0x184>
1004051a:	0026      	movs	r6, r4
1004051c:	409e      	lsls	r6, r3
1004051e:	0033      	movs	r3, r6
10040520:	0026      	movs	r6, r4
10040522:	4647      	mov	r7, r8
10040524:	40be      	lsls	r6, r7
10040526:	0032      	movs	r2, r6
10040528:	1a80      	subs	r0, r0, r2
1004052a:	4199      	sbcs	r1, r3
1004052c:	9000      	str	r0, [sp, #0]
1004052e:	9101      	str	r1, [sp, #4]
10040530:	e79e      	b.n	10040470 <__udivmoddi4+0x84>
10040532:	42a3      	cmp	r3, r4
10040534:	d8bc      	bhi.n	100404b0 <__udivmoddi4+0xc4>
10040536:	e782      	b.n	1004043e <__udivmoddi4+0x52>
10040538:	4642      	mov	r2, r8
1004053a:	2320      	movs	r3, #32
1004053c:	2100      	movs	r1, #0
1004053e:	1a9b      	subs	r3, r3, r2
10040540:	2200      	movs	r2, #0
10040542:	9100      	str	r1, [sp, #0]
10040544:	9201      	str	r2, [sp, #4]
10040546:	2201      	movs	r2, #1
10040548:	40da      	lsrs	r2, r3
1004054a:	9201      	str	r2, [sp, #4]
1004054c:	e785      	b.n	1004045a <__udivmoddi4+0x6e>
1004054e:	4642      	mov	r2, r8
10040550:	2320      	movs	r3, #32
10040552:	1a9b      	subs	r3, r3, r2
10040554:	002a      	movs	r2, r5
10040556:	4646      	mov	r6, r8
10040558:	409a      	lsls	r2, r3
1004055a:	0023      	movs	r3, r4
1004055c:	40f3      	lsrs	r3, r6
1004055e:	4644      	mov	r4, r8
10040560:	4313      	orrs	r3, r2
10040562:	002a      	movs	r2, r5
10040564:	40e2      	lsrs	r2, r4
10040566:	001c      	movs	r4, r3
10040568:	465b      	mov	r3, fp
1004056a:	0015      	movs	r5, r2
1004056c:	2b00      	cmp	r3, #0
1004056e:	dad4      	bge.n	1004051a <__udivmoddi4+0x12e>
10040570:	4642      	mov	r2, r8
10040572:	002f      	movs	r7, r5
10040574:	2320      	movs	r3, #32
10040576:	0026      	movs	r6, r4
10040578:	4097      	lsls	r7, r2
1004057a:	1a9b      	subs	r3, r3, r2
1004057c:	40de      	lsrs	r6, r3
1004057e:	003b      	movs	r3, r7
10040580:	4333      	orrs	r3, r6
10040582:	e7cd      	b.n	10040520 <__udivmoddi4+0x134>

10040584 <__clzsi2>:
10040584:	211c      	movs	r1, #28
10040586:	2301      	movs	r3, #1
10040588:	041b      	lsls	r3, r3, #16
1004058a:	4298      	cmp	r0, r3
1004058c:	d301      	bcc.n	10040592 <__clzsi2+0xe>
1004058e:	0c00      	lsrs	r0, r0, #16
10040590:	3910      	subs	r1, #16
10040592:	0a1b      	lsrs	r3, r3, #8
10040594:	4298      	cmp	r0, r3
10040596:	d301      	bcc.n	1004059c <__clzsi2+0x18>
10040598:	0a00      	lsrs	r0, r0, #8
1004059a:	3908      	subs	r1, #8
1004059c:	091b      	lsrs	r3, r3, #4
1004059e:	4298      	cmp	r0, r3
100405a0:	d301      	bcc.n	100405a6 <__clzsi2+0x22>
100405a2:	0900      	lsrs	r0, r0, #4
100405a4:	3904      	subs	r1, #4
100405a6:	a202      	add	r2, pc, #8	@ (adr r2, 100405b0 <__clzsi2+0x2c>)
100405a8:	5c10      	ldrb	r0, [r2, r0]
100405aa:	1840      	adds	r0, r0, r1
100405ac:	4770      	bx	lr
100405ae:	46c0      	nop			@ (mov r8, r8)
100405b0:	02020304 	.word	0x02020304
100405b4:	01010101 	.word	0x01010101
	...

100405c0 <__clzdi2>:
100405c0:	b510      	push	{r4, lr}
100405c2:	2900      	cmp	r1, #0
100405c4:	d103      	bne.n	100405ce <__clzdi2+0xe>
100405c6:	f7ff ffdd 	bl	10040584 <__clzsi2>
100405ca:	3020      	adds	r0, #32
100405cc:	e002      	b.n	100405d4 <__clzdi2+0x14>
100405ce:	0008      	movs	r0, r1
100405d0:	f7ff ffd8 	bl	10040584 <__clzsi2>
100405d4:	bd10      	pop	{r4, pc}
100405d6:	46c0      	nop			@ (mov r8, r8)

100405d8 <LL_AHB1_GRP1_EnableClock>:
  * @arg LL_AHB1_GRP1_PERIPH_RNG
  * @arg LL_AHB1_GRP1_PERIPH_AES
  * @retval None
  */
__STATIC_INLINE void LL_AHB1_GRP1_EnableClock(uint32_t Periphs)
{
100405d8:	b580      	push	{r7, lr}
100405da:	b084      	sub	sp, #16
100405dc:	af00      	add	r7, sp, #0
100405de:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  SET_BIT(RCC->AHBENR, Periphs);
100405e0:	4b07      	ldr	r3, [pc, #28]	@ (10040600 <LL_AHB1_GRP1_EnableClock+0x28>)
100405e2:	6d19      	ldr	r1, [r3, #80]	@ 0x50
100405e4:	4b06      	ldr	r3, [pc, #24]	@ (10040600 <LL_AHB1_GRP1_EnableClock+0x28>)
100405e6:	687a      	ldr	r2, [r7, #4]
100405e8:	430a      	orrs	r2, r1
100405ea:	651a      	str	r2, [r3, #80]	@ 0x50
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->AHBENR, Periphs);
100405ec:	4b04      	ldr	r3, [pc, #16]	@ (10040600 <LL_AHB1_GRP1_EnableClock+0x28>)
100405ee:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
100405f0:	687a      	ldr	r2, [r7, #4]
100405f2:	4013      	ands	r3, r2
100405f4:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
100405f6:	68fb      	ldr	r3, [r7, #12]
}
100405f8:	46c0      	nop			@ (mov r8, r8)
100405fa:	46bd      	mov	sp, r7
100405fc:	b004      	add	sp, #16
100405fe:	bd80      	pop	{r7, pc}
10040600:	48400000 	.word	0x48400000

10040604 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
10040604:	b590      	push	{r4, r7, lr}
10040606:	b089      	sub	sp, #36	@ 0x24
10040608:	af00      	add	r7, sp, #0
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
1004060a:	f001 f9b5 	bl	10041978 <HAL_Init>
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();
1004060e:	f000 f84b 	bl	100406a8 <SystemClock_Config>

  /* Configure the peripherals common clocks */
  PeriphCommonClock_Config();
10040612:	f000 f879 	bl	10040708 <PeriphCommonClock_Config>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
10040616:	f000 f8d7 	bl	100407c8 <MX_GPIO_Init>
  MX_I2C2_Init();
1004061a:	f000 f895 	bl	10040748 <MX_I2C2_Init>
 // ssd1306_SetCursor(5,5);
 // retVal = ssd1306_WriteString(myText, Font_7x10, White);
 // ssd1306_UpdateScreen();


  ssd1306_Init();
1004061e:	f000 fedf 	bl	100413e0 <ssd1306_Init>

  // Example 32 bars (fits nicely on 128px wide display)
  uint8_t graphValues[32] = {
10040622:	003b      	movs	r3, r7
10040624:	4a1e      	ldr	r2, [pc, #120]	@ (100406a0 <main+0x9c>)
10040626:	ca13      	ldmia	r2!, {r0, r1, r4}
10040628:	c313      	stmia	r3!, {r0, r1, r4}
1004062a:	ca13      	ldmia	r2!, {r0, r1, r4}
1004062c:	c313      	stmia	r3!, {r0, r1, r4}
1004062e:	ca03      	ldmia	r2!, {r0, r1}
10040630:	c303      	stmia	r3!, {r0, r1}
      80,65,50,35,20,10,5, 8,
      15,30,50,70,85,95,70,40,
      30,25,20,15,10,5,3,0
  };

  RenderScreen(graphValues, 32);
10040632:	003b      	movs	r3, r7
10040634:	2120      	movs	r1, #32
10040636:	0018      	movs	r0, r3
10040638:	f000 f9c2 	bl	100409c0 <RenderScreen>


  /* USER CODE END 2 */

  /* Initialize leds */
  BSP_LED_Init(LED_BLUE);
1004063c:	2000      	movs	r0, #0
1004063e:	f000 fccb 	bl	10040fd8 <BSP_LED_Init>
  BSP_LED_Init(LED_GREEN);
10040642:	2001      	movs	r0, #1
10040644:	f000 fcc8 	bl	10040fd8 <BSP_LED_Init>
  BSP_LED_Init(LED_RED);
10040648:	2002      	movs	r0, #2
1004064a:	f000 fcc5 	bl	10040fd8 <BSP_LED_Init>

  /* Initialize USER push-button, will be used to trigger an interrupt each time it's pressed.*/
  BSP_PB_Init(B1, BUTTON_MODE_EXTI);
1004064e:	2101      	movs	r1, #1
10040650:	2000      	movs	r0, #0
10040652:	f000 fd37 	bl	100410c4 <BSP_PB_Init>
  BSP_PB_Init(B2, BUTTON_MODE_EXTI);
10040656:	2101      	movs	r1, #1
10040658:	2001      	movs	r0, #1
1004065a:	f000 fd33 	bl	100410c4 <BSP_PB_Init>
  BSP_PB_Init(B3, BUTTON_MODE_EXTI);
1004065e:	2101      	movs	r1, #1
10040660:	2002      	movs	r0, #2
10040662:	f000 fd2f 	bl	100410c4 <BSP_PB_Init>

  /* Initialize COM1 port (115200, 8 bits (7-bit data + 1 stop bit), no parity */
  BspCOMInit.BaudRate   = 115200;
10040666:	4b0f      	ldr	r3, [pc, #60]	@ (100406a4 <main+0xa0>)
10040668:	22e1      	movs	r2, #225	@ 0xe1
1004066a:	0252      	lsls	r2, r2, #9
1004066c:	601a      	str	r2, [r3, #0]
  BspCOMInit.WordLength = COM_WORDLENGTH_8B;
1004066e:	4b0d      	ldr	r3, [pc, #52]	@ (100406a4 <main+0xa0>)
10040670:	2200      	movs	r2, #0
10040672:	605a      	str	r2, [r3, #4]
  BspCOMInit.StopBits   = COM_STOPBITS_1;
10040674:	4b0b      	ldr	r3, [pc, #44]	@ (100406a4 <main+0xa0>)
10040676:	2200      	movs	r2, #0
10040678:	811a      	strh	r2, [r3, #8]
  BspCOMInit.Parity     = COM_PARITY_NONE;
1004067a:	4b0a      	ldr	r3, [pc, #40]	@ (100406a4 <main+0xa0>)
1004067c:	2200      	movs	r2, #0
1004067e:	815a      	strh	r2, [r3, #10]
  BspCOMInit.HwFlowCtl  = COM_HWCONTROL_NONE;
10040680:	4b08      	ldr	r3, [pc, #32]	@ (100406a4 <main+0xa0>)
10040682:	2200      	movs	r2, #0
10040684:	819a      	strh	r2, [r3, #12]
  if (BSP_COM_Init(COM1, &BspCOMInit) != BSP_ERROR_NONE)
10040686:	4b07      	ldr	r3, [pc, #28]	@ (100406a4 <main+0xa0>)
10040688:	0019      	movs	r1, r3
1004068a:	2000      	movs	r0, #0
1004068c:	f000 fdb6 	bl	100411fc <BSP_COM_Init>
10040690:	1e03      	subs	r3, r0, #0
10040692:	d002      	beq.n	1004069a <main+0x96>
  {
    Error_Handler();
10040694:	f000 f9bc 	bl	10040a10 <Error_Handler>
  }

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
10040698:	46c0      	nop			@ (mov r8, r8)
1004069a:	46c0      	nop			@ (mov r8, r8)
1004069c:	e7fd      	b.n	1004069a <main+0x96>
1004069e:	46c0      	nop			@ (mov r8, r8)
100406a0:	10043ea4 	.word	0x10043ea4
100406a4:	20000034 	.word	0x20000034

100406a8 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
100406a8:	b590      	push	{r4, r7, lr}
100406aa:	b089      	sub	sp, #36	@ 0x24
100406ac:	af00      	add	r7, sp, #0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
100406ae:	2408      	movs	r4, #8
100406b0:	193b      	adds	r3, r7, r4
100406b2:	0018      	movs	r0, r3
100406b4:	2318      	movs	r3, #24
100406b6:	001a      	movs	r2, r3
100406b8:	2100      	movs	r1, #0
100406ba:	f003 fbeb 	bl	10043e94 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
100406be:	003b      	movs	r3, r7
100406c0:	0018      	movs	r0, r3
100406c2:	2308      	movs	r3, #8
100406c4:	001a      	movs	r2, r3
100406c6:	2100      	movs	r1, #0
100406c8:	f003 fbe4 	bl	10043e94 <memset>

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
100406cc:	193b      	adds	r3, r7, r4
100406ce:	2210      	movs	r2, #16
100406d0:	601a      	str	r2, [r3, #0]
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
100406d2:	193b      	adds	r3, r7, r4
100406d4:	0018      	movs	r0, r3
100406d6:	f002 fc51 	bl	10042f7c <HAL_RCC_OscConfig>
100406da:	1e03      	subs	r3, r0, #0
100406dc:	d001      	beq.n	100406e2 <SystemClock_Config+0x3a>
  {
    Error_Handler();
100406de:	f000 f997 	bl	10040a10 <Error_Handler>
  }

  /** Configure the SYSCLKSource and SYSCLKDivider
  */
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
100406e2:	003b      	movs	r3, r7
100406e4:	2202      	movs	r2, #2
100406e6:	601a      	str	r2, [r3, #0]
  RCC_ClkInitStruct.SYSCLKDivider = RCC_RC64MPLL_DIV1;
100406e8:	003b      	movs	r3, r7
100406ea:	2200      	movs	r2, #0
100406ec:	605a      	str	r2, [r3, #4]

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_WAIT_STATES_1) != HAL_OK)
100406ee:	003b      	movs	r3, r7
100406f0:	2110      	movs	r1, #16
100406f2:	0018      	movs	r0, r3
100406f4:	f002 fd98 	bl	10043228 <HAL_RCC_ClockConfig>
100406f8:	1e03      	subs	r3, r0, #0
100406fa:	d001      	beq.n	10040700 <SystemClock_Config+0x58>
  {
    Error_Handler();
100406fc:	f000 f988 	bl	10040a10 <Error_Handler>
  }
}
10040700:	46c0      	nop			@ (mov r8, r8)
10040702:	46bd      	mov	sp, r7
10040704:	b009      	add	sp, #36	@ 0x24
10040706:	bd90      	pop	{r4, r7, pc}

10040708 <PeriphCommonClock_Config>:
/**
  * @brief Peripherals Common Clock Configuration
  * @retval None
  */
void PeriphCommonClock_Config(void)
{
10040708:	b580      	push	{r7, lr}
1004070a:	b086      	sub	sp, #24
1004070c:	af00      	add	r7, sp, #0
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
1004070e:	003b      	movs	r3, r7
10040710:	0018      	movs	r0, r3
10040712:	2318      	movs	r3, #24
10040714:	001a      	movs	r2, r3
10040716:	2100      	movs	r1, #0
10040718:	f003 fbbc 	bl	10043e94 <memset>

  /** Initializes the peripherals clock
  */
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_SMPS;
1004071c:	003b      	movs	r3, r7
1004071e:	2202      	movs	r2, #2
10040720:	601a      	str	r2, [r3, #0]
  PeriphClkInitStruct.SmpsDivSelection = RCC_SMPSCLK_DIV2;
10040722:	003b      	movs	r3, r7
10040724:	2200      	movs	r2, #0
10040726:	611a      	str	r2, [r3, #16]
  PeriphClkInitStruct.KRMRateMultiplier = 2;
10040728:	003b      	movs	r3, r7
1004072a:	2202      	movs	r2, #2
1004072c:	615a      	str	r2, [r3, #20]

  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
1004072e:	003b      	movs	r3, r7
10040730:	0018      	movs	r0, r3
10040732:	f002 fee3 	bl	100434fc <HAL_RCCEx_PeriphCLKConfig>
10040736:	1e03      	subs	r3, r0, #0
10040738:	d001      	beq.n	1004073e <PeriphCommonClock_Config+0x36>
  {
    Error_Handler();
1004073a:	f000 f969 	bl	10040a10 <Error_Handler>
  }
}
1004073e:	46c0      	nop			@ (mov r8, r8)
10040740:	46bd      	mov	sp, r7
10040742:	b006      	add	sp, #24
10040744:	bd80      	pop	{r7, pc}
	...

10040748 <MX_I2C2_Init>:
  * @brief I2C2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_I2C2_Init(void)
{
10040748:	b580      	push	{r7, lr}
1004074a:	af00      	add	r7, sp, #0
  /* USER CODE END I2C2_Init 0 */

  /* USER CODE BEGIN I2C2_Init 1 */

  /* USER CODE END I2C2_Init 1 */
  hi2c2.Instance = I2C2;
1004074c:	4b1b      	ldr	r3, [pc, #108]	@ (100407bc <MX_I2C2_Init+0x74>)
1004074e:	4a1c      	ldr	r2, [pc, #112]	@ (100407c0 <MX_I2C2_Init+0x78>)
10040750:	601a      	str	r2, [r3, #0]
  hi2c2.Init.Timing = 0x00503D58;
10040752:	4b1a      	ldr	r3, [pc, #104]	@ (100407bc <MX_I2C2_Init+0x74>)
10040754:	4a1b      	ldr	r2, [pc, #108]	@ (100407c4 <MX_I2C2_Init+0x7c>)
10040756:	605a      	str	r2, [r3, #4]
  hi2c2.Init.OwnAddress1 = 0;
10040758:	4b18      	ldr	r3, [pc, #96]	@ (100407bc <MX_I2C2_Init+0x74>)
1004075a:	2200      	movs	r2, #0
1004075c:	609a      	str	r2, [r3, #8]
  hi2c2.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
1004075e:	4b17      	ldr	r3, [pc, #92]	@ (100407bc <MX_I2C2_Init+0x74>)
10040760:	2201      	movs	r2, #1
10040762:	60da      	str	r2, [r3, #12]
  hi2c2.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
10040764:	4b15      	ldr	r3, [pc, #84]	@ (100407bc <MX_I2C2_Init+0x74>)
10040766:	2200      	movs	r2, #0
10040768:	611a      	str	r2, [r3, #16]
  hi2c2.Init.OwnAddress2 = 0;
1004076a:	4b14      	ldr	r3, [pc, #80]	@ (100407bc <MX_I2C2_Init+0x74>)
1004076c:	2200      	movs	r2, #0
1004076e:	615a      	str	r2, [r3, #20]
  hi2c2.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
10040770:	4b12      	ldr	r3, [pc, #72]	@ (100407bc <MX_I2C2_Init+0x74>)
10040772:	2200      	movs	r2, #0
10040774:	619a      	str	r2, [r3, #24]
  hi2c2.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
10040776:	4b11      	ldr	r3, [pc, #68]	@ (100407bc <MX_I2C2_Init+0x74>)
10040778:	2200      	movs	r2, #0
1004077a:	61da      	str	r2, [r3, #28]
  hi2c2.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
1004077c:	4b0f      	ldr	r3, [pc, #60]	@ (100407bc <MX_I2C2_Init+0x74>)
1004077e:	2200      	movs	r2, #0
10040780:	621a      	str	r2, [r3, #32]
  if (HAL_I2C_Init(&hi2c2) != HAL_OK)
10040782:	4b0e      	ldr	r3, [pc, #56]	@ (100407bc <MX_I2C2_Init+0x74>)
10040784:	0018      	movs	r0, r3
10040786:	f001 fc51 	bl	1004202c <HAL_I2C_Init>
1004078a:	1e03      	subs	r3, r0, #0
1004078c:	d001      	beq.n	10040792 <MX_I2C2_Init+0x4a>
  {
    Error_Handler();
1004078e:	f000 f93f 	bl	10040a10 <Error_Handler>
  }

  /** Configure Analogue filter
  */
  if (HAL_I2CEx_ConfigAnalogFilter(&hi2c2, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
10040792:	4b0a      	ldr	r3, [pc, #40]	@ (100407bc <MX_I2C2_Init+0x74>)
10040794:	2100      	movs	r1, #0
10040796:	0018      	movs	r0, r3
10040798:	f002 f8b6 	bl	10042908 <HAL_I2CEx_ConfigAnalogFilter>
1004079c:	1e03      	subs	r3, r0, #0
1004079e:	d001      	beq.n	100407a4 <MX_I2C2_Init+0x5c>
  {
    Error_Handler();
100407a0:	f000 f936 	bl	10040a10 <Error_Handler>
  }

  /** Configure Digital filter
  */
  if (HAL_I2CEx_ConfigDigitalFilter(&hi2c2, 0) != HAL_OK)
100407a4:	4b05      	ldr	r3, [pc, #20]	@ (100407bc <MX_I2C2_Init+0x74>)
100407a6:	2100      	movs	r1, #0
100407a8:	0018      	movs	r0, r3
100407aa:	f002 f8f9 	bl	100429a0 <HAL_I2CEx_ConfigDigitalFilter>
100407ae:	1e03      	subs	r3, r0, #0
100407b0:	d001      	beq.n	100407b6 <MX_I2C2_Init+0x6e>
  {
    Error_Handler();
100407b2:	f000 f92d 	bl	10040a10 <Error_Handler>
  }
  /* USER CODE BEGIN I2C2_Init 2 */

  /* USER CODE END I2C2_Init 2 */

}
100407b6:	46c0      	nop			@ (mov r8, r8)
100407b8:	46bd      	mov	sp, r7
100407ba:	bd80      	pop	{r7, pc}
100407bc:	20000044 	.word	0x20000044
100407c0:	41001000 	.word	0x41001000
100407c4:	00503d58 	.word	0x00503d58

100407c8 <MX_GPIO_Init>:
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
100407c8:	b580      	push	{r7, lr}
100407ca:	b086      	sub	sp, #24
100407cc:	af00      	add	r7, sp, #0
  GPIO_InitTypeDef GPIO_InitStruct = {0};
100407ce:	1d3b      	adds	r3, r7, #4
100407d0:	0018      	movs	r0, r3
100407d2:	2314      	movs	r3, #20
100407d4:	001a      	movs	r2, r3
100407d6:	2100      	movs	r1, #0
100407d8:	f003 fb5c 	bl	10043e94 <memset>
  /* USER CODE BEGIN MX_GPIO_Init_1 */

  /* USER CODE END MX_GPIO_Init_1 */

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOA_CLK_ENABLE();
100407dc:	2004      	movs	r0, #4
100407de:	f7ff fefb 	bl	100405d8 <LL_AHB1_GRP1_EnableClock>
  __HAL_RCC_GPIOB_CLK_ENABLE();
100407e2:	2008      	movs	r0, #8
100407e4:	f7ff fef8 	bl	100405d8 <LL_AHB1_GRP1_EnableClock>

  /*Configure GPIO pin : PA2 */
  GPIO_InitStruct.Pin = GPIO_PIN_2;
100407e8:	1d3b      	adds	r3, r7, #4
100407ea:	2204      	movs	r2, #4
100407ec:	601a      	str	r2, [r3, #0]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
100407ee:	1d3b      	adds	r3, r7, #4
100407f0:	2202      	movs	r2, #2
100407f2:	605a      	str	r2, [r3, #4]
  GPIO_InitStruct.Pull = GPIO_PULLUP;
100407f4:	1d3b      	adds	r3, r7, #4
100407f6:	2201      	movs	r2, #1
100407f8:	609a      	str	r2, [r3, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
100407fa:	1d3b      	adds	r3, r7, #4
100407fc:	2200      	movs	r2, #0
100407fe:	60da      	str	r2, [r3, #12]
  GPIO_InitStruct.Alternate = GPIO_AF0_SWDIO;
10040800:	1d3b      	adds	r3, r7, #4
10040802:	2200      	movs	r2, #0
10040804:	611a      	str	r2, [r3, #16]
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
10040806:	1d3a      	adds	r2, r7, #4
10040808:	2390      	movs	r3, #144	@ 0x90
1004080a:	05db      	lsls	r3, r3, #23
1004080c:	0011      	movs	r1, r2
1004080e:	0018      	movs	r0, r3
10040810:	f001 fa3a 	bl	10041c88 <HAL_GPIO_Init>

  /*Configure GPIO pin : PA3 */
  GPIO_InitStruct.Pin = GPIO_PIN_3;
10040814:	1d3b      	adds	r3, r7, #4
10040816:	2208      	movs	r2, #8
10040818:	601a      	str	r2, [r3, #0]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
1004081a:	1d3b      	adds	r3, r7, #4
1004081c:	2202      	movs	r2, #2
1004081e:	605a      	str	r2, [r3, #4]
  GPIO_InitStruct.Pull = GPIO_PULLDOWN;
10040820:	1d3b      	adds	r3, r7, #4
10040822:	2202      	movs	r2, #2
10040824:	609a      	str	r2, [r3, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
10040826:	1d3b      	adds	r3, r7, #4
10040828:	2203      	movs	r2, #3
1004082a:	60da      	str	r2, [r3, #12]
  GPIO_InitStruct.Alternate = GPIO_AF0_SWCLK;
1004082c:	1d3b      	adds	r3, r7, #4
1004082e:	2200      	movs	r2, #0
10040830:	611a      	str	r2, [r3, #16]
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
10040832:	1d3a      	adds	r2, r7, #4
10040834:	2390      	movs	r3, #144	@ 0x90
10040836:	05db      	lsls	r3, r3, #23
10040838:	0011      	movs	r1, r2
1004083a:	0018      	movs	r0, r3
1004083c:	f001 fa24 	bl	10041c88 <HAL_GPIO_Init>

  /*Configure GPIO pin : VCP_RX_Pin */
  GPIO_InitStruct.Pin = VCP_RX_Pin;
10040840:	1d3b      	adds	r3, r7, #4
10040842:	2280      	movs	r2, #128	@ 0x80
10040844:	0212      	lsls	r2, r2, #8
10040846:	601a      	str	r2, [r3, #0]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
10040848:	1d3b      	adds	r3, r7, #4
1004084a:	2202      	movs	r2, #2
1004084c:	605a      	str	r2, [r3, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
1004084e:	1d3b      	adds	r3, r7, #4
10040850:	2200      	movs	r2, #0
10040852:	609a      	str	r2, [r3, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
10040854:	1d3b      	adds	r3, r7, #4
10040856:	2200      	movs	r2, #0
10040858:	60da      	str	r2, [r3, #12]
  GPIO_InitStruct.Alternate = GPIO_AF1_USART1;
1004085a:	1d3b      	adds	r3, r7, #4
1004085c:	2201      	movs	r2, #1
1004085e:	611a      	str	r2, [r3, #16]
  HAL_GPIO_Init(VCP_RX_GPIO_Port, &GPIO_InitStruct);
10040860:	1d3a      	adds	r2, r7, #4
10040862:	2390      	movs	r3, #144	@ 0x90
10040864:	05db      	lsls	r3, r3, #23
10040866:	0011      	movs	r1, r2
10040868:	0018      	movs	r0, r3
1004086a:	f001 fa0d 	bl	10041c88 <HAL_GPIO_Init>

  /**/
  HAL_PWREx_EnableGPIOPullUp(PWR_GPIO_A, PWR_GPIO_BIT_2);
1004086e:	2104      	movs	r1, #4
10040870:	2000      	movs	r0, #0
10040872:	f002 f8e1 	bl	10042a38 <HAL_PWREx_EnableGPIOPullUp>

  /**/
  HAL_PWREx_DisableGPIOPullUp(PWR_GPIO_A, PWR_GPIO_BIT_3|PWR_GPIO_BIT_15);
10040876:	4b07      	ldr	r3, [pc, #28]	@ (10040894 <MX_GPIO_Init+0xcc>)
10040878:	0019      	movs	r1, r3
1004087a:	2000      	movs	r0, #0
1004087c:	f002 f916 	bl	10042aac <HAL_PWREx_DisableGPIOPullUp>

  /**/
  HAL_PWREx_DisableGPIOPullDown(PWR_GPIO_A, PWR_GPIO_BIT_3|PWR_GPIO_BIT_15);
10040880:	4b04      	ldr	r3, [pc, #16]	@ (10040894 <MX_GPIO_Init+0xcc>)
10040882:	0019      	movs	r1, r3
10040884:	2000      	movs	r0, #0
10040886:	f002 f93f 	bl	10042b08 <HAL_PWREx_DisableGPIOPullDown>

  /* USER CODE BEGIN MX_GPIO_Init_2 */

  /* USER CODE END MX_GPIO_Init_2 */
}
1004088a:	46c0      	nop			@ (mov r8, r8)
1004088c:	46bd      	mov	sp, r7
1004088e:	b006      	add	sp, #24
10040890:	bd80      	pop	{r7, pc}
10040892:	46c0      	nop			@ (mov r8, r8)
10040894:	00008008 	.word	0x00008008

10040898 <DrawBarGraph>:

/* USER CODE BEGIN 4 */

void DrawBarGraph(uint8_t *values, uint8_t count, uint8_t maxValue)
{
10040898:	b5b0      	push	{r4, r5, r7, lr}
1004089a:	b086      	sub	sp, #24
1004089c:	af02      	add	r7, sp, #8
1004089e:	6078      	str	r0, [r7, #4]
100408a0:	0008      	movs	r0, r1
100408a2:	0011      	movs	r1, r2
100408a4:	1cfb      	adds	r3, r7, #3
100408a6:	1c02      	adds	r2, r0, #0
100408a8:	701a      	strb	r2, [r3, #0]
100408aa:	1cbb      	adds	r3, r7, #2
100408ac:	1c0a      	adds	r2, r1, #0
100408ae:	701a      	strb	r2, [r3, #0]
    uint8_t barWidth = OLED_W / count;
100408b0:	1cfb      	adds	r3, r7, #3
100408b2:	781b      	ldrb	r3, [r3, #0]
100408b4:	0019      	movs	r1, r3
100408b6:	2080      	movs	r0, #128	@ 0x80
100408b8:	f7ff fc8c 	bl	100401d4 <__divsi3>
100408bc:	0003      	movs	r3, r0
100408be:	001a      	movs	r2, r3
100408c0:	210f      	movs	r1, #15
100408c2:	187b      	adds	r3, r7, r1
100408c4:	701a      	strb	r2, [r3, #0]
    if (barWidth < 1) barWidth = 1;
100408c6:	000a      	movs	r2, r1
100408c8:	18bb      	adds	r3, r7, r2
100408ca:	781b      	ldrb	r3, [r3, #0]
100408cc:	2b00      	cmp	r3, #0
100408ce:	d102      	bne.n	100408d6 <DrawBarGraph+0x3e>
100408d0:	18bb      	adds	r3, r7, r2
100408d2:	2201      	movs	r2, #1
100408d4:	701a      	strb	r2, [r3, #0]

    for (uint8_t i = 0; i < count; i++)
100408d6:	230e      	movs	r3, #14
100408d8:	18fb      	adds	r3, r7, r3
100408da:	2200      	movs	r2, #0
100408dc:	701a      	strb	r2, [r3, #0]
100408de:	e063      	b.n	100409a8 <DrawBarGraph+0x110>
    {
        uint8_t v = values[i];
100408e0:	230e      	movs	r3, #14
100408e2:	18fb      	adds	r3, r7, r3
100408e4:	781b      	ldrb	r3, [r3, #0]
100408e6:	687a      	ldr	r2, [r7, #4]
100408e8:	18d2      	adds	r2, r2, r3
100408ea:	210d      	movs	r1, #13
100408ec:	187b      	adds	r3, r7, r1
100408ee:	7812      	ldrb	r2, [r2, #0]
100408f0:	701a      	strb	r2, [r3, #0]
        if (v > maxValue) v = maxValue;
100408f2:	187a      	adds	r2, r7, r1
100408f4:	1cbb      	adds	r3, r7, #2
100408f6:	7812      	ldrb	r2, [r2, #0]
100408f8:	781b      	ldrb	r3, [r3, #0]
100408fa:	429a      	cmp	r2, r3
100408fc:	d903      	bls.n	10040906 <DrawBarGraph+0x6e>
100408fe:	187b      	adds	r3, r7, r1
10040900:	1cba      	adds	r2, r7, #2
10040902:	7812      	ldrb	r2, [r2, #0]
10040904:	701a      	strb	r2, [r3, #0]

        // scale value to graph height
        uint8_t h = (v * GRAPH_HEIGHT) / maxValue;
10040906:	230d      	movs	r3, #13
10040908:	18fb      	adds	r3, r7, r3
1004090a:	781a      	ldrb	r2, [r3, #0]
1004090c:	0013      	movs	r3, r2
1004090e:	009b      	lsls	r3, r3, #2
10040910:	189b      	adds	r3, r3, r2
10040912:	009b      	lsls	r3, r3, #2
10040914:	001a      	movs	r2, r3
10040916:	1cbb      	adds	r3, r7, #2
10040918:	781b      	ldrb	r3, [r3, #0]
1004091a:	0019      	movs	r1, r3
1004091c:	0010      	movs	r0, r2
1004091e:	f7ff fc59 	bl	100401d4 <__divsi3>
10040922:	0003      	movs	r3, r0
10040924:	001a      	movs	r2, r3
10040926:	240b      	movs	r4, #11
10040928:	193b      	adds	r3, r7, r4
1004092a:	701a      	strb	r2, [r3, #0]

        uint8_t x1 = i * barWidth;
1004092c:	200a      	movs	r0, #10
1004092e:	183b      	adds	r3, r7, r0
10040930:	220e      	movs	r2, #14
10040932:	18ba      	adds	r2, r7, r2
10040934:	250f      	movs	r5, #15
10040936:	1979      	adds	r1, r7, r5
10040938:	7812      	ldrb	r2, [r2, #0]
1004093a:	7809      	ldrb	r1, [r1, #0]
1004093c:	434a      	muls	r2, r1
1004093e:	701a      	strb	r2, [r3, #0]
        uint8_t x2 = x1 + barWidth - 1;
10040940:	183a      	adds	r2, r7, r0
10040942:	197b      	adds	r3, r7, r5
10040944:	7812      	ldrb	r2, [r2, #0]
10040946:	781b      	ldrb	r3, [r3, #0]
10040948:	18d3      	adds	r3, r2, r3
1004094a:	b2da      	uxtb	r2, r3
1004094c:	200c      	movs	r0, #12
1004094e:	183b      	adds	r3, r7, r0
10040950:	3a01      	subs	r2, #1
10040952:	701a      	strb	r2, [r3, #0]
        uint8_t y1 = OLED_H - 1 - h;
10040954:	2309      	movs	r3, #9
10040956:	18fb      	adds	r3, r7, r3
10040958:	193a      	adds	r2, r7, r4
1004095a:	7812      	ldrb	r2, [r2, #0]
1004095c:	211f      	movs	r1, #31
1004095e:	1a8a      	subs	r2, r1, r2
10040960:	701a      	strb	r2, [r3, #0]
        uint8_t y2 = OLED_H - 1;
10040962:	2308      	movs	r3, #8
10040964:	18fb      	adds	r3, r7, r3
10040966:	221f      	movs	r2, #31
10040968:	701a      	strb	r2, [r3, #0]

        if (x2 >= OLED_W) x2 = OLED_W - 1;
1004096a:	183b      	adds	r3, r7, r0
1004096c:	781b      	ldrb	r3, [r3, #0]
1004096e:	b25b      	sxtb	r3, r3
10040970:	2b00      	cmp	r3, #0
10040972:	da02      	bge.n	1004097a <DrawBarGraph+0xe2>
10040974:	183b      	adds	r3, r7, r0
10040976:	227f      	movs	r2, #127	@ 0x7f
10040978:	701a      	strb	r2, [r3, #0]

        // Draw filled bar using your existing function
        ssd1306_FillRectangle(x1, y1, x2, y2, White);
1004097a:	2308      	movs	r3, #8
1004097c:	18fb      	adds	r3, r7, r3
1004097e:	781c      	ldrb	r4, [r3, #0]
10040980:	230c      	movs	r3, #12
10040982:	18fb      	adds	r3, r7, r3
10040984:	781a      	ldrb	r2, [r3, #0]
10040986:	2309      	movs	r3, #9
10040988:	18fb      	adds	r3, r7, r3
1004098a:	7819      	ldrb	r1, [r3, #0]
1004098c:	230a      	movs	r3, #10
1004098e:	18fb      	adds	r3, r7, r3
10040990:	7818      	ldrb	r0, [r3, #0]
10040992:	2301      	movs	r3, #1
10040994:	9300      	str	r3, [sp, #0]
10040996:	0023      	movs	r3, r4
10040998:	f000 ff28 	bl	100417ec <ssd1306_FillRectangle>
    for (uint8_t i = 0; i < count; i++)
1004099c:	210e      	movs	r1, #14
1004099e:	187b      	adds	r3, r7, r1
100409a0:	781a      	ldrb	r2, [r3, #0]
100409a2:	187b      	adds	r3, r7, r1
100409a4:	3201      	adds	r2, #1
100409a6:	701a      	strb	r2, [r3, #0]
100409a8:	230e      	movs	r3, #14
100409aa:	18fa      	adds	r2, r7, r3
100409ac:	1cfb      	adds	r3, r7, #3
100409ae:	7812      	ldrb	r2, [r2, #0]
100409b0:	781b      	ldrb	r3, [r3, #0]
100409b2:	429a      	cmp	r2, r3
100409b4:	d394      	bcc.n	100408e0 <DrawBarGraph+0x48>
    }
}
100409b6:	46c0      	nop			@ (mov r8, r8)
100409b8:	46c0      	nop			@ (mov r8, r8)
100409ba:	46bd      	mov	sp, r7
100409bc:	b004      	add	sp, #16
100409be:	bdb0      	pop	{r4, r5, r7, pc}

100409c0 <RenderScreen>:


void RenderScreen(uint8_t *values, uint8_t count)
{
100409c0:	b580      	push	{r7, lr}
100409c2:	b084      	sub	sp, #16
100409c4:	af02      	add	r7, sp, #8
100409c6:	6078      	str	r0, [r7, #4]
100409c8:	000a      	movs	r2, r1
100409ca:	1cfb      	adds	r3, r7, #3
100409cc:	701a      	strb	r2, [r3, #0]
    ssd1306_Fill(Black);
100409ce:	2000      	movs	r0, #0
100409d0:	f000 fd72 	bl	100414b8 <ssd1306_Fill>

    // Draw top text
    ssd1306_SetCursor(0, 0);
100409d4:	2100      	movs	r1, #0
100409d6:	2000      	movs	r0, #0
100409d8:	f000 feee 	bl	100417b8 <ssd1306_SetCursor>
    ssd1306_WriteString("Frequency: 868MHz", Font_7x10, White);
100409dc:	4b0a      	ldr	r3, [pc, #40]	@ (10040a08 <RenderScreen+0x48>)
100409de:	480b      	ldr	r0, [pc, #44]	@ (10040a0c <RenderScreen+0x4c>)
100409e0:	2201      	movs	r2, #1
100409e2:	9200      	str	r2, [sp, #0]
100409e4:	6819      	ldr	r1, [r3, #0]
100409e6:	685a      	ldr	r2, [r3, #4]
100409e8:	689b      	ldr	r3, [r3, #8]
100409ea:	f000 feb9 	bl	10041760 <ssd1306_WriteString>

    // Bars below the text
    DrawBarGraph(values, count, 100);  // values scaled 0100
100409ee:	1cfb      	adds	r3, r7, #3
100409f0:	7819      	ldrb	r1, [r3, #0]
100409f2:	687b      	ldr	r3, [r7, #4]
100409f4:	2264      	movs	r2, #100	@ 0x64
100409f6:	0018      	movs	r0, r3
100409f8:	f7ff ff4e 	bl	10040898 <DrawBarGraph>

    ssd1306_UpdateScreen();
100409fc:	f000 fd76 	bl	100414ec <ssd1306_UpdateScreen>
}
10040a00:	46c0      	nop			@ (mov r8, r8)
10040a02:	46bd      	mov	sp, r7
10040a04:	b002      	add	sp, #8
10040a06:	bd80      	pop	{r7, pc}
10040a08:	10044644 	.word	0x10044644
10040a0c:	10043ec4 	.word	0x10043ec4

10040a10 <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
10040a10:	b580      	push	{r7, lr}
10040a12:	af00      	add	r7, sp, #0
  \details Disables IRQ interrupts by setting special-purpose register PRIMASK.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
10040a14:	b672      	cpsid	i
}
10040a16:	46c0      	nop			@ (mov r8, r8)
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
10040a18:	46c0      	nop			@ (mov r8, r8)
10040a1a:	e7fd      	b.n	10040a18 <Error_Handler+0x8>

10040a1c <LL_AHB1_GRP1_EnableClock>:
{
10040a1c:	b580      	push	{r7, lr}
10040a1e:	b084      	sub	sp, #16
10040a20:	af00      	add	r7, sp, #0
10040a22:	6078      	str	r0, [r7, #4]
  SET_BIT(RCC->AHBENR, Periphs);
10040a24:	4b07      	ldr	r3, [pc, #28]	@ (10040a44 <LL_AHB1_GRP1_EnableClock+0x28>)
10040a26:	6d19      	ldr	r1, [r3, #80]	@ 0x50
10040a28:	4b06      	ldr	r3, [pc, #24]	@ (10040a44 <LL_AHB1_GRP1_EnableClock+0x28>)
10040a2a:	687a      	ldr	r2, [r7, #4]
10040a2c:	430a      	orrs	r2, r1
10040a2e:	651a      	str	r2, [r3, #80]	@ 0x50
  tmpreg = READ_BIT(RCC->AHBENR, Periphs);
10040a30:	4b04      	ldr	r3, [pc, #16]	@ (10040a44 <LL_AHB1_GRP1_EnableClock+0x28>)
10040a32:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
10040a34:	687a      	ldr	r2, [r7, #4]
10040a36:	4013      	ands	r3, r2
10040a38:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
10040a3a:	68fb      	ldr	r3, [r7, #12]
}
10040a3c:	46c0      	nop			@ (mov r8, r8)
10040a3e:	46bd      	mov	sp, r7
10040a40:	b004      	add	sp, #16
10040a42:	bd80      	pop	{r7, pc}
10040a44:	48400000 	.word	0x48400000

10040a48 <LL_APB0_GRP1_EnableClock>:
  * @arg LL_APB0_GRP1_PERIPH_WDG
  * @arg LL_APB0_GRP1_PERIPH_DBGMCU
  * @retval None
  */
__STATIC_INLINE void LL_APB0_GRP1_EnableClock(uint32_t Periphs)
{
10040a48:	b580      	push	{r7, lr}
10040a4a:	b084      	sub	sp, #16
10040a4c:	af00      	add	r7, sp, #0
10040a4e:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  SET_BIT(RCC->APB0ENR, Periphs);
10040a50:	4b07      	ldr	r3, [pc, #28]	@ (10040a70 <LL_APB0_GRP1_EnableClock+0x28>)
10040a52:	6d59      	ldr	r1, [r3, #84]	@ 0x54
10040a54:	4b06      	ldr	r3, [pc, #24]	@ (10040a70 <LL_APB0_GRP1_EnableClock+0x28>)
10040a56:	687a      	ldr	r2, [r7, #4]
10040a58:	430a      	orrs	r2, r1
10040a5a:	655a      	str	r2, [r3, #84]	@ 0x54
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->APB0ENR, Periphs);
10040a5c:	4b04      	ldr	r3, [pc, #16]	@ (10040a70 <LL_APB0_GRP1_EnableClock+0x28>)
10040a5e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
10040a60:	687a      	ldr	r2, [r7, #4]
10040a62:	4013      	ands	r3, r2
10040a64:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
10040a66:	68fb      	ldr	r3, [r7, #12]
}
10040a68:	46c0      	nop			@ (mov r8, r8)
10040a6a:	46bd      	mov	sp, r7
10040a6c:	b004      	add	sp, #16
10040a6e:	bd80      	pop	{r7, pc}
10040a70:	48400000 	.word	0x48400000

10040a74 <LL_APB1_GRP1_EnableClock>:
  * @arg LL_APB1_GRP1_PERIPH_I2C1
  * @arg LL_APB1_GRP1_PERIPH_I2C2
  * @retval None
  */
__STATIC_INLINE void LL_APB1_GRP1_EnableClock(uint32_t Periphs)
{
10040a74:	b580      	push	{r7, lr}
10040a76:	b084      	sub	sp, #16
10040a78:	af00      	add	r7, sp, #0
10040a7a:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  SET_BIT(RCC->APB1ENR, Periphs);
10040a7c:	4b07      	ldr	r3, [pc, #28]	@ (10040a9c <LL_APB1_GRP1_EnableClock+0x28>)
10040a7e:	6d99      	ldr	r1, [r3, #88]	@ 0x58
10040a80:	4b06      	ldr	r3, [pc, #24]	@ (10040a9c <LL_APB1_GRP1_EnableClock+0x28>)
10040a82:	687a      	ldr	r2, [r7, #4]
10040a84:	430a      	orrs	r2, r1
10040a86:	659a      	str	r2, [r3, #88]	@ 0x58
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->APB1ENR, Periphs);
10040a88:	4b04      	ldr	r3, [pc, #16]	@ (10040a9c <LL_APB1_GRP1_EnableClock+0x28>)
10040a8a:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
10040a8c:	687a      	ldr	r2, [r7, #4]
10040a8e:	4013      	ands	r3, r2
10040a90:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
10040a92:	68fb      	ldr	r3, [r7, #12]
}
10040a94:	46c0      	nop			@ (mov r8, r8)
10040a96:	46bd      	mov	sp, r7
10040a98:	b004      	add	sp, #16
10040a9a:	bd80      	pop	{r7, pc}
10040a9c:	48400000 	.word	0x48400000

10040aa0 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
10040aa0:	b580      	push	{r7, lr}
10040aa2:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
10040aa4:	2380      	movs	r3, #128	@ 0x80
10040aa6:	005b      	lsls	r3, r3, #1
10040aa8:	0018      	movs	r0, r3
10040aaa:	f7ff ffcd 	bl	10040a48 <LL_APB0_GRP1_EnableClock>
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
10040aae:	46c0      	nop			@ (mov r8, r8)
10040ab0:	46bd      	mov	sp, r7
10040ab2:	bd80      	pop	{r7, pc}

10040ab4 <HAL_I2C_MspInit>:
  * This function configures the hardware resources used in this example
  * @param hi2c: I2C handle pointer
  * @retval None
  */
void HAL_I2C_MspInit(I2C_HandleTypeDef* hi2c)
{
10040ab4:	b590      	push	{r4, r7, lr}
10040ab6:	b089      	sub	sp, #36	@ 0x24
10040ab8:	af00      	add	r7, sp, #0
10040aba:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
10040abc:	240c      	movs	r4, #12
10040abe:	193b      	adds	r3, r7, r4
10040ac0:	0018      	movs	r0, r3
10040ac2:	2314      	movs	r3, #20
10040ac4:	001a      	movs	r2, r3
10040ac6:	2100      	movs	r1, #0
10040ac8:	f003 f9e4 	bl	10043e94 <memset>
  if(hi2c->Instance==I2C2)
10040acc:	687b      	ldr	r3, [r7, #4]
10040ace:	681b      	ldr	r3, [r3, #0]
10040ad0:	4a16      	ldr	r2, [pc, #88]	@ (10040b2c <HAL_I2C_MspInit+0x78>)
10040ad2:	4293      	cmp	r3, r2
10040ad4:	d126      	bne.n	10040b24 <HAL_I2C_MspInit+0x70>
  {
    /* USER CODE BEGIN I2C2_MspInit 0 */

    /* USER CODE END I2C2_MspInit 0 */

    __HAL_RCC_GPIOA_CLK_ENABLE();
10040ad6:	2004      	movs	r0, #4
10040ad8:	f7ff ffa0 	bl	10040a1c <LL_AHB1_GRP1_EnableClock>
    /**I2C2 GPIO Configuration
    PA6     ------> I2C2_SCL
    PA7     ------> I2C2_SDA
    */
    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7;
10040adc:	0021      	movs	r1, r4
10040ade:	187b      	adds	r3, r7, r1
10040ae0:	22c0      	movs	r2, #192	@ 0xc0
10040ae2:	601a      	str	r2, [r3, #0]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
10040ae4:	187b      	adds	r3, r7, r1
10040ae6:	2212      	movs	r2, #18
10040ae8:	605a      	str	r2, [r3, #4]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
10040aea:	187b      	adds	r3, r7, r1
10040aec:	2200      	movs	r2, #0
10040aee:	609a      	str	r2, [r3, #8]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
10040af0:	187b      	adds	r3, r7, r1
10040af2:	2200      	movs	r2, #0
10040af4:	60da      	str	r2, [r3, #12]
    GPIO_InitStruct.Alternate = GPIO_AF0_I2C2;
10040af6:	187b      	adds	r3, r7, r1
10040af8:	2200      	movs	r2, #0
10040afa:	611a      	str	r2, [r3, #16]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
10040afc:	187a      	adds	r2, r7, r1
10040afe:	2390      	movs	r3, #144	@ 0x90
10040b00:	05db      	lsls	r3, r3, #23
10040b02:	0011      	movs	r1, r2
10040b04:	0018      	movs	r0, r3
10040b06:	f001 f8bf 	bl	10041c88 <HAL_GPIO_Init>

    HAL_PWREx_DisableGPIOPullUp(PWR_GPIO_A, PWR_GPIO_BIT_6|PWR_GPIO_BIT_7);
10040b0a:	21c0      	movs	r1, #192	@ 0xc0
10040b0c:	2000      	movs	r0, #0
10040b0e:	f001 ffcd 	bl	10042aac <HAL_PWREx_DisableGPIOPullUp>

    HAL_PWREx_DisableGPIOPullDown(PWR_GPIO_A, PWR_GPIO_BIT_6|PWR_GPIO_BIT_7);
10040b12:	21c0      	movs	r1, #192	@ 0xc0
10040b14:	2000      	movs	r0, #0
10040b16:	f001 fff7 	bl	10042b08 <HAL_PWREx_DisableGPIOPullDown>

    /* Peripheral clock enable */
    __HAL_RCC_I2C2_CLK_ENABLE();
10040b1a:	2380      	movs	r3, #128	@ 0x80
10040b1c:	041b      	lsls	r3, r3, #16
10040b1e:	0018      	movs	r0, r3
10040b20:	f7ff ffa8 	bl	10040a74 <LL_APB1_GRP1_EnableClock>

    /* USER CODE END I2C2_MspInit 1 */

  }

}
10040b24:	46c0      	nop			@ (mov r8, r8)
10040b26:	46bd      	mov	sp, r7
10040b28:	b009      	add	sp, #36	@ 0x24
10040b2a:	bd90      	pop	{r4, r7, pc}
10040b2c:	41001000 	.word	0x41001000

10040b30 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
10040b30:	b580      	push	{r7, lr}
10040b32:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
   while (1)
10040b34:	46c0      	nop			@ (mov r8, r8)
10040b36:	e7fd      	b.n	10040b34 <NMI_Handler+0x4>

10040b38 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
10040b38:	b580      	push	{r7, lr}
10040b3a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
10040b3c:	46c0      	nop			@ (mov r8, r8)
10040b3e:	e7fd      	b.n	10040b3c <HardFault_Handler+0x4>

10040b40 <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
10040b40:	b580      	push	{r7, lr}
10040b42:	af00      	add	r7, sp, #0

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
10040b44:	46c0      	nop			@ (mov r8, r8)
10040b46:	46bd      	mov	sp, r7
10040b48:	bd80      	pop	{r7, pc}

10040b4a <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
10040b4a:	b580      	push	{r7, lr}
10040b4c:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
10040b4e:	46c0      	nop			@ (mov r8, r8)
10040b50:	46bd      	mov	sp, r7
10040b52:	bd80      	pop	{r7, pc}

10040b54 <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
10040b54:	b580      	push	{r7, lr}
10040b56:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
10040b58:	f000 ff6e 	bl	10041a38 <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
10040b5c:	46c0      	nop			@ (mov r8, r8)
10040b5e:	46bd      	mov	sp, r7
10040b60:	bd80      	pop	{r7, pc}
	...

10040b64 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
10040b64:	b590      	push	{r4, r7, lr}
10040b66:	b083      	sub	sp, #12
10040b68:	af00      	add	r7, sp, #0
10040b6a:	0002      	movs	r2, r0
10040b6c:	6039      	str	r1, [r7, #0]
10040b6e:	1dfb      	adds	r3, r7, #7
10040b70:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
10040b72:	1dfb      	adds	r3, r7, #7
10040b74:	781b      	ldrb	r3, [r3, #0]
10040b76:	2b7f      	cmp	r3, #127	@ 0x7f
10040b78:	d828      	bhi.n	10040bcc <__NVIC_SetPriority+0x68>
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
10040b7a:	4a2f      	ldr	r2, [pc, #188]	@ (10040c38 <__NVIC_SetPriority+0xd4>)
10040b7c:	1dfb      	adds	r3, r7, #7
10040b7e:	781b      	ldrb	r3, [r3, #0]
10040b80:	b25b      	sxtb	r3, r3
10040b82:	089b      	lsrs	r3, r3, #2
10040b84:	33c0      	adds	r3, #192	@ 0xc0
10040b86:	009b      	lsls	r3, r3, #2
10040b88:	589b      	ldr	r3, [r3, r2]
10040b8a:	1dfa      	adds	r2, r7, #7
10040b8c:	7812      	ldrb	r2, [r2, #0]
10040b8e:	0011      	movs	r1, r2
10040b90:	2203      	movs	r2, #3
10040b92:	400a      	ands	r2, r1
10040b94:	00d2      	lsls	r2, r2, #3
10040b96:	21ff      	movs	r1, #255	@ 0xff
10040b98:	4091      	lsls	r1, r2
10040b9a:	000a      	movs	r2, r1
10040b9c:	43d2      	mvns	r2, r2
10040b9e:	401a      	ands	r2, r3
10040ba0:	0011      	movs	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
10040ba2:	683b      	ldr	r3, [r7, #0]
10040ba4:	019b      	lsls	r3, r3, #6
10040ba6:	22ff      	movs	r2, #255	@ 0xff
10040ba8:	401a      	ands	r2, r3
10040baa:	1dfb      	adds	r3, r7, #7
10040bac:	781b      	ldrb	r3, [r3, #0]
10040bae:	0018      	movs	r0, r3
10040bb0:	2303      	movs	r3, #3
10040bb2:	4003      	ands	r3, r0
10040bb4:	00db      	lsls	r3, r3, #3
10040bb6:	409a      	lsls	r2, r3
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
10040bb8:	481f      	ldr	r0, [pc, #124]	@ (10040c38 <__NVIC_SetPriority+0xd4>)
10040bba:	1dfb      	adds	r3, r7, #7
10040bbc:	781b      	ldrb	r3, [r3, #0]
10040bbe:	b25b      	sxtb	r3, r3
10040bc0:	089b      	lsrs	r3, r3, #2
10040bc2:	430a      	orrs	r2, r1
10040bc4:	33c0      	adds	r3, #192	@ 0xc0
10040bc6:	009b      	lsls	r3, r3, #2
10040bc8:	501a      	str	r2, [r3, r0]
  else
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
}
10040bca:	e031      	b.n	10040c30 <__NVIC_SetPriority+0xcc>
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
10040bcc:	4a1b      	ldr	r2, [pc, #108]	@ (10040c3c <__NVIC_SetPriority+0xd8>)
10040bce:	1dfb      	adds	r3, r7, #7
10040bd0:	781b      	ldrb	r3, [r3, #0]
10040bd2:	0019      	movs	r1, r3
10040bd4:	230f      	movs	r3, #15
10040bd6:	400b      	ands	r3, r1
10040bd8:	3b08      	subs	r3, #8
10040bda:	089b      	lsrs	r3, r3, #2
10040bdc:	3306      	adds	r3, #6
10040bde:	009b      	lsls	r3, r3, #2
10040be0:	18d3      	adds	r3, r2, r3
10040be2:	3304      	adds	r3, #4
10040be4:	681b      	ldr	r3, [r3, #0]
10040be6:	1dfa      	adds	r2, r7, #7
10040be8:	7812      	ldrb	r2, [r2, #0]
10040bea:	0011      	movs	r1, r2
10040bec:	2203      	movs	r2, #3
10040bee:	400a      	ands	r2, r1
10040bf0:	00d2      	lsls	r2, r2, #3
10040bf2:	21ff      	movs	r1, #255	@ 0xff
10040bf4:	4091      	lsls	r1, r2
10040bf6:	000a      	movs	r2, r1
10040bf8:	43d2      	mvns	r2, r2
10040bfa:	401a      	ands	r2, r3
10040bfc:	0011      	movs	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
10040bfe:	683b      	ldr	r3, [r7, #0]
10040c00:	019b      	lsls	r3, r3, #6
10040c02:	22ff      	movs	r2, #255	@ 0xff
10040c04:	401a      	ands	r2, r3
10040c06:	1dfb      	adds	r3, r7, #7
10040c08:	781b      	ldrb	r3, [r3, #0]
10040c0a:	0018      	movs	r0, r3
10040c0c:	2303      	movs	r3, #3
10040c0e:	4003      	ands	r3, r0
10040c10:	00db      	lsls	r3, r3, #3
10040c12:	409a      	lsls	r2, r3
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
10040c14:	4809      	ldr	r0, [pc, #36]	@ (10040c3c <__NVIC_SetPriority+0xd8>)
10040c16:	1dfb      	adds	r3, r7, #7
10040c18:	781b      	ldrb	r3, [r3, #0]
10040c1a:	001c      	movs	r4, r3
10040c1c:	230f      	movs	r3, #15
10040c1e:	4023      	ands	r3, r4
10040c20:	3b08      	subs	r3, #8
10040c22:	089b      	lsrs	r3, r3, #2
10040c24:	430a      	orrs	r2, r1
10040c26:	3306      	adds	r3, #6
10040c28:	009b      	lsls	r3, r3, #2
10040c2a:	18c3      	adds	r3, r0, r3
10040c2c:	3304      	adds	r3, #4
10040c2e:	601a      	str	r2, [r3, #0]
}
10040c30:	46c0      	nop			@ (mov r8, r8)
10040c32:	46bd      	mov	sp, r7
10040c34:	b003      	add	sp, #12
10040c36:	bd90      	pop	{r4, r7, pc}
10040c38:	e000e100 	.word	0xe000e100
10040c3c:	e000ed00 	.word	0xe000ed00

10040c40 <__NVIC_SystemReset>:
/**
  \brief   System Reset
  \details Initiates a system reset request to reset the MCU.
 */
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
10040c40:	b580      	push	{r7, lr}
10040c42:	af00      	add	r7, sp, #0
  __ASM volatile ("dsb 0xF":::"memory");
10040c44:	f3bf 8f4f 	dsb	sy
}
10040c48:	46c0      	nop			@ (mov r8, r8)
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = ((0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
10040c4a:	4b04      	ldr	r3, [pc, #16]	@ (10040c5c <__NVIC_SystemReset+0x1c>)
10040c4c:	4a04      	ldr	r2, [pc, #16]	@ (10040c60 <__NVIC_SystemReset+0x20>)
10040c4e:	60da      	str	r2, [r3, #12]
  __ASM volatile ("dsb 0xF":::"memory");
10040c50:	f3bf 8f4f 	dsb	sy
}
10040c54:	46c0      	nop			@ (mov r8, r8)
                 SCB_AIRCR_SYSRESETREQ_Msk);
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
10040c56:	46c0      	nop			@ (mov r8, r8)
10040c58:	e7fd      	b.n	10040c56 <__NVIC_SystemReset+0x16>
10040c5a:	46c0      	nop			@ (mov r8, r8)
10040c5c:	e000ed00 	.word	0xe000ed00
10040c60:	05fa0004 	.word	0x05fa0004

10040c64 <SystemInit>:
  * @brief  Setup the microcontroller system.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
10040c64:	b580      	push	{r7, lr}
10040c66:	b086      	sub	sp, #24
10040c68:	af00      	add	r7, sp, #0
  uint32_t mainRegulator, smpsOutVoltage, lsiBw, hsiCalib;
  uint8_t i;

  /* If the reset reason is a wakeup from power save restore the context */
  if ((RCC->CSR == 0) && ((PWR->IWUF != 0) || (PWR->WUFA != 0) || (PWR->WUFB != 0)))
10040c6a:	4a5e      	ldr	r2, [pc, #376]	@ (10040de4 <SystemInit+0x180>)
10040c6c:	2394      	movs	r3, #148	@ 0x94
10040c6e:	58d3      	ldr	r3, [r2, r3]
10040c70:	2b00      	cmp	r3, #0
10040c72:	d112      	bne.n	10040c9a <SystemInit+0x36>
10040c74:	4b5c      	ldr	r3, [pc, #368]	@ (10040de8 <SystemInit+0x184>)
10040c76:	691b      	ldr	r3, [r3, #16]
10040c78:	2b00      	cmp	r3, #0
10040c7a:	d107      	bne.n	10040c8c <SystemInit+0x28>
10040c7c:	4b5a      	ldr	r3, [pc, #360]	@ (10040de8 <SystemInit+0x184>)
10040c7e:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
10040c80:	2b00      	cmp	r3, #0
10040c82:	d103      	bne.n	10040c8c <SystemInit+0x28>
10040c84:	4b58      	ldr	r3, [pc, #352]	@ (10040de8 <SystemInit+0x184>)
10040c86:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
10040c88:	2b00      	cmp	r3, #0
10040c8a:	d006      	beq.n	10040c9a <SystemInit+0x36>
  {
    RAM_VR.WakeupFromSleepFlag = 1; /* A wakeup from power save occurred */
10040c8c:	4b57      	ldr	r3, [pc, #348]	@ (10040dec <SystemInit+0x188>)
10040c8e:	2201      	movs	r2, #1
10040c90:	609a      	str	r2, [r3, #8]
    CPUcontextRestore();            /* Restore the context */
10040c92:	f000 f909 	bl	10040ea8 <CPUcontextRestore>
    /* if the context restore worked properly, we should never return here */
    while(1)
    {
      NVIC_SystemReset();
10040c96:	f7ff ffd3 	bl	10040c40 <__NVIC_SystemReset>

  /* Configure the Vector Table location */
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation */
#else
  SCB->VTOR = (uint32_t) (__vector_table);
10040c9a:	4b55      	ldr	r3, [pc, #340]	@ (10040df0 <SystemInit+0x18c>)
10040c9c:	4a55      	ldr	r2, [pc, #340]	@ (10040df4 <SystemInit+0x190>)
10040c9e:	609a      	str	r2, [r3, #8]
#endif /* USER_VECT_TAB_ADDRESS */

  /* Store in RAM the AppBase information */
  RAM_VR.AppBase = (uint32_t) SCB->VTOR;
10040ca0:	4b53      	ldr	r3, [pc, #332]	@ (10040df0 <SystemInit+0x18c>)
10040ca2:	689a      	ldr	r2, [r3, #8]
10040ca4:	4b51      	ldr	r3, [pc, #324]	@ (10040dec <SystemInit+0x188>)
10040ca6:	611a      	str	r2, [r3, #16]

  /* Enable all the RAM banks in retention during power save */
  SET_BIT(PWR->CR2, PWR_CR2_RAMRET1);
10040ca8:	4b4f      	ldr	r3, [pc, #316]	@ (10040de8 <SystemInit+0x184>)
10040caa:	685a      	ldr	r2, [r3, #4]
10040cac:	4b4e      	ldr	r3, [pc, #312]	@ (10040de8 <SystemInit+0x184>)
10040cae:	2120      	movs	r1, #32
10040cb0:	430a      	orrs	r2, r1
10040cb2:	605a      	str	r2, [r3, #4]

  /* Disable the GPIO retention in power save configuration */
  CLEAR_BIT(PWR->CR2, PWR_CR2_GPIORET);
10040cb4:	4b4c      	ldr	r3, [pc, #304]	@ (10040de8 <SystemInit+0x184>)
10040cb6:	685a      	ldr	r2, [r3, #4]
10040cb8:	4b4b      	ldr	r3, [pc, #300]	@ (10040de8 <SystemInit+0x184>)
10040cba:	494f      	ldr	r1, [pc, #316]	@ (10040df8 <SystemInit+0x194>)
10040cbc:	400a      	ands	r2, r1
10040cbe:	605a      	str	r2, [r3, #4]

  /* SMPS setup */
  if ((CFG_HW_SMPS == SMPS_ON) || (CFG_HW_SMPS == SMPS_STATIC_BOF) || (CFG_HW_SMPS == SMPS_DYNAMIC_BOF))
  {
    while(READ_BIT(PWR->SR2, PWR_SR2_SMPSRDY) != PWR_SR2_SMPSRDY); // Wait until SMPS is ready
10040cc0:	46c0      	nop			@ (mov r8, r8)
10040cc2:	4b49      	ldr	r3, [pc, #292]	@ (10040de8 <SystemInit+0x184>)
10040cc4:	695b      	ldr	r3, [r3, #20]
10040cc6:	2204      	movs	r2, #4
10040cc8:	4013      	ands	r3, r2
10040cca:	2b04      	cmp	r3, #4
10040ccc:	d1f9      	bne.n	10040cc2 <SystemInit+0x5e>
    MODIFY_REG(PWR->CR5, PWR_CR5_SMPSBOMSEL, (CFG_HW_SMPS_BOM<<PWR_CR5_SMPSBOMSEL_Pos)); // Configure the SMPS BOM
10040cce:	4b46      	ldr	r3, [pc, #280]	@ (10040de8 <SystemInit+0x184>)
10040cd0:	69db      	ldr	r3, [r3, #28]
10040cd2:	2230      	movs	r2, #48	@ 0x30
10040cd4:	4393      	bics	r3, r2
10040cd6:	001a      	movs	r2, r3
10040cd8:	4b43      	ldr	r3, [pc, #268]	@ (10040de8 <SystemInit+0x184>)
10040cda:	2120      	movs	r1, #32
10040cdc:	430a      	orrs	r2, r1
10040cde:	61da      	str	r2, [r3, #28]
  }
  if ((CFG_HW_SMPS == SMPS_ON) || (CFG_HW_SMPS == SMPS_OFF))
  {
    MODIFY_REG(PWR->CR5, PWR_CR5_NOSMPS, (CFG_HW_SMPS<<PWR_CR5_NOSMPS_Pos)); // SMPS ON/OFF Configuration
10040ce0:	4b41      	ldr	r3, [pc, #260]	@ (10040de8 <SystemInit+0x184>)
10040ce2:	69da      	ldr	r2, [r3, #28]
10040ce4:	4b40      	ldr	r3, [pc, #256]	@ (10040de8 <SystemInit+0x184>)
10040ce6:	4945      	ldr	r1, [pc, #276]	@ (10040dfc <SystemInit+0x198>)
10040ce8:	400a      	ands	r2, r1
10040cea:	61da      	str	r2, [r3, #28]
    /* The SMPS output voltage level and SMPS BOF tuning are set to 1.4V by default */
    SET_BIT(PWR->CR5, PWR_CR5_NOSMPS_BOF);
    CLEAR_BIT(PWR->CR5, PWR_CR5_SMPS_BOF_STATIC);
    SET_BIT(PWR->CR5, PWR_CR5_SMPS_BOF_DYN);
  }
  MODIFY_REG(PWR->CR5, PWR_CR5_SMPSLPOPEN, (CFG_HW_SMPS_LOW_POWER<<PWR_CR5_SMPSLPOPEN_Pos)); // SMPS configuration during power save
10040cec:	4b3e      	ldr	r3, [pc, #248]	@ (10040de8 <SystemInit+0x184>)
10040cee:	69da      	ldr	r2, [r3, #28]
10040cf0:	4b3d      	ldr	r3, [pc, #244]	@ (10040de8 <SystemInit+0x184>)
10040cf2:	2180      	movs	r1, #128	@ 0x80
10040cf4:	0049      	lsls	r1, r1, #1
10040cf6:	430a      	orrs	r2, r1
10040cf8:	61da      	str	r2, [r3, #28]

  /* If Trimming values from engineering in flash locations are not present load default values */
  if (*(volatile uint32_t*)VALIDITY_LOCATION != VALIDITY_TAG)
10040cfa:	4b41      	ldr	r3, [pc, #260]	@ (10040e00 <SystemInit+0x19c>)
10040cfc:	681b      	ldr	r3, [r3, #0]
10040cfe:	4a41      	ldr	r2, [pc, #260]	@ (10040e04 <SystemInit+0x1a0>)
10040d00:	4293      	cmp	r3, r2
10040d02:	d055      	beq.n	10040db0 <SystemInit+0x14c>
  {
    hsiCalib       = 0x21;
10040d04:	2321      	movs	r3, #33	@ 0x21
10040d06:	617b      	str	r3, [r7, #20]
    lsiBw          = 8;
10040d08:	2308      	movs	r3, #8
10040d0a:	613b      	str	r3, [r7, #16]
    mainRegulator  = 0x03;
10040d0c:	2303      	movs	r3, #3
10040d0e:	60fb      	str	r3, [r7, #12]
    smpsOutVoltage = 0x03;
10040d10:	2303      	movs	r3, #3
10040d12:	60bb      	str	r3, [r7, #8]

    /* Set HSI Calibration Trimming value */
    MODIFY_REG(RCC->CSSWCR, RCC_CSSWCR_HSITRIMSW, hsiCalib << RCC_CSSWCR_HSITRIMSW_Pos);
10040d14:	4b33      	ldr	r3, [pc, #204]	@ (10040de4 <SystemInit+0x180>)
10040d16:	68db      	ldr	r3, [r3, #12]
10040d18:	4a3b      	ldr	r2, [pc, #236]	@ (10040e08 <SystemInit+0x1a4>)
10040d1a:	4013      	ands	r3, r2
10040d1c:	0019      	movs	r1, r3
10040d1e:	697b      	ldr	r3, [r7, #20]
10040d20:	061a      	lsls	r2, r3, #24
10040d22:	4b30      	ldr	r3, [pc, #192]	@ (10040de4 <SystemInit+0x180>)
10040d24:	430a      	orrs	r2, r1
10040d26:	60da      	str	r2, [r3, #12]
    SET_BIT(RCC->CSSWCR, RCC_CSSWCR_HSISWTRIMEN);
10040d28:	4b2e      	ldr	r3, [pc, #184]	@ (10040de4 <SystemInit+0x180>)
10040d2a:	68da      	ldr	r2, [r3, #12]
10040d2c:	4b2d      	ldr	r3, [pc, #180]	@ (10040de4 <SystemInit+0x180>)
10040d2e:	2180      	movs	r1, #128	@ 0x80
10040d30:	0409      	lsls	r1, r1, #16
10040d32:	430a      	orrs	r2, r1
10040d34:	60da      	str	r2, [r3, #12]

    /* Low speed internal RC trimming value set by software */
    MODIFY_REG(RCC->CSSWCR, RCC_CSSWCR_LSISWBW, lsiBw << RCC_CSSWCR_LSISWBW_Pos);
10040d36:	4b2b      	ldr	r3, [pc, #172]	@ (10040de4 <SystemInit+0x180>)
10040d38:	68db      	ldr	r3, [r3, #12]
10040d3a:	221e      	movs	r2, #30
10040d3c:	4393      	bics	r3, r2
10040d3e:	0019      	movs	r1, r3
10040d40:	693b      	ldr	r3, [r7, #16]
10040d42:	005a      	lsls	r2, r3, #1
10040d44:	4b27      	ldr	r3, [pc, #156]	@ (10040de4 <SystemInit+0x180>)
10040d46:	430a      	orrs	r2, r1
10040d48:	60da      	str	r2, [r3, #12]
    SET_BIT(RCC->CSSWCR, RCC_CSSWCR_LSISWTRIMEN);
10040d4a:	4b26      	ldr	r3, [pc, #152]	@ (10040de4 <SystemInit+0x180>)
10040d4c:	68da      	ldr	r2, [r3, #12]
10040d4e:	4b25      	ldr	r3, [pc, #148]	@ (10040de4 <SystemInit+0x180>)
10040d50:	2101      	movs	r1, #1
10040d52:	430a      	orrs	r2, r1
10040d54:	60da      	str	r2, [r3, #12]

    /* Set Main Regulator voltage Trimming value */
    MODIFY_REG(PWR->ENGTRIM, PWR_ENGTRIM_TRIM_MR, ((mainRegulator << PWR_ENGTRIM_TRIM_MR_Pos) & PWR_ENGTRIM_TRIM_MR));
10040d56:	4a24      	ldr	r2, [pc, #144]	@ (10040de8 <SystemInit+0x184>)
10040d58:	2394      	movs	r3, #148	@ 0x94
10040d5a:	58d3      	ldr	r3, [r2, r3]
10040d5c:	4a2b      	ldr	r2, [pc, #172]	@ (10040e0c <SystemInit+0x1a8>)
10040d5e:	401a      	ands	r2, r3
10040d60:	68fb      	ldr	r3, [r7, #12]
10040d62:	0199      	lsls	r1, r3, #6
10040d64:	23f0      	movs	r3, #240	@ 0xf0
10040d66:	009b      	lsls	r3, r3, #2
10040d68:	400b      	ands	r3, r1
10040d6a:	491f      	ldr	r1, [pc, #124]	@ (10040de8 <SystemInit+0x184>)
10040d6c:	4313      	orrs	r3, r2
10040d6e:	2294      	movs	r2, #148	@ 0x94
10040d70:	508b      	str	r3, [r1, r2]
    SET_BIT(PWR->ENGTRIM, PWR_ENGTRIM_TRIMMREN);
10040d72:	4a1d      	ldr	r2, [pc, #116]	@ (10040de8 <SystemInit+0x184>)
10040d74:	2394      	movs	r3, #148	@ 0x94
10040d76:	58d3      	ldr	r3, [r2, r3]
10040d78:	491b      	ldr	r1, [pc, #108]	@ (10040de8 <SystemInit+0x184>)
10040d7a:	2220      	movs	r2, #32
10040d7c:	4313      	orrs	r3, r2
10040d7e:	2294      	movs	r2, #148	@ 0x94
10040d80:	508b      	str	r3, [r1, r2]

    /* Set SMPS output voltage Trimming value */
    MODIFY_REG(PWR->ENGTRIM, PWR_ENGTRIM_SMPS_TRIM, ((smpsOutVoltage << PWR_ENGTRIM_SMPS_TRIM_Pos) & PWR_ENGTRIM_SMPS_TRIM));
10040d82:	4a19      	ldr	r2, [pc, #100]	@ (10040de8 <SystemInit+0x184>)
10040d84:	2394      	movs	r3, #148	@ 0x94
10040d86:	58d3      	ldr	r3, [r2, r3]
10040d88:	4a21      	ldr	r2, [pc, #132]	@ (10040e10 <SystemInit+0x1ac>)
10040d8a:	401a      	ands	r2, r3
10040d8c:	68bb      	ldr	r3, [r7, #8]
10040d8e:	02d9      	lsls	r1, r3, #11
10040d90:	23e0      	movs	r3, #224	@ 0xe0
10040d92:	019b      	lsls	r3, r3, #6
10040d94:	400b      	ands	r3, r1
10040d96:	4914      	ldr	r1, [pc, #80]	@ (10040de8 <SystemInit+0x184>)
10040d98:	4313      	orrs	r3, r2
10040d9a:	2294      	movs	r2, #148	@ 0x94
10040d9c:	508b      	str	r3, [r1, r2]
    SET_BIT(PWR->ENGTRIM, PWR_ENGTRIM_SMPSTRIMEN);
10040d9e:	4a12      	ldr	r2, [pc, #72]	@ (10040de8 <SystemInit+0x184>)
10040da0:	2394      	movs	r3, #148	@ 0x94
10040da2:	58d3      	ldr	r3, [r2, r3]
10040da4:	4910      	ldr	r1, [pc, #64]	@ (10040de8 <SystemInit+0x184>)
10040da6:	2280      	movs	r2, #128	@ 0x80
10040da8:	00d2      	lsls	r2, r2, #3
10040daa:	4313      	orrs	r3, r2
10040dac:	2294      	movs	r2, #148	@ 0x94
10040dae:	508b      	str	r3, [r1, r2]
  }

  /* Set all the interrupt with low priprity */
  for (i=0; i<32; i++)
10040db0:	1dfb      	adds	r3, r7, #7
10040db2:	2200      	movs	r2, #0
10040db4:	701a      	strb	r2, [r3, #0]
10040db6:	e00b      	b.n	10040dd0 <SystemInit+0x16c>
  {
    NVIC_SetPriority((IRQn_Type)i, IRQ_LOW_PRIORITY);
10040db8:	1dfb      	adds	r3, r7, #7
10040dba:	781b      	ldrb	r3, [r3, #0]
10040dbc:	b25b      	sxtb	r3, r3
10040dbe:	2103      	movs	r1, #3
10040dc0:	0018      	movs	r0, r3
10040dc2:	f7ff fecf 	bl	10040b64 <__NVIC_SetPriority>
  for (i=0; i<32; i++)
10040dc6:	1dfb      	adds	r3, r7, #7
10040dc8:	781a      	ldrb	r2, [r3, #0]
10040dca:	1dfb      	adds	r3, r7, #7
10040dcc:	3201      	adds	r2, #1
10040dce:	701a      	strb	r2, [r3, #0]
10040dd0:	1dfb      	adds	r3, r7, #7
10040dd2:	781b      	ldrb	r3, [r3, #0]
10040dd4:	2b1f      	cmp	r3, #31
10040dd6:	d9ef      	bls.n	10040db8 <SystemInit+0x154>
  __ASM volatile ("cpsie i" : : : "memory");
10040dd8:	b662      	cpsie	i
}
10040dda:	46c0      	nop			@ (mov r8, r8)
  }

  /* Enable all the irqs */
  __enable_irq();
}
10040ddc:	46c0      	nop			@ (mov r8, r8)
10040dde:	46bd      	mov	sp, r7
10040de0:	b006      	add	sp, #24
10040de2:	bd80      	pop	{r7, pc}
10040de4:	48400000 	.word	0x48400000
10040de8:	48500000 	.word	0x48500000
10040dec:	20000004 	.word	0x20000004
10040df0:	e000ed00 	.word	0xe000ed00
10040df4:	10040000 	.word	0x10040000
10040df8:	fffffeff 	.word	0xfffffeff
10040dfc:	fffffbff 	.word	0xfffffbff
10040e00:	10001ef8 	.word	0x10001ef8
10040e04:	fcbceccc 	.word	0xfcbceccc
10040e08:	c0ffffff 	.word	0xc0ffffff
10040e0c:	fffffc3f 	.word	0xfffffc3f
10040e10:	ffffc7ff 	.word	0xffffc7ff

10040e14 <SystemCoreClockUpdate>:
  *
  * @param  None
  * @retval None
  */
void SystemCoreClockUpdate(void)
{
10040e14:	b580      	push	{r7, lr}
10040e16:	b082      	sub	sp, #8
10040e18:	af00      	add	r7, sp, #0
  uint8_t directHSE_enabled;
  uint8_t divPrescaler;

  /* Get SYSCLK source HSE or HSI+PLL64MHz */
  directHSE_enabled = (RCC->CFGR & RCC_CFGR_HSESEL) >> RCC_CFGR_HSESEL_Pos;
10040e1a:	4b1e      	ldr	r3, [pc, #120]	@ (10040e94 <SystemCoreClockUpdate+0x80>)
10040e1c:	689b      	ldr	r3, [r3, #8]
10040e1e:	085b      	lsrs	r3, r3, #1
10040e20:	b2da      	uxtb	r2, r3
10040e22:	1dfb      	adds	r3, r7, #7
10040e24:	2101      	movs	r1, #1
10040e26:	400a      	ands	r2, r1
10040e28:	701a      	strb	r2, [r3, #0]

  /* Get the clock divider */
  divPrescaler = (RCC->CFGR & RCC_CFGR_CLKSYSDIV_STATUS) >> RCC_CFGR_CLKSYSDIV_STATUS_Pos;
10040e2a:	4b1a      	ldr	r3, [pc, #104]	@ (10040e94 <SystemCoreClockUpdate+0x80>)
10040e2c:	689b      	ldr	r3, [r3, #8]
10040e2e:	0a1b      	lsrs	r3, r3, #8
10040e30:	b2da      	uxtb	r2, r3
10040e32:	1dbb      	adds	r3, r7, #6
10040e34:	2107      	movs	r1, #7
10040e36:	400a      	ands	r2, r1
10040e38:	701a      	strb	r2, [r3, #0]

  if (directHSE_enabled)
10040e3a:	1dfb      	adds	r3, r7, #7
10040e3c:	781b      	ldrb	r3, [r3, #0]
10040e3e:	2b00      	cmp	r3, #0
10040e40:	d01d      	beq.n	10040e7e <SystemCoreClockUpdate+0x6a>
  {
    switch(divPrescaler)
10040e42:	1dbb      	adds	r3, r7, #6
10040e44:	781b      	ldrb	r3, [r3, #0]
10040e46:	2b00      	cmp	r3, #0
10040e48:	d002      	beq.n	10040e50 <SystemCoreClockUpdate+0x3c>
10040e4a:	2b01      	cmp	r3, #1
10040e4c:	d004      	beq.n	10040e58 <SystemCoreClockUpdate+0x44>
10040e4e:	e007      	b.n	10040e60 <SystemCoreClockUpdate+0x4c>
    {
    case 0:
      SystemCoreClock = HSE_VALUE;
10040e50:	4b11      	ldr	r3, [pc, #68]	@ (10040e98 <SystemCoreClockUpdate+0x84>)
10040e52:	4a12      	ldr	r2, [pc, #72]	@ (10040e9c <SystemCoreClockUpdate+0x88>)
10040e54:	601a      	str	r2, [r3, #0]
      break;
10040e56:	e019      	b.n	10040e8c <SystemCoreClockUpdate+0x78>
    case 1:
      SystemCoreClock = HSE_VALUE/2;
10040e58:	4b0f      	ldr	r3, [pc, #60]	@ (10040e98 <SystemCoreClockUpdate+0x84>)
10040e5a:	4a11      	ldr	r2, [pc, #68]	@ (10040ea0 <SystemCoreClockUpdate+0x8c>)
10040e5c:	601a      	str	r2, [r3, #0]
      break;
10040e5e:	e015      	b.n	10040e8c <SystemCoreClockUpdate+0x78>
    default:
      SystemCoreClock = HSE_VALUE/(3*(1<<(divPrescaler-2)));
10040e60:	1dbb      	adds	r3, r7, #6
10040e62:	781b      	ldrb	r3, [r3, #0]
10040e64:	3b02      	subs	r3, #2
10040e66:	2203      	movs	r2, #3
10040e68:	409a      	lsls	r2, r3
10040e6a:	0013      	movs	r3, r2
10040e6c:	0019      	movs	r1, r3
10040e6e:	480b      	ldr	r0, [pc, #44]	@ (10040e9c <SystemCoreClockUpdate+0x88>)
10040e70:	f7ff f926 	bl	100400c0 <__udivsi3>
10040e74:	0003      	movs	r3, r0
10040e76:	001a      	movs	r2, r3
10040e78:	4b07      	ldr	r3, [pc, #28]	@ (10040e98 <SystemCoreClockUpdate+0x84>)
10040e7a:	601a      	str	r2, [r3, #0]
      break;
10040e7c:	e006      	b.n	10040e8c <SystemCoreClockUpdate+0x78>
    }
  }
  else
  {
    SystemCoreClock = HSI_VALUE >> divPrescaler;
10040e7e:	1dbb      	adds	r3, r7, #6
10040e80:	781b      	ldrb	r3, [r3, #0]
10040e82:	4a08      	ldr	r2, [pc, #32]	@ (10040ea4 <SystemCoreClockUpdate+0x90>)
10040e84:	40da      	lsrs	r2, r3
10040e86:	4b04      	ldr	r3, [pc, #16]	@ (10040e98 <SystemCoreClockUpdate+0x84>)
10040e88:	601a      	str	r2, [r3, #0]
  }
}
10040e8a:	46c0      	nop			@ (mov r8, r8)
10040e8c:	46c0      	nop			@ (mov r8, r8)
10040e8e:	46bd      	mov	sp, r7
10040e90:	b002      	add	sp, #8
10040e92:	bd80      	pop	{r7, pc}
10040e94:	48400000 	.word	0x48400000
10040e98:	20000338 	.word	0x20000338
10040e9c:	02dc6c00 	.word	0x02dc6c00
10040ea0:	016e3600 	.word	0x016e3600
10040ea4:	03d09000 	.word	0x03d09000

10040ea8 <CPUcontextRestore>:
  *         by popping it from the stack 
  * @param  None
  * @retval None
  */
__WEAK void CPUcontextRestore(void)
{
10040ea8:	b580      	push	{r7, lr}
10040eaa:	af00      	add	r7, sp, #0
}
10040eac:	46c0      	nop			@ (mov r8, r8)
10040eae:	46bd      	mov	sp, r7
10040eb0:	bd80      	pop	{r7, pc}
	...

10040eb4 <Reset_Handler>:

	.section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
   ldr   r0, =_estack
10040eb4:	480c      	ldr	r0, [pc, #48]	@ (10040ee8 <LoopForever+0x2>)
   mov   sp, r0          /* set stack pointer */
10040eb6:	4685      	mov	sp, r0
/* Call the clock system initialization function.*/
  bl  SystemInit
10040eb8:	f7ff fed4 	bl	10040c64 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  movs  r1, #0
10040ebc:	2100      	movs	r1, #0
  b  LoopCopyDataInit
10040ebe:	e003      	b.n	10040ec8 <LoopCopyDataInit>

10040ec0 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
10040ec0:	4b0a      	ldr	r3, [pc, #40]	@ (10040eec <LoopForever+0x6>)
  ldr  r3, [r3, r1]
10040ec2:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
10040ec4:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
10040ec6:	3104      	adds	r1, #4

10040ec8 <LoopCopyDataInit>:

LoopCopyDataInit:
  ldr  r0, =_sdata
10040ec8:	4809      	ldr	r0, [pc, #36]	@ (10040ef0 <LoopForever+0xa>)
  ldr  r3, =_edata
10040eca:	4b0a      	ldr	r3, [pc, #40]	@ (10040ef4 <LoopForever+0xe>)
  adds  r2, r0, r1
10040ecc:	1842      	adds	r2, r0, r1
  cmp  r2, r3
10040ece:	429a      	cmp	r2, r3
  bcc  CopyDataInit
10040ed0:	d3f6      	bcc.n	10040ec0 <CopyDataInit>
  ldr  r2, =_sbss
10040ed2:	4a09      	ldr	r2, [pc, #36]	@ (10040ef8 <LoopForever+0x12>)
  b  LoopFillZerobss
10040ed4:	e002      	b.n	10040edc <LoopFillZerobss>

10040ed6 <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
  movs  r3, #0
10040ed6:	2300      	movs	r3, #0
  str  r3, [r2]
10040ed8:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
10040eda:	3204      	adds	r2, #4

10040edc <LoopFillZerobss>:


LoopFillZerobss:
  ldr  r3, = _ebss
10040edc:	4b07      	ldr	r3, [pc, #28]	@ (10040efc <LoopForever+0x16>)
  cmp  r2, r3
10040ede:	429a      	cmp	r2, r3
  bcc  FillZerobss
10040ee0:	d3f9      	bcc.n	10040ed6 <FillZerobss>

/* Call the application's entry point.*/
  bl  main
10040ee2:	f7ff fb8f 	bl	10040604 <main>

10040ee6 <LoopForever>:

LoopForever:
    b LoopForever
10040ee6:	e7fe      	b.n	10040ee6 <LoopForever>
   ldr   r0, =_estack
10040ee8:	20008000 	.word	0x20008000
  ldr  r3, =_sidata
10040eec:	10044678 	.word	0x10044678
  ldr  r0, =_sdata
10040ef0:	20000338 	.word	0x20000338
  ldr  r3, =_edata
10040ef4:	20000374 	.word	0x20000374
  ldr  r2, =_sbss
10040ef8:	20000034 	.word	0x20000034
  ldr  r3, = _ebss
10040efc:	20000338 	.word	0x20000338

10040f00 <ADC_IRQHandler>:
 * @retval : None
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
10040f00:	e7fe      	b.n	10040f00 <ADC_IRQHandler>
	...

10040f04 <LL_PWR_IsEnabledPUPDCfg>:
  * @brief  Check if pull-up and pull-down configuration is enabled
  * @rmtoll CR1          APC           LL_PWR_IsEnabledPUPDCfg
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_PWR_IsEnabledPUPDCfg(void)
{
10040f04:	b580      	push	{r7, lr}
10040f06:	af00      	add	r7, sp, #0
  return ((READ_BIT(PWR->CR1, PWR_CR1_APC) == (PWR_CR1_APC)) ? 1UL : 0UL);
10040f08:	4b05      	ldr	r3, [pc, #20]	@ (10040f20 <LL_PWR_IsEnabledPUPDCfg+0x1c>)
10040f0a:	681b      	ldr	r3, [r3, #0]
10040f0c:	2210      	movs	r2, #16
10040f0e:	4013      	ands	r3, r2
10040f10:	2b10      	cmp	r3, #16
10040f12:	d101      	bne.n	10040f18 <LL_PWR_IsEnabledPUPDCfg+0x14>
10040f14:	2301      	movs	r3, #1
10040f16:	e000      	b.n	10040f1a <LL_PWR_IsEnabledPUPDCfg+0x16>
10040f18:	2300      	movs	r3, #0
}
10040f1a:	0018      	movs	r0, r3
10040f1c:	46bd      	mov	sp, r7
10040f1e:	bd80      	pop	{r7, pc}
10040f20:	48500000 	.word	0x48500000

10040f24 <LL_PWR_EnableGPIOPullUp>:
  * @retval None
  * @note   Please refer the user manual to know which IOs are able for this
  *         feature.
  */
__STATIC_INLINE void LL_PWR_EnableGPIOPullUp(uint32_t GPIO, uint32_t GPIONumber)
{
10040f24:	b580      	push	{r7, lr}
10040f26:	b082      	sub	sp, #8
10040f28:	af00      	add	r7, sp, #0
10040f2a:	6078      	str	r0, [r7, #4]
10040f2c:	6039      	str	r1, [r7, #0]
  CLEAR_BIT(*((__IO uint32_t *)(GPIO + 4UL)), GPIONumber);
10040f2e:	687b      	ldr	r3, [r7, #4]
10040f30:	3304      	adds	r3, #4
10040f32:	681a      	ldr	r2, [r3, #0]
10040f34:	683b      	ldr	r3, [r7, #0]
10040f36:	43d9      	mvns	r1, r3
10040f38:	687b      	ldr	r3, [r7, #4]
10040f3a:	3304      	adds	r3, #4
10040f3c:	400a      	ands	r2, r1
10040f3e:	601a      	str	r2, [r3, #0]
  SET_BIT(*((__IO uint32_t *)GPIO), GPIONumber);
10040f40:	687b      	ldr	r3, [r7, #4]
10040f42:	6819      	ldr	r1, [r3, #0]
10040f44:	687b      	ldr	r3, [r7, #4]
10040f46:	683a      	ldr	r2, [r7, #0]
10040f48:	430a      	orrs	r2, r1
10040f4a:	601a      	str	r2, [r3, #0]
}
10040f4c:	46c0      	nop			@ (mov r8, r8)
10040f4e:	46bd      	mov	sp, r7
10040f50:	b002      	add	sp, #8
10040f52:	bd80      	pop	{r7, pc}

10040f54 <LL_AHB1_GRP1_EnableClock>:
{
10040f54:	b580      	push	{r7, lr}
10040f56:	b084      	sub	sp, #16
10040f58:	af00      	add	r7, sp, #0
10040f5a:	6078      	str	r0, [r7, #4]
  SET_BIT(RCC->AHBENR, Periphs);
10040f5c:	4b07      	ldr	r3, [pc, #28]	@ (10040f7c <LL_AHB1_GRP1_EnableClock+0x28>)
10040f5e:	6d19      	ldr	r1, [r3, #80]	@ 0x50
10040f60:	4b06      	ldr	r3, [pc, #24]	@ (10040f7c <LL_AHB1_GRP1_EnableClock+0x28>)
10040f62:	687a      	ldr	r2, [r7, #4]
10040f64:	430a      	orrs	r2, r1
10040f66:	651a      	str	r2, [r3, #80]	@ 0x50
  tmpreg = READ_BIT(RCC->AHBENR, Periphs);
10040f68:	4b04      	ldr	r3, [pc, #16]	@ (10040f7c <LL_AHB1_GRP1_EnableClock+0x28>)
10040f6a:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
10040f6c:	687a      	ldr	r2, [r7, #4]
10040f6e:	4013      	ands	r3, r2
10040f70:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
10040f72:	68fb      	ldr	r3, [r7, #12]
}
10040f74:	46c0      	nop			@ (mov r8, r8)
10040f76:	46bd      	mov	sp, r7
10040f78:	b004      	add	sp, #16
10040f7a:	bd80      	pop	{r7, pc}
10040f7c:	48400000 	.word	0x48400000

10040f80 <LL_APB0_GRP1_EnableClock>:
{
10040f80:	b580      	push	{r7, lr}
10040f82:	b084      	sub	sp, #16
10040f84:	af00      	add	r7, sp, #0
10040f86:	6078      	str	r0, [r7, #4]
  SET_BIT(RCC->APB0ENR, Periphs);
10040f88:	4b07      	ldr	r3, [pc, #28]	@ (10040fa8 <LL_APB0_GRP1_EnableClock+0x28>)
10040f8a:	6d59      	ldr	r1, [r3, #84]	@ 0x54
10040f8c:	4b06      	ldr	r3, [pc, #24]	@ (10040fa8 <LL_APB0_GRP1_EnableClock+0x28>)
10040f8e:	687a      	ldr	r2, [r7, #4]
10040f90:	430a      	orrs	r2, r1
10040f92:	655a      	str	r2, [r3, #84]	@ 0x54
  tmpreg = READ_BIT(RCC->APB0ENR, Periphs);
10040f94:	4b04      	ldr	r3, [pc, #16]	@ (10040fa8 <LL_APB0_GRP1_EnableClock+0x28>)
10040f96:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
10040f98:	687a      	ldr	r2, [r7, #4]
10040f9a:	4013      	ands	r3, r2
10040f9c:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
10040f9e:	68fb      	ldr	r3, [r7, #12]
}
10040fa0:	46c0      	nop			@ (mov r8, r8)
10040fa2:	46bd      	mov	sp, r7
10040fa4:	b004      	add	sp, #16
10040fa6:	bd80      	pop	{r7, pc}
10040fa8:	48400000 	.word	0x48400000

10040fac <LL_APB1_GRP1_EnableClock>:
{
10040fac:	b580      	push	{r7, lr}
10040fae:	b084      	sub	sp, #16
10040fb0:	af00      	add	r7, sp, #0
10040fb2:	6078      	str	r0, [r7, #4]
  SET_BIT(RCC->APB1ENR, Periphs);
10040fb4:	4b07      	ldr	r3, [pc, #28]	@ (10040fd4 <LL_APB1_GRP1_EnableClock+0x28>)
10040fb6:	6d99      	ldr	r1, [r3, #88]	@ 0x58
10040fb8:	4b06      	ldr	r3, [pc, #24]	@ (10040fd4 <LL_APB1_GRP1_EnableClock+0x28>)
10040fba:	687a      	ldr	r2, [r7, #4]
10040fbc:	430a      	orrs	r2, r1
10040fbe:	659a      	str	r2, [r3, #88]	@ 0x58
  tmpreg = READ_BIT(RCC->APB1ENR, Periphs);
10040fc0:	4b04      	ldr	r3, [pc, #16]	@ (10040fd4 <LL_APB1_GRP1_EnableClock+0x28>)
10040fc2:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
10040fc4:	687a      	ldr	r2, [r7, #4]
10040fc6:	4013      	ands	r3, r2
10040fc8:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
10040fca:	68fb      	ldr	r3, [r7, #12]
}
10040fcc:	46c0      	nop			@ (mov r8, r8)
10040fce:	46bd      	mov	sp, r7
10040fd0:	b004      	add	sp, #16
10040fd2:	bd80      	pop	{r7, pc}
10040fd4:	48400000 	.word	0x48400000

10040fd8 <BSP_LED_Init>:
  *     @arg  LD2
  *     @arg  LD3
  * @retval BSP error code.
  */
int32_t BSP_LED_Init(Led_TypeDef Led)
{
10040fd8:	b590      	push	{r4, r7, lr}
10040fda:	b089      	sub	sp, #36	@ 0x24
10040fdc:	af00      	add	r7, sp, #0
10040fde:	0002      	movs	r2, r0
10040fe0:	1dfb      	adds	r3, r7, #7
10040fe2:	701a      	strb	r2, [r3, #0]
  GPIO_InitTypeDef GPIO_Init;

  /* Enable the GPIO_LED Clock */
  if (Led == LD1)
10040fe4:	1dfb      	adds	r3, r7, #7
10040fe6:	781b      	ldrb	r3, [r3, #0]
10040fe8:	2b00      	cmp	r3, #0
10040fea:	d103      	bne.n	10040ff4 <BSP_LED_Init+0x1c>
  {
    LD1_GPIO_CLK_ENABLE();
10040fec:	2004      	movs	r0, #4
10040fee:	f7ff ffb1 	bl	10040f54 <LL_AHB1_GRP1_EnableClock>
10040ff2:	e00a      	b.n	1004100a <BSP_LED_Init+0x32>
  }
  else if (Led == LD2)
10040ff4:	1dfb      	adds	r3, r7, #7
10040ff6:	781b      	ldrb	r3, [r3, #0]
10040ff8:	2b01      	cmp	r3, #1
10040ffa:	d103      	bne.n	10041004 <BSP_LED_Init+0x2c>
  {
    LD2_GPIO_CLK_ENABLE();
10040ffc:	2008      	movs	r0, #8
10040ffe:	f7ff ffa9 	bl	10040f54 <LL_AHB1_GRP1_EnableClock>
10041002:	e002      	b.n	1004100a <BSP_LED_Init+0x32>
  }
  else /* Led = LD3 */
  {
    LD3_GPIO_CLK_ENABLE();
10041004:	2008      	movs	r0, #8
10041006:	f7ff ffa5 	bl	10040f54 <LL_AHB1_GRP1_EnableClock>
  }

  /* configure the GPIO_LED pin */
  GPIO_Init.Pin   = LED_PIN[Led];
1004100a:	1dfb      	adds	r3, r7, #7
1004100c:	781a      	ldrb	r2, [r3, #0]
1004100e:	4b28      	ldr	r3, [pc, #160]	@ (100410b0 <BSP_LED_Init+0xd8>)
10041010:	0052      	lsls	r2, r2, #1
10041012:	5ad3      	ldrh	r3, [r2, r3]
10041014:	001a      	movs	r2, r3
10041016:	240c      	movs	r4, #12
10041018:	193b      	adds	r3, r7, r4
1004101a:	601a      	str	r2, [r3, #0]
  GPIO_Init.Mode  = GPIO_MODE_OUTPUT_PP;
1004101c:	193b      	adds	r3, r7, r4
1004101e:	2201      	movs	r2, #1
10041020:	605a      	str	r2, [r3, #4]
  GPIO_Init.Pull  = GPIO_PULLUP;
10041022:	193b      	adds	r3, r7, r4
10041024:	2201      	movs	r2, #1
10041026:	609a      	str	r2, [r3, #8]
  GPIO_Init.Speed = GPIO_SPEED_FREQ_HIGH;
10041028:	193b      	adds	r3, r7, r4
1004102a:	2202      	movs	r2, #2
1004102c:	60da      	str	r2, [r3, #12]
  HAL_GPIO_Init(LED_PORT[Led], &GPIO_Init);
1004102e:	1dfb      	adds	r3, r7, #7
10041030:	781a      	ldrb	r2, [r3, #0]
10041032:	4b20      	ldr	r3, [pc, #128]	@ (100410b4 <BSP_LED_Init+0xdc>)
10041034:	0092      	lsls	r2, r2, #2
10041036:	58d3      	ldr	r3, [r2, r3]
10041038:	193a      	adds	r2, r7, r4
1004103a:	0011      	movs	r1, r2
1004103c:	0018      	movs	r0, r3
1004103e:	f000 fe23 	bl	10041c88 <HAL_GPIO_Init>

  if( LL_PWR_IsEnabledPUPDCfg() != 0)
10041042:	f7ff ff5f 	bl	10040f04 <LL_PWR_IsEnabledPUPDCfg>
10041046:	1e03      	subs	r3, r0, #0
10041048:	d01f      	beq.n	1004108a <BSP_LED_Init+0xb2>
  {
    if (LED_PORT[Led] == GPIOA)
1004104a:	1dfb      	adds	r3, r7, #7
1004104c:	781a      	ldrb	r2, [r3, #0]
1004104e:	4b19      	ldr	r3, [pc, #100]	@ (100410b4 <BSP_LED_Init+0xdc>)
10041050:	0092      	lsls	r2, r2, #2
10041052:	58d2      	ldr	r2, [r2, r3]
10041054:	2390      	movs	r3, #144	@ 0x90
10041056:	05db      	lsls	r3, r3, #23
10041058:	429a      	cmp	r2, r3
1004105a:	d106      	bne.n	1004106a <BSP_LED_Init+0x92>
    {
      LL_PWR_EnableGPIOPullUp( LL_PWR_GPIO_A, GPIO_Init.Pin);
1004105c:	193b      	adds	r3, r7, r4
1004105e:	681b      	ldr	r3, [r3, #0]
10041060:	4a15      	ldr	r2, [pc, #84]	@ (100410b8 <BSP_LED_Init+0xe0>)
10041062:	0019      	movs	r1, r3
10041064:	0010      	movs	r0, r2
10041066:	f7ff ff5d 	bl	10040f24 <LL_PWR_EnableGPIOPullUp>
    }
     if (LED_PORT[Led] == GPIOB)
1004106a:	1dfb      	adds	r3, r7, #7
1004106c:	781a      	ldrb	r2, [r3, #0]
1004106e:	4b11      	ldr	r3, [pc, #68]	@ (100410b4 <BSP_LED_Init+0xdc>)
10041070:	0092      	lsls	r2, r2, #2
10041072:	58d3      	ldr	r3, [r2, r3]
10041074:	4a11      	ldr	r2, [pc, #68]	@ (100410bc <BSP_LED_Init+0xe4>)
10041076:	4293      	cmp	r3, r2
10041078:	d107      	bne.n	1004108a <BSP_LED_Init+0xb2>
    {
      LL_PWR_EnableGPIOPullUp( LL_PWR_GPIO_B, GPIO_Init.Pin);
1004107a:	230c      	movs	r3, #12
1004107c:	18fb      	adds	r3, r7, r3
1004107e:	681b      	ldr	r3, [r3, #0]
10041080:	4a0f      	ldr	r2, [pc, #60]	@ (100410c0 <BSP_LED_Init+0xe8>)
10041082:	0019      	movs	r1, r3
10041084:	0010      	movs	r0, r2
10041086:	f7ff ff4d 	bl	10040f24 <LL_PWR_EnableGPIOPullUp>
    }
  }

  HAL_GPIO_WritePin(LED_PORT[Led], LED_PIN[Led], GPIO_PIN_SET);
1004108a:	1dfb      	adds	r3, r7, #7
1004108c:	781a      	ldrb	r2, [r3, #0]
1004108e:	4b09      	ldr	r3, [pc, #36]	@ (100410b4 <BSP_LED_Init+0xdc>)
10041090:	0092      	lsls	r2, r2, #2
10041092:	58d0      	ldr	r0, [r2, r3]
10041094:	1dfb      	adds	r3, r7, #7
10041096:	781a      	ldrb	r2, [r3, #0]
10041098:	4b05      	ldr	r3, [pc, #20]	@ (100410b0 <BSP_LED_Init+0xd8>)
1004109a:	0052      	lsls	r2, r2, #1
1004109c:	5ad3      	ldrh	r3, [r2, r3]
1004109e:	2201      	movs	r2, #1
100410a0:	0019      	movs	r1, r3
100410a2:	f000 ffa6 	bl	10041ff2 <HAL_GPIO_WritePin>

  return BSP_ERROR_NONE;
100410a6:	2300      	movs	r3, #0
}
100410a8:	0018      	movs	r0, r3
100410aa:	46bd      	mov	sp, r7
100410ac:	b009      	add	sp, #36	@ 0x24
100410ae:	bd90      	pop	{r4, r7, pc}
100410b0:	2000033c 	.word	0x2000033c
100410b4:	20000344 	.word	0x20000344
100410b8:	48500020 	.word	0x48500020
100410bc:	48100000 	.word	0x48100000
100410c0:	48500028 	.word	0x48500028

100410c4 <BSP_PB_Init>:
  *     @arg BUTTON_MODE_EXTI: Button will be connected to EXTI line with interrupt
  *                            generation capability
  * @retval BSP error code.
  */
int32_t BSP_PB_Init(Button_TypeDef Button, ButtonMode_TypeDef ButtonMode)
{
100410c4:	b580      	push	{r7, lr}
100410c6:	b088      	sub	sp, #32
100410c8:	af00      	add	r7, sp, #0
100410ca:	0002      	movs	r2, r0
100410cc:	1dfb      	adds	r3, r7, #7
100410ce:	701a      	strb	r2, [r3, #0]
100410d0:	1dbb      	adds	r3, r7, #6
100410d2:	1c0a      	adds	r2, r1, #0
100410d4:	701a      	strb	r2, [r3, #0]
  int32_t               status = BSP_ERROR_NONE;
100410d6:	2300      	movs	r3, #0
100410d8:	61fb      	str	r3, [r7, #28]
  GPIO_InitTypeDef      GPIO_Init;

  /* Enable the BUTTON clock */
  if (Button == B1)
100410da:	1dfb      	adds	r3, r7, #7
100410dc:	781b      	ldrb	r3, [r3, #0]
100410de:	2b00      	cmp	r3, #0
100410e0:	d103      	bne.n	100410ea <BSP_PB_Init+0x26>
  {
    B1_GPIO_CLK_ENABLE();
100410e2:	2004      	movs	r0, #4
100410e4:	f7ff ff36 	bl	10040f54 <LL_AHB1_GRP1_EnableClock>
100410e8:	e00a      	b.n	10041100 <BSP_PB_Init+0x3c>
  }
  else if (Button == B2)
100410ea:	1dfb      	adds	r3, r7, #7
100410ec:	781b      	ldrb	r3, [r3, #0]
100410ee:	2b01      	cmp	r3, #1
100410f0:	d103      	bne.n	100410fa <BSP_PB_Init+0x36>
  {
    B2_GPIO_CLK_ENABLE();
100410f2:	2008      	movs	r0, #8
100410f4:	f7ff ff2e 	bl	10040f54 <LL_AHB1_GRP1_EnableClock>
100410f8:	e002      	b.n	10041100 <BSP_PB_Init+0x3c>
  }
  else /* B3 */
  {
    B3_GPIO_CLK_ENABLE();
100410fa:	2008      	movs	r0, #8
100410fc:	f7ff ff2a 	bl	10040f54 <LL_AHB1_GRP1_EnableClock>
  }

  GPIO_Init.Pin   = BUTTON_PIN[Button];
10041100:	1dfb      	adds	r3, r7, #7
10041102:	781a      	ldrb	r2, [r3, #0]
10041104:	4b37      	ldr	r3, [pc, #220]	@ (100411e4 <BSP_PB_Init+0x120>)
10041106:	0052      	lsls	r2, r2, #1
10041108:	5ad3      	ldrh	r3, [r2, r3]
1004110a:	001a      	movs	r2, r3
1004110c:	2108      	movs	r1, #8
1004110e:	187b      	adds	r3, r7, r1
10041110:	601a      	str	r2, [r3, #0]
  GPIO_Init.Pull  = GPIO_PULLUP;
10041112:	187b      	adds	r3, r7, r1
10041114:	2201      	movs	r2, #1
10041116:	609a      	str	r2, [r3, #8]
  GPIO_Init.Speed = GPIO_SPEED_FREQ_HIGH;
10041118:	187b      	adds	r3, r7, r1
1004111a:	2202      	movs	r2, #2
1004111c:	60da      	str	r2, [r3, #12]

  if (ButtonMode == BUTTON_MODE_GPIO)
1004111e:	1dbb      	adds	r3, r7, #6
10041120:	781b      	ldrb	r3, [r3, #0]
10041122:	2b00      	cmp	r3, #0
10041124:	d10c      	bne.n	10041140 <BSP_PB_Init+0x7c>
  {
    /* Configure Button pin as input */
    GPIO_Init.Mode = GPIO_MODE_INPUT;
10041126:	187b      	adds	r3, r7, r1
10041128:	2200      	movs	r2, #0
1004112a:	605a      	str	r2, [r3, #4]
    HAL_GPIO_Init(BUTTON_PORT[Button], &GPIO_Init);
1004112c:	1dfb      	adds	r3, r7, #7
1004112e:	781a      	ldrb	r2, [r3, #0]
10041130:	4b2d      	ldr	r3, [pc, #180]	@ (100411e8 <BSP_PB_Init+0x124>)
10041132:	0092      	lsls	r2, r2, #2
10041134:	58d3      	ldr	r3, [r2, r3]
10041136:	187a      	adds	r2, r7, r1
10041138:	0011      	movs	r1, r2
1004113a:	0018      	movs	r0, r3
1004113c:	f000 fda4 	bl	10041c88 <HAL_GPIO_Init>
  }

  if (ButtonMode == BUTTON_MODE_EXTI)
10041140:	1dbb      	adds	r3, r7, #6
10041142:	781b      	ldrb	r3, [r3, #0]
10041144:	2b01      	cmp	r3, #1
10041146:	d123      	bne.n	10041190 <BSP_PB_Init+0xcc>
  {
    __HAL_RCC_SYSCFG_CLK_ENABLE();
10041148:	2380      	movs	r3, #128	@ 0x80
1004114a:	005b      	lsls	r3, r3, #1
1004114c:	0018      	movs	r0, r3
1004114e:	f7ff ff17 	bl	10040f80 <LL_APB0_GRP1_EnableClock>

    /* Configure Button pin as input with External interrupt */
    GPIO_Init.Mode = GPIO_MODE_IT_FALLING;
10041152:	2108      	movs	r1, #8
10041154:	187b      	adds	r3, r7, r1
10041156:	2280      	movs	r2, #128	@ 0x80
10041158:	0252      	lsls	r2, r2, #9
1004115a:	605a      	str	r2, [r3, #4]
    HAL_GPIO_Init(BUTTON_PORT[Button], &GPIO_Init);
1004115c:	1dfb      	adds	r3, r7, #7
1004115e:	781a      	ldrb	r2, [r3, #0]
10041160:	4b21      	ldr	r3, [pc, #132]	@ (100411e8 <BSP_PB_Init+0x124>)
10041162:	0092      	lsls	r2, r2, #2
10041164:	58d3      	ldr	r3, [r2, r3]
10041166:	187a      	adds	r2, r7, r1
10041168:	0011      	movs	r1, r2
1004116a:	0018      	movs	r0, r3
1004116c:	f000 fd8c 	bl	10041c88 <HAL_GPIO_Init>

    /* Enable and set Button EXTI Interrupt to the lowest priority */
    HAL_NVIC_SetPriority(BUTTON_IRQn[Button], 0x00, 0);
10041170:	1dfb      	adds	r3, r7, #7
10041172:	781b      	ldrb	r3, [r3, #0]
10041174:	4a1d      	ldr	r2, [pc, #116]	@ (100411ec <BSP_PB_Init+0x128>)
10041176:	56d3      	ldrsb	r3, [r2, r3]
10041178:	2200      	movs	r2, #0
1004117a:	2100      	movs	r1, #0
1004117c:	0018      	movs	r0, r3
1004117e:	f000 fd51 	bl	10041c24 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(BUTTON_IRQn[Button]);
10041182:	1dfb      	adds	r3, r7, #7
10041184:	781b      	ldrb	r3, [r3, #0]
10041186:	4a19      	ldr	r2, [pc, #100]	@ (100411ec <BSP_PB_Init+0x128>)
10041188:	56d3      	ldrsb	r3, [r2, r3]
1004118a:	0018      	movs	r0, r3
1004118c:	f000 fd5f 	bl	10041c4e <HAL_NVIC_EnableIRQ>

  }
  if( LL_PWR_IsEnabledPUPDCfg() != 0)
10041190:	f7ff feb8 	bl	10040f04 <LL_PWR_IsEnabledPUPDCfg>
10041194:	1e03      	subs	r3, r0, #0
10041196:	d020      	beq.n	100411da <BSP_PB_Init+0x116>
  {
    if (BUTTON_PORT[Button] == GPIOA)
10041198:	1dfb      	adds	r3, r7, #7
1004119a:	781a      	ldrb	r2, [r3, #0]
1004119c:	4b12      	ldr	r3, [pc, #72]	@ (100411e8 <BSP_PB_Init+0x124>)
1004119e:	0092      	lsls	r2, r2, #2
100411a0:	58d2      	ldr	r2, [r2, r3]
100411a2:	2390      	movs	r3, #144	@ 0x90
100411a4:	05db      	lsls	r3, r3, #23
100411a6:	429a      	cmp	r2, r3
100411a8:	d107      	bne.n	100411ba <BSP_PB_Init+0xf6>
    {
      LL_PWR_EnableGPIOPullUp( LL_PWR_GPIO_A, GPIO_Init.Pin);
100411aa:	2308      	movs	r3, #8
100411ac:	18fb      	adds	r3, r7, r3
100411ae:	681b      	ldr	r3, [r3, #0]
100411b0:	4a0f      	ldr	r2, [pc, #60]	@ (100411f0 <BSP_PB_Init+0x12c>)
100411b2:	0019      	movs	r1, r3
100411b4:	0010      	movs	r0, r2
100411b6:	f7ff feb5 	bl	10040f24 <LL_PWR_EnableGPIOPullUp>
    }
     if (BUTTON_PORT[Button] == GPIOB)
100411ba:	1dfb      	adds	r3, r7, #7
100411bc:	781a      	ldrb	r2, [r3, #0]
100411be:	4b0a      	ldr	r3, [pc, #40]	@ (100411e8 <BSP_PB_Init+0x124>)
100411c0:	0092      	lsls	r2, r2, #2
100411c2:	58d3      	ldr	r3, [r2, r3]
100411c4:	4a0b      	ldr	r2, [pc, #44]	@ (100411f4 <BSP_PB_Init+0x130>)
100411c6:	4293      	cmp	r3, r2
100411c8:	d107      	bne.n	100411da <BSP_PB_Init+0x116>
    {
      LL_PWR_EnableGPIOPullUp( LL_PWR_GPIO_B, GPIO_Init.Pin);
100411ca:	2308      	movs	r3, #8
100411cc:	18fb      	adds	r3, r7, r3
100411ce:	681b      	ldr	r3, [r3, #0]
100411d0:	4a09      	ldr	r2, [pc, #36]	@ (100411f8 <BSP_PB_Init+0x134>)
100411d2:	0019      	movs	r1, r3
100411d4:	0010      	movs	r0, r2
100411d6:	f7ff fea5 	bl	10040f24 <LL_PWR_EnableGPIOPullUp>
    }
  }
  return status;
100411da:	69fb      	ldr	r3, [r7, #28]
}
100411dc:	0018      	movs	r0, r3
100411de:	46bd      	mov	sp, r7
100411e0:	b008      	add	sp, #32
100411e2:	bd80      	pop	{r7, pc}
100411e4:	20000350 	.word	0x20000350
100411e8:	20000358 	.word	0x20000358
100411ec:	20000364 	.word	0x20000364
100411f0:	48500020 	.word	0x48500020
100411f4:	48100000 	.word	0x48100000
100411f8:	48500028 	.word	0x48500028

100411fc <BSP_COM_Init>:
  * @param  COM_Init Pointer to a COM_InitTypeDef structure that contains the
  *                  configuration information for the specified COM peripheral.
  * @retval BSP error code.
  */
int32_t BSP_COM_Init(COM_TypeDef COM, COM_InitTypeDef *COM_Init)
{
100411fc:	b580      	push	{r7, lr}
100411fe:	b084      	sub	sp, #16
10041200:	af00      	add	r7, sp, #0
10041202:	0002      	movs	r2, r0
10041204:	6039      	str	r1, [r7, #0]
10041206:	1dfb      	adds	r3, r7, #7
10041208:	701a      	strb	r2, [r3, #0]
  int32_t status = BSP_ERROR_NONE;
1004120a:	2300      	movs	r3, #0
1004120c:	60fb      	str	r3, [r7, #12]

  if (COM_Init == NULL)
1004120e:	683b      	ldr	r3, [r7, #0]
10041210:	2b00      	cmp	r3, #0
10041212:	d103      	bne.n	1004121c <BSP_COM_Init+0x20>
  {
    status = BSP_ERROR_WRONG_PARAM;
10041214:	2302      	movs	r3, #2
10041216:	425b      	negs	r3, r3
10041218:	60fb      	str	r3, [r7, #12]
1004121a:	e026      	b.n	1004126a <BSP_COM_Init+0x6e>
  }
  else
  {
    /* Initialize COM instance */
    hcom_uart[COM].Instance = COM_UART[COM];
1004121c:	1dfb      	adds	r3, r7, #7
1004121e:	7819      	ldrb	r1, [r3, #0]
10041220:	1dfb      	adds	r3, r7, #7
10041222:	781a      	ldrb	r2, [r3, #0]
10041224:	4b13      	ldr	r3, [pc, #76]	@ (10041274 <BSP_COM_Init+0x78>)
10041226:	0089      	lsls	r1, r1, #2
10041228:	58c9      	ldr	r1, [r1, r3]
1004122a:	4b13      	ldr	r3, [pc, #76]	@ (10041278 <BSP_COM_Init+0x7c>)
1004122c:	2094      	movs	r0, #148	@ 0x94
1004122e:	4342      	muls	r2, r0
10041230:	50d1      	str	r1, [r2, r3]

#if (USE_HAL_UART_REGISTER_CALLBACKS == 0)
    UART_MspInit(&hcom_uart[COM]);
10041232:	1dfb      	adds	r3, r7, #7
10041234:	781b      	ldrb	r3, [r3, #0]
10041236:	2294      	movs	r2, #148	@ 0x94
10041238:	435a      	muls	r2, r3
1004123a:	4b0f      	ldr	r3, [pc, #60]	@ (10041278 <BSP_COM_Init+0x7c>)
1004123c:	18d3      	adds	r3, r2, r3
1004123e:	0018      	movs	r0, r3
10041240:	f000 f84e 	bl	100412e0 <UART_MspInit>
        status = BSP_ERROR_MSP_FAILURE;
      }
    }
#endif

    if (status == BSP_ERROR_NONE)
10041244:	68fb      	ldr	r3, [r7, #12]
10041246:	2b00      	cmp	r3, #0
10041248:	d10f      	bne.n	1004126a <BSP_COM_Init+0x6e>
    {
      if (MX_USART1_Init(&hcom_uart[COM], COM_Init) != HAL_OK)
1004124a:	1dfb      	adds	r3, r7, #7
1004124c:	781b      	ldrb	r3, [r3, #0]
1004124e:	2294      	movs	r2, #148	@ 0x94
10041250:	435a      	muls	r2, r3
10041252:	4b09      	ldr	r3, [pc, #36]	@ (10041278 <BSP_COM_Init+0x7c>)
10041254:	18d3      	adds	r3, r2, r3
10041256:	683a      	ldr	r2, [r7, #0]
10041258:	0011      	movs	r1, r2
1004125a:	0018      	movs	r0, r3
1004125c:	f000 f80e 	bl	1004127c <MX_USART1_Init>
10041260:	1e03      	subs	r3, r0, #0
10041262:	d002      	beq.n	1004126a <BSP_COM_Init+0x6e>
      {
        status = BSP_ERROR_PERIPH_FAILURE;
10041264:	2304      	movs	r3, #4
10041266:	425b      	negs	r3, r3
10041268:	60fb      	str	r3, [r7, #12]
      }
    }
  }

  return status;
1004126a:	68fb      	ldr	r3, [r7, #12]
}
1004126c:	0018      	movs	r0, r3
1004126e:	46bd      	mov	sp, r7
10041270:	b004      	add	sp, #16
10041272:	bd80      	pop	{r7, pc}
10041274:	20000368 	.word	0x20000368
10041278:	20000098 	.word	0x20000098

1004127c <MX_USART1_Init>:
  * @param  huart UART handle.
  * @param  MXInit UART initialization structure.
  * @retval HAL status.
  */
__weak HAL_StatusTypeDef MX_USART1_Init(UART_HandleTypeDef* huart, MX_UART_InitTypeDef *MXInit)
{
1004127c:	b580      	push	{r7, lr}
1004127e:	b082      	sub	sp, #8
10041280:	af00      	add	r7, sp, #0
10041282:	6078      	str	r0, [r7, #4]
10041284:	6039      	str	r1, [r7, #0]
  /* UART configuration */
  huart->Init.BaudRate       = MXInit->BaudRate;
10041286:	683b      	ldr	r3, [r7, #0]
10041288:	681a      	ldr	r2, [r3, #0]
1004128a:	687b      	ldr	r3, [r7, #4]
1004128c:	605a      	str	r2, [r3, #4]
  huart->Init.WordLength     = (uint32_t) MXInit->WordLength;
1004128e:	683b      	ldr	r3, [r7, #0]
10041290:	685a      	ldr	r2, [r3, #4]
10041292:	687b      	ldr	r3, [r7, #4]
10041294:	609a      	str	r2, [r3, #8]
  huart->Init.StopBits       = (uint32_t) MXInit->StopBits;
10041296:	683b      	ldr	r3, [r7, #0]
10041298:	891b      	ldrh	r3, [r3, #8]
1004129a:	001a      	movs	r2, r3
1004129c:	687b      	ldr	r3, [r7, #4]
1004129e:	60da      	str	r2, [r3, #12]
  huart->Init.Parity         = (uint32_t) MXInit->Parity;
100412a0:	683b      	ldr	r3, [r7, #0]
100412a2:	895b      	ldrh	r3, [r3, #10]
100412a4:	001a      	movs	r2, r3
100412a6:	687b      	ldr	r3, [r7, #4]
100412a8:	611a      	str	r2, [r3, #16]
  huart->Init.Mode           = UART_MODE_TX_RX;
100412aa:	687b      	ldr	r3, [r7, #4]
100412ac:	220c      	movs	r2, #12
100412ae:	615a      	str	r2, [r3, #20]
  huart->Init.HwFlowCtl      = (uint32_t) MXInit->HwFlowCtl;
100412b0:	683b      	ldr	r3, [r7, #0]
100412b2:	899b      	ldrh	r3, [r3, #12]
100412b4:	001a      	movs	r2, r3
100412b6:	687b      	ldr	r3, [r7, #4]
100412b8:	619a      	str	r2, [r3, #24]
  huart->Init.OverSampling   = UART_OVERSAMPLING_8;
100412ba:	687b      	ldr	r3, [r7, #4]
100412bc:	2280      	movs	r2, #128	@ 0x80
100412be:	0212      	lsls	r2, r2, #8
100412c0:	61da      	str	r2, [r3, #28]
  huart->Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
100412c2:	687b      	ldr	r3, [r7, #4]
100412c4:	2200      	movs	r2, #0
100412c6:	621a      	str	r2, [r3, #32]
  huart->Init.ClockPrescaler = UART_PRESCALER_DIV1;
100412c8:	687b      	ldr	r3, [r7, #4]
100412ca:	2200      	movs	r2, #0
100412cc:	625a      	str	r2, [r3, #36]	@ 0x24

  return HAL_UART_Init(huart);
100412ce:	687b      	ldr	r3, [r7, #4]
100412d0:	0018      	movs	r0, r3
100412d2:	f002 f9e5 	bl	100436a0 <HAL_UART_Init>
100412d6:	0003      	movs	r3, r0
}
100412d8:	0018      	movs	r0, r3
100412da:	46bd      	mov	sp, r7
100412dc:	b002      	add	sp, #8
100412de:	bd80      	pop	{r7, pc}

100412e0 <UART_MspInit>:
  * @brief  Initialize UART MSP.
  * @param  huart UART handle.
  * @retval None.
  */
static void UART_MspInit(UART_HandleTypeDef *huart)
{
100412e0:	b590      	push	{r4, r7, lr}
100412e2:	b089      	sub	sp, #36	@ 0x24
100412e4:	af00      	add	r7, sp, #0
100412e6:	6078      	str	r0, [r7, #4]

  /* Prevent unused argument(s) compilation warning */
  UNUSED(huart);

  /* Enable COM and GPIO clocks */
  COM1_TX_GPIO_CLK_ENABLE();
100412e8:	2004      	movs	r0, #4
100412ea:	f7ff fe33 	bl	10040f54 <LL_AHB1_GRP1_EnableClock>
  COM1_RX_GPIO_CLK_ENABLE();
100412ee:	2004      	movs	r0, #4
100412f0:	f7ff fe30 	bl	10040f54 <LL_AHB1_GRP1_EnableClock>
  COM1_CLK_ENABLE();
100412f4:	2380      	movs	r3, #128	@ 0x80
100412f6:	00db      	lsls	r3, r3, #3
100412f8:	0018      	movs	r0, r3
100412fa:	f7ff fe57 	bl	10040fac <LL_APB1_GRP1_EnableClock>

  /* Configure COM Tx as alternate function */
  GPIO_Init.Pin       = COM1_TX_PIN;
100412fe:	240c      	movs	r4, #12
10041300:	193b      	adds	r3, r7, r4
10041302:	2202      	movs	r2, #2
10041304:	601a      	str	r2, [r3, #0]
  GPIO_Init.Mode      = GPIO_MODE_AF_PP;
10041306:	193b      	adds	r3, r7, r4
10041308:	2202      	movs	r2, #2
1004130a:	605a      	str	r2, [r3, #4]
  GPIO_Init.Speed     = GPIO_SPEED_FREQ_HIGH;
1004130c:	193b      	adds	r3, r7, r4
1004130e:	2202      	movs	r2, #2
10041310:	60da      	str	r2, [r3, #12]
  GPIO_Init.Pull      = GPIO_PULLUP;
10041312:	193b      	adds	r3, r7, r4
10041314:	2201      	movs	r2, #1
10041316:	609a      	str	r2, [r3, #8]
  GPIO_Init.Alternate = COM1_TX_AF;
10041318:	193b      	adds	r3, r7, r4
1004131a:	2201      	movs	r2, #1
1004131c:	611a      	str	r2, [r3, #16]
  HAL_GPIO_Init(COM1_TX_GPIO_PORT, &GPIO_Init);
1004131e:	193a      	adds	r2, r7, r4
10041320:	2390      	movs	r3, #144	@ 0x90
10041322:	05db      	lsls	r3, r3, #23
10041324:	0011      	movs	r1, r2
10041326:	0018      	movs	r0, r3
10041328:	f000 fcae 	bl	10041c88 <HAL_GPIO_Init>
  if( LL_PWR_IsEnabledPUPDCfg() != 0)
1004132c:	f7ff fdea 	bl	10040f04 <LL_PWR_IsEnabledPUPDCfg>
10041330:	1e03      	subs	r3, r0, #0
10041332:	d006      	beq.n	10041342 <UART_MspInit+0x62>
  {
    LL_PWR_EnableGPIOPullUp( LL_PWR_GPIO_A, GPIO_Init.Pin);
10041334:	193b      	adds	r3, r7, r4
10041336:	681b      	ldr	r3, [r3, #0]
10041338:	4a0b      	ldr	r2, [pc, #44]	@ (10041368 <UART_MspInit+0x88>)
1004133a:	0019      	movs	r1, r3
1004133c:	0010      	movs	r0, r2
1004133e:	f7ff fdf1 	bl	10040f24 <LL_PWR_EnableGPIOPullUp>
  }
  /* Configure COM Rx as alternate function */
  GPIO_Init.Pin       = COM1_RX_PIN;
10041342:	210c      	movs	r1, #12
10041344:	187b      	adds	r3, r7, r1
10041346:	2280      	movs	r2, #128	@ 0x80
10041348:	0212      	lsls	r2, r2, #8
1004134a:	601a      	str	r2, [r3, #0]
  GPIO_Init.Alternate = COM1_RX_AF;
1004134c:	187b      	adds	r3, r7, r1
1004134e:	2201      	movs	r2, #1
10041350:	611a      	str	r2, [r3, #16]
  HAL_GPIO_Init(COM1_RX_GPIO_PORT, &GPIO_Init);
10041352:	187a      	adds	r2, r7, r1
10041354:	2390      	movs	r3, #144	@ 0x90
10041356:	05db      	lsls	r3, r3, #23
10041358:	0011      	movs	r1, r2
1004135a:	0018      	movs	r0, r3
1004135c:	f000 fc94 	bl	10041c88 <HAL_GPIO_Init>
}
10041360:	46c0      	nop			@ (mov r8, r8)
10041362:	46bd      	mov	sp, r7
10041364:	b009      	add	sp, #36	@ 0x24
10041366:	bd90      	pop	{r4, r7, pc}
10041368:	48500020 	.word	0x48500020

1004136c <ssd1306_Reset>:
#include <stdlib.h>
#include <string.h>  // For memcpy

#if defined(SSD1306_USE_I2C)

void ssd1306_Reset(void) {
1004136c:	b580      	push	{r7, lr}
1004136e:	af00      	add	r7, sp, #0
    /* for I2C - do nothing */
}
10041370:	46c0      	nop			@ (mov r8, r8)
10041372:	46bd      	mov	sp, r7
10041374:	bd80      	pop	{r7, pc}
	...

10041378 <ssd1306_WriteCommand>:

// Send a byte to the command register
void ssd1306_WriteCommand(uint8_t byte) {
10041378:	b580      	push	{r7, lr}
1004137a:	b086      	sub	sp, #24
1004137c:	af04      	add	r7, sp, #16
1004137e:	0002      	movs	r2, r0
10041380:	1dfb      	adds	r3, r7, #7
10041382:	701a      	strb	r2, [r3, #0]
    HAL_I2C_Mem_Write(&SSD1306_I2C_PORT, SSD1306_I2C_ADDR, 0x00, 1, &byte, 1, HAL_MAX_DELAY);
10041384:	4808      	ldr	r0, [pc, #32]	@ (100413a8 <ssd1306_WriteCommand+0x30>)
10041386:	2301      	movs	r3, #1
10041388:	425b      	negs	r3, r3
1004138a:	9302      	str	r3, [sp, #8]
1004138c:	2301      	movs	r3, #1
1004138e:	9301      	str	r3, [sp, #4]
10041390:	1dfb      	adds	r3, r7, #7
10041392:	9300      	str	r3, [sp, #0]
10041394:	2301      	movs	r3, #1
10041396:	2200      	movs	r2, #0
10041398:	2178      	movs	r1, #120	@ 0x78
1004139a:	f000 feed 	bl	10042178 <HAL_I2C_Mem_Write>
}
1004139e:	46c0      	nop			@ (mov r8, r8)
100413a0:	46bd      	mov	sp, r7
100413a2:	b002      	add	sp, #8
100413a4:	bd80      	pop	{r7, pc}
100413a6:	46c0      	nop			@ (mov r8, r8)
100413a8:	20000044 	.word	0x20000044

100413ac <ssd1306_WriteData>:

// Send data
void ssd1306_WriteData(uint8_t* buffer, size_t buff_size) {
100413ac:	b580      	push	{r7, lr}
100413ae:	b086      	sub	sp, #24
100413b0:	af04      	add	r7, sp, #16
100413b2:	6078      	str	r0, [r7, #4]
100413b4:	6039      	str	r1, [r7, #0]
    HAL_I2C_Mem_Write(&SSD1306_I2C_PORT, SSD1306_I2C_ADDR, 0x40, 1, buffer, buff_size, HAL_MAX_DELAY);
100413b6:	683b      	ldr	r3, [r7, #0]
100413b8:	b29b      	uxth	r3, r3
100413ba:	4808      	ldr	r0, [pc, #32]	@ (100413dc <ssd1306_WriteData+0x30>)
100413bc:	2201      	movs	r2, #1
100413be:	4252      	negs	r2, r2
100413c0:	9202      	str	r2, [sp, #8]
100413c2:	9301      	str	r3, [sp, #4]
100413c4:	687b      	ldr	r3, [r7, #4]
100413c6:	9300      	str	r3, [sp, #0]
100413c8:	2301      	movs	r3, #1
100413ca:	2240      	movs	r2, #64	@ 0x40
100413cc:	2178      	movs	r1, #120	@ 0x78
100413ce:	f000 fed3 	bl	10042178 <HAL_I2C_Mem_Write>
}
100413d2:	46c0      	nop			@ (mov r8, r8)
100413d4:	46bd      	mov	sp, r7
100413d6:	b002      	add	sp, #8
100413d8:	bd80      	pop	{r7, pc}
100413da:	46c0      	nop			@ (mov r8, r8)
100413dc:	20000044 	.word	0x20000044

100413e0 <ssd1306_Init>:
    }
    return ret;
}

/* Initialize the oled screen */
void ssd1306_Init(void) {
100413e0:	b580      	push	{r7, lr}
100413e2:	af00      	add	r7, sp, #0
    // Reset OLED
    ssd1306_Reset();
100413e4:	f7ff ffc2 	bl	1004136c <ssd1306_Reset>

    // Wait for the screen to boot
    HAL_Delay(100);
100413e8:	2064      	movs	r0, #100	@ 0x64
100413ea:	f000 fb4b 	bl	10041a84 <HAL_Delay>

    // Init OLED
    ssd1306_SetDisplayOn(0); //display off
100413ee:	2000      	movs	r0, #0
100413f0:	f000 fa9c 	bl	1004192c <ssd1306_SetDisplayOn>

    ssd1306_WriteCommand(0x20); //Set Memory Addressing Mode
100413f4:	2020      	movs	r0, #32
100413f6:	f7ff ffbf 	bl	10041378 <ssd1306_WriteCommand>
    ssd1306_WriteCommand(0x00); // 00b,Horizontal Addressing Mode; 01b,Vertical Addressing Mode;
100413fa:	2000      	movs	r0, #0
100413fc:	f7ff ffbc 	bl	10041378 <ssd1306_WriteCommand>
                                // 10b,Page Addressing Mode (RESET); 11b,Invalid

    ssd1306_WriteCommand(0xB0); //Set Page Start Address for Page Addressing Mode,0-7
10041400:	20b0      	movs	r0, #176	@ 0xb0
10041402:	f7ff ffb9 	bl	10041378 <ssd1306_WriteCommand>

#ifdef SSD1306_MIRROR_VERT
    ssd1306_WriteCommand(0xC0); // Mirror vertically
#else
    ssd1306_WriteCommand(0xC8); //Set COM Output Scan Direction
10041406:	20c8      	movs	r0, #200	@ 0xc8
10041408:	f7ff ffb6 	bl	10041378 <ssd1306_WriteCommand>
#endif

    ssd1306_WriteCommand(0x00); //---set low column address
1004140c:	2000      	movs	r0, #0
1004140e:	f7ff ffb3 	bl	10041378 <ssd1306_WriteCommand>
    ssd1306_WriteCommand(0x10); //---set high column address
10041412:	2010      	movs	r0, #16
10041414:	f7ff ffb0 	bl	10041378 <ssd1306_WriteCommand>

    ssd1306_WriteCommand(0x40); //--set start line address - CHECK
10041418:	2040      	movs	r0, #64	@ 0x40
1004141a:	f7ff ffad 	bl	10041378 <ssd1306_WriteCommand>

    ssd1306_SetContrast(0xFF);
1004141e:	20ff      	movs	r0, #255	@ 0xff
10041420:	f000 fa6b 	bl	100418fa <ssd1306_SetContrast>

#ifdef SSD1306_MIRROR_HORIZ
    ssd1306_WriteCommand(0xA0); // Mirror horizontally
#else
    ssd1306_WriteCommand(0xA1); //--set segment re-map 0 to 127 - CHECK
10041424:	20a1      	movs	r0, #161	@ 0xa1
10041426:	f7ff ffa7 	bl	10041378 <ssd1306_WriteCommand>
#endif

#ifdef SSD1306_INVERSE_COLOR
    ssd1306_WriteCommand(0xA7); //--set inverse color
#else
    ssd1306_WriteCommand(0xA6); //--set normal color
1004142a:	20a6      	movs	r0, #166	@ 0xa6
1004142c:	f7ff ffa4 	bl	10041378 <ssd1306_WriteCommand>
// Set multiplex ratio.
#if (SSD1306_HEIGHT == 128)
    // Found in the Luma Python lib for SH1106.
    ssd1306_WriteCommand(0xFF);
#else
    ssd1306_WriteCommand(0xA8); //--set multiplex ratio(1 to 64) - CHECK
10041430:	20a8      	movs	r0, #168	@ 0xa8
10041432:	f7ff ffa1 	bl	10041378 <ssd1306_WriteCommand>
#endif

#if (SSD1306_HEIGHT == 32)
    ssd1306_WriteCommand(0x1F); //
10041436:	201f      	movs	r0, #31
10041438:	f7ff ff9e 	bl	10041378 <ssd1306_WriteCommand>
    ssd1306_WriteCommand(0x3F); // Seems to work for 128px high displays too.
#else
#error "Only 32, 64, or 128 lines of height are supported!"
#endif

    ssd1306_WriteCommand(0xA4); //0xa4,Output follows RAM content;0xa5,Output ignores RAM content
1004143c:	20a4      	movs	r0, #164	@ 0xa4
1004143e:	f7ff ff9b 	bl	10041378 <ssd1306_WriteCommand>

    ssd1306_WriteCommand(0xD3); //-set display offset - CHECK
10041442:	20d3      	movs	r0, #211	@ 0xd3
10041444:	f7ff ff98 	bl	10041378 <ssd1306_WriteCommand>
    ssd1306_WriteCommand(0x00); //-not offset
10041448:	2000      	movs	r0, #0
1004144a:	f7ff ff95 	bl	10041378 <ssd1306_WriteCommand>

    ssd1306_WriteCommand(0xD5); //--set display clock divide ratio/oscillator frequency
1004144e:	20d5      	movs	r0, #213	@ 0xd5
10041450:	f7ff ff92 	bl	10041378 <ssd1306_WriteCommand>
    ssd1306_WriteCommand(0xF0); //--set divide ratio
10041454:	20f0      	movs	r0, #240	@ 0xf0
10041456:	f7ff ff8f 	bl	10041378 <ssd1306_WriteCommand>

    ssd1306_WriteCommand(0xD9); //--set pre-charge period
1004145a:	20d9      	movs	r0, #217	@ 0xd9
1004145c:	f7ff ff8c 	bl	10041378 <ssd1306_WriteCommand>
    ssd1306_WriteCommand(0x22); //
10041460:	2022      	movs	r0, #34	@ 0x22
10041462:	f7ff ff89 	bl	10041378 <ssd1306_WriteCommand>

    ssd1306_WriteCommand(0xDA); //--set com pins hardware configuration - CHECK
10041466:	20da      	movs	r0, #218	@ 0xda
10041468:	f7ff ff86 	bl	10041378 <ssd1306_WriteCommand>
#if (SSD1306_HEIGHT == 32)
    ssd1306_WriteCommand(0x02);
1004146c:	2002      	movs	r0, #2
1004146e:	f7ff ff83 	bl	10041378 <ssd1306_WriteCommand>
    ssd1306_WriteCommand(0x12);
#else
#error "Only 32, 64, or 128 lines of height are supported!"
#endif

    ssd1306_WriteCommand(0xDB); //--set vcomh
10041472:	20db      	movs	r0, #219	@ 0xdb
10041474:	f7ff ff80 	bl	10041378 <ssd1306_WriteCommand>
    ssd1306_WriteCommand(0x20); //0x20,0.77xVcc
10041478:	2020      	movs	r0, #32
1004147a:	f7ff ff7d 	bl	10041378 <ssd1306_WriteCommand>

    ssd1306_WriteCommand(0x8D); //--set DC-DC enable
1004147e:	208d      	movs	r0, #141	@ 0x8d
10041480:	f7ff ff7a 	bl	10041378 <ssd1306_WriteCommand>
    ssd1306_WriteCommand(0x14); //
10041484:	2014      	movs	r0, #20
10041486:	f7ff ff77 	bl	10041378 <ssd1306_WriteCommand>
    ssd1306_SetDisplayOn(1); //--turn on SSD1306 panel
1004148a:	2001      	movs	r0, #1
1004148c:	f000 fa4e 	bl	1004192c <ssd1306_SetDisplayOn>

    // Clear screen
    ssd1306_Fill(Black);
10041490:	2000      	movs	r0, #0
10041492:	f000 f811 	bl	100414b8 <ssd1306_Fill>
    
    // Flush buffer to screen
    ssd1306_UpdateScreen();
10041496:	f000 f829 	bl	100414ec <ssd1306_UpdateScreen>
    
    // Set default values for screen object
    SSD1306.CurrentX = 0;
1004149a:	4b06      	ldr	r3, [pc, #24]	@ (100414b4 <ssd1306_Init+0xd4>)
1004149c:	2200      	movs	r2, #0
1004149e:	801a      	strh	r2, [r3, #0]
    SSD1306.CurrentY = 0;
100414a0:	4b04      	ldr	r3, [pc, #16]	@ (100414b4 <ssd1306_Init+0xd4>)
100414a2:	2200      	movs	r2, #0
100414a4:	805a      	strh	r2, [r3, #2]
    
    SSD1306.Initialized = 1;
100414a6:	4b03      	ldr	r3, [pc, #12]	@ (100414b4 <ssd1306_Init+0xd4>)
100414a8:	2201      	movs	r2, #1
100414aa:	711a      	strb	r2, [r3, #4]
}
100414ac:	46c0      	nop			@ (mov r8, r8)
100414ae:	46bd      	mov	sp, r7
100414b0:	bd80      	pop	{r7, pc}
100414b2:	46c0      	nop			@ (mov r8, r8)
100414b4:	2000032c 	.word	0x2000032c

100414b8 <ssd1306_Fill>:

/* Fill the whole screen with the given color */
void ssd1306_Fill(SSD1306_COLOR color) {
100414b8:	b580      	push	{r7, lr}
100414ba:	b082      	sub	sp, #8
100414bc:	af00      	add	r7, sp, #0
100414be:	0002      	movs	r2, r0
100414c0:	1dfb      	adds	r3, r7, #7
100414c2:	701a      	strb	r2, [r3, #0]
    memset(SSD1306_Buffer, (color == Black) ? 0x00 : 0xFF, sizeof(SSD1306_Buffer));
100414c4:	1dfb      	adds	r3, r7, #7
100414c6:	781b      	ldrb	r3, [r3, #0]
100414c8:	2b00      	cmp	r3, #0
100414ca:	d101      	bne.n	100414d0 <ssd1306_Fill+0x18>
100414cc:	2300      	movs	r3, #0
100414ce:	e000      	b.n	100414d2 <ssd1306_Fill+0x1a>
100414d0:	23ff      	movs	r3, #255	@ 0xff
100414d2:	2280      	movs	r2, #128	@ 0x80
100414d4:	0092      	lsls	r2, r2, #2
100414d6:	4804      	ldr	r0, [pc, #16]	@ (100414e8 <ssd1306_Fill+0x30>)
100414d8:	0019      	movs	r1, r3
100414da:	f002 fcdb 	bl	10043e94 <memset>
}
100414de:	46c0      	nop			@ (mov r8, r8)
100414e0:	46bd      	mov	sp, r7
100414e2:	b002      	add	sp, #8
100414e4:	bd80      	pop	{r7, pc}
100414e6:	46c0      	nop			@ (mov r8, r8)
100414e8:	2000012c 	.word	0x2000012c

100414ec <ssd1306_UpdateScreen>:

/* Write the screenbuffer with changed to the screen */
void ssd1306_UpdateScreen(void) {
100414ec:	b580      	push	{r7, lr}
100414ee:	b082      	sub	sp, #8
100414f0:	af00      	add	r7, sp, #0
    // depends on the screen height:
    //
    //  * 32px   ==  4 pages
    //  * 64px   ==  8 pages
    //  * 128px  ==  16 pages
    for(uint8_t i = 0; i < SSD1306_HEIGHT/8; i++) {
100414f2:	1dfb      	adds	r3, r7, #7
100414f4:	2200      	movs	r2, #0
100414f6:	701a      	strb	r2, [r3, #0]
100414f8:	e01a      	b.n	10041530 <ssd1306_UpdateScreen+0x44>
        ssd1306_WriteCommand(0xB0 + i); // Set the current RAM page address.
100414fa:	1dfb      	adds	r3, r7, #7
100414fc:	781b      	ldrb	r3, [r3, #0]
100414fe:	3b50      	subs	r3, #80	@ 0x50
10041500:	b2db      	uxtb	r3, r3
10041502:	0018      	movs	r0, r3
10041504:	f7ff ff38 	bl	10041378 <ssd1306_WriteCommand>
        ssd1306_WriteCommand(0x00 + SSD1306_X_OFFSET_LOWER);
10041508:	2000      	movs	r0, #0
1004150a:	f7ff ff35 	bl	10041378 <ssd1306_WriteCommand>
        ssd1306_WriteCommand(0x10 + SSD1306_X_OFFSET_UPPER);
1004150e:	2010      	movs	r0, #16
10041510:	f7ff ff32 	bl	10041378 <ssd1306_WriteCommand>
        ssd1306_WriteData(&SSD1306_Buffer[SSD1306_WIDTH*i],SSD1306_WIDTH);
10041514:	1dfb      	adds	r3, r7, #7
10041516:	781b      	ldrb	r3, [r3, #0]
10041518:	01da      	lsls	r2, r3, #7
1004151a:	4b0a      	ldr	r3, [pc, #40]	@ (10041544 <ssd1306_UpdateScreen+0x58>)
1004151c:	18d3      	adds	r3, r2, r3
1004151e:	2180      	movs	r1, #128	@ 0x80
10041520:	0018      	movs	r0, r3
10041522:	f7ff ff43 	bl	100413ac <ssd1306_WriteData>
    for(uint8_t i = 0; i < SSD1306_HEIGHT/8; i++) {
10041526:	1dfb      	adds	r3, r7, #7
10041528:	781a      	ldrb	r2, [r3, #0]
1004152a:	1dfb      	adds	r3, r7, #7
1004152c:	3201      	adds	r2, #1
1004152e:	701a      	strb	r2, [r3, #0]
10041530:	1dfb      	adds	r3, r7, #7
10041532:	781b      	ldrb	r3, [r3, #0]
10041534:	2b03      	cmp	r3, #3
10041536:	d9e0      	bls.n	100414fa <ssd1306_UpdateScreen+0xe>
    }
}
10041538:	46c0      	nop			@ (mov r8, r8)
1004153a:	46c0      	nop			@ (mov r8, r8)
1004153c:	46bd      	mov	sp, r7
1004153e:	b002      	add	sp, #8
10041540:	bd80      	pop	{r7, pc}
10041542:	46c0      	nop			@ (mov r8, r8)
10041544:	2000012c 	.word	0x2000012c

10041548 <ssd1306_DrawPixel>:
 * Draw one pixel in the screenbuffer
 * X => X Coordinate
 * Y => Y Coordinate
 * color => Pixel color
 */
void ssd1306_DrawPixel(uint8_t x, uint8_t y, SSD1306_COLOR color) {
10041548:	b590      	push	{r4, r7, lr}
1004154a:	b083      	sub	sp, #12
1004154c:	af00      	add	r7, sp, #0
1004154e:	0004      	movs	r4, r0
10041550:	0008      	movs	r0, r1
10041552:	0011      	movs	r1, r2
10041554:	1dfb      	adds	r3, r7, #7
10041556:	1c22      	adds	r2, r4, #0
10041558:	701a      	strb	r2, [r3, #0]
1004155a:	1dbb      	adds	r3, r7, #6
1004155c:	1c02      	adds	r2, r0, #0
1004155e:	701a      	strb	r2, [r3, #0]
10041560:	1d7b      	adds	r3, r7, #5
10041562:	1c0a      	adds	r2, r1, #0
10041564:	701a      	strb	r2, [r3, #0]
    if(x >= SSD1306_WIDTH || y >= SSD1306_HEIGHT) {
10041566:	1dfb      	adds	r3, r7, #7
10041568:	781b      	ldrb	r3, [r3, #0]
1004156a:	b25b      	sxtb	r3, r3
1004156c:	2b00      	cmp	r3, #0
1004156e:	db47      	blt.n	10041600 <ssd1306_DrawPixel+0xb8>
10041570:	1dbb      	adds	r3, r7, #6
10041572:	781b      	ldrb	r3, [r3, #0]
10041574:	2b1f      	cmp	r3, #31
10041576:	d843      	bhi.n	10041600 <ssd1306_DrawPixel+0xb8>
        // Don't write outside the buffer
        return;
    }
   
    // Draw in the right color
    if(color == White) {
10041578:	1d7b      	adds	r3, r7, #5
1004157a:	781b      	ldrb	r3, [r3, #0]
1004157c:	2b01      	cmp	r3, #1
1004157e:	d11e      	bne.n	100415be <ssd1306_DrawPixel+0x76>
        SSD1306_Buffer[x + (y / 8) * SSD1306_WIDTH] |= 1 << (y % 8);
10041580:	1dfb      	adds	r3, r7, #7
10041582:	781a      	ldrb	r2, [r3, #0]
10041584:	1dbb      	adds	r3, r7, #6
10041586:	781b      	ldrb	r3, [r3, #0]
10041588:	08db      	lsrs	r3, r3, #3
1004158a:	b2d8      	uxtb	r0, r3
1004158c:	0003      	movs	r3, r0
1004158e:	01db      	lsls	r3, r3, #7
10041590:	18d3      	adds	r3, r2, r3
10041592:	4a1d      	ldr	r2, [pc, #116]	@ (10041608 <ssd1306_DrawPixel+0xc0>)
10041594:	5cd3      	ldrb	r3, [r2, r3]
10041596:	b25a      	sxtb	r2, r3
10041598:	1dbb      	adds	r3, r7, #6
1004159a:	781b      	ldrb	r3, [r3, #0]
1004159c:	2107      	movs	r1, #7
1004159e:	400b      	ands	r3, r1
100415a0:	2101      	movs	r1, #1
100415a2:	4099      	lsls	r1, r3
100415a4:	000b      	movs	r3, r1
100415a6:	b25b      	sxtb	r3, r3
100415a8:	4313      	orrs	r3, r2
100415aa:	b259      	sxtb	r1, r3
100415ac:	1dfb      	adds	r3, r7, #7
100415ae:	781a      	ldrb	r2, [r3, #0]
100415b0:	0003      	movs	r3, r0
100415b2:	01db      	lsls	r3, r3, #7
100415b4:	18d3      	adds	r3, r2, r3
100415b6:	b2c9      	uxtb	r1, r1
100415b8:	4a13      	ldr	r2, [pc, #76]	@ (10041608 <ssd1306_DrawPixel+0xc0>)
100415ba:	54d1      	strb	r1, [r2, r3]
100415bc:	e021      	b.n	10041602 <ssd1306_DrawPixel+0xba>
    } else { 
        SSD1306_Buffer[x + (y / 8) * SSD1306_WIDTH] &= ~(1 << (y % 8));
100415be:	1dfb      	adds	r3, r7, #7
100415c0:	781a      	ldrb	r2, [r3, #0]
100415c2:	1dbb      	adds	r3, r7, #6
100415c4:	781b      	ldrb	r3, [r3, #0]
100415c6:	08db      	lsrs	r3, r3, #3
100415c8:	b2d8      	uxtb	r0, r3
100415ca:	0003      	movs	r3, r0
100415cc:	01db      	lsls	r3, r3, #7
100415ce:	18d3      	adds	r3, r2, r3
100415d0:	4a0d      	ldr	r2, [pc, #52]	@ (10041608 <ssd1306_DrawPixel+0xc0>)
100415d2:	5cd3      	ldrb	r3, [r2, r3]
100415d4:	b25b      	sxtb	r3, r3
100415d6:	1dba      	adds	r2, r7, #6
100415d8:	7812      	ldrb	r2, [r2, #0]
100415da:	2107      	movs	r1, #7
100415dc:	400a      	ands	r2, r1
100415de:	2101      	movs	r1, #1
100415e0:	4091      	lsls	r1, r2
100415e2:	000a      	movs	r2, r1
100415e4:	b252      	sxtb	r2, r2
100415e6:	43d2      	mvns	r2, r2
100415e8:	b252      	sxtb	r2, r2
100415ea:	4013      	ands	r3, r2
100415ec:	b259      	sxtb	r1, r3
100415ee:	1dfb      	adds	r3, r7, #7
100415f0:	781a      	ldrb	r2, [r3, #0]
100415f2:	0003      	movs	r3, r0
100415f4:	01db      	lsls	r3, r3, #7
100415f6:	18d3      	adds	r3, r2, r3
100415f8:	b2c9      	uxtb	r1, r1
100415fa:	4a03      	ldr	r2, [pc, #12]	@ (10041608 <ssd1306_DrawPixel+0xc0>)
100415fc:	54d1      	strb	r1, [r2, r3]
100415fe:	e000      	b.n	10041602 <ssd1306_DrawPixel+0xba>
        return;
10041600:	46c0      	nop			@ (mov r8, r8)
    }
}
10041602:	46bd      	mov	sp, r7
10041604:	b003      	add	sp, #12
10041606:	bd90      	pop	{r4, r7, pc}
10041608:	2000012c 	.word	0x2000012c

1004160c <ssd1306_WriteChar>:
 * Draw 1 char to the screen buffer
 * ch       => char om weg te schrijven
 * Font     => Font waarmee we gaan schrijven
 * color    => Black or White
 */
char ssd1306_WriteChar(char ch, SSD1306_Font_t Font, SSD1306_COLOR color) {
1004160c:	b590      	push	{r4, r7, lr}
1004160e:	b089      	sub	sp, #36	@ 0x24
10041610:	af00      	add	r7, sp, #0
10041612:	0004      	movs	r4, r0
10041614:	0038      	movs	r0, r7
10041616:	6001      	str	r1, [r0, #0]
10041618:	6042      	str	r2, [r0, #4]
1004161a:	6083      	str	r3, [r0, #8]
1004161c:	210f      	movs	r1, #15
1004161e:	187b      	adds	r3, r7, r1
10041620:	1c22      	adds	r2, r4, #0
10041622:	701a      	strb	r2, [r3, #0]
    uint32_t i, b, j;
    
    // Check if character is valid
    if (ch < 32 || ch > 126)
10041624:	000a      	movs	r2, r1
10041626:	18bb      	adds	r3, r7, r2
10041628:	781b      	ldrb	r3, [r3, #0]
1004162a:	2b1f      	cmp	r3, #31
1004162c:	d903      	bls.n	10041636 <ssd1306_WriteChar+0x2a>
1004162e:	18bb      	adds	r3, r7, r2
10041630:	781b      	ldrb	r3, [r3, #0]
10041632:	2b7e      	cmp	r3, #126	@ 0x7e
10041634:	d901      	bls.n	1004163a <ssd1306_WriteChar+0x2e>
        return 0;
10041636:	2300      	movs	r3, #0
10041638:	e08b      	b.n	10041752 <ssd1306_WriteChar+0x146>
    
    // Char width is not equal to font width for proportional font
    const uint8_t char_width = Font.char_width ? Font.char_width[ch-32] : Font.width;
1004163a:	003b      	movs	r3, r7
1004163c:	689b      	ldr	r3, [r3, #8]
1004163e:	2b00      	cmp	r3, #0
10041640:	d008      	beq.n	10041654 <ssd1306_WriteChar+0x48>
10041642:	003b      	movs	r3, r7
10041644:	689a      	ldr	r2, [r3, #8]
10041646:	230f      	movs	r3, #15
10041648:	18fb      	adds	r3, r7, r3
1004164a:	781b      	ldrb	r3, [r3, #0]
1004164c:	3b20      	subs	r3, #32
1004164e:	18d3      	adds	r3, r2, r3
10041650:	781b      	ldrb	r3, [r3, #0]
10041652:	e001      	b.n	10041658 <ssd1306_WriteChar+0x4c>
10041654:	003b      	movs	r3, r7
10041656:	781b      	ldrb	r3, [r3, #0]
10041658:	2117      	movs	r1, #23
1004165a:	187a      	adds	r2, r7, r1
1004165c:	7013      	strb	r3, [r2, #0]
    // Check remaining space on current line
    if (SSD1306_WIDTH < (SSD1306.CurrentX + char_width) ||
1004165e:	4b3f      	ldr	r3, [pc, #252]	@ (1004175c <ssd1306_WriteChar+0x150>)
10041660:	881b      	ldrh	r3, [r3, #0]
10041662:	001a      	movs	r2, r3
10041664:	187b      	adds	r3, r7, r1
10041666:	781b      	ldrb	r3, [r3, #0]
10041668:	18d3      	adds	r3, r2, r3
1004166a:	2b80      	cmp	r3, #128	@ 0x80
1004166c:	dc07      	bgt.n	1004167e <ssd1306_WriteChar+0x72>
        SSD1306_HEIGHT < (SSD1306.CurrentY + Font.height))
1004166e:	4b3b      	ldr	r3, [pc, #236]	@ (1004175c <ssd1306_WriteChar+0x150>)
10041670:	885b      	ldrh	r3, [r3, #2]
10041672:	001a      	movs	r2, r3
10041674:	003b      	movs	r3, r7
10041676:	785b      	ldrb	r3, [r3, #1]
10041678:	18d3      	adds	r3, r2, r3
    if (SSD1306_WIDTH < (SSD1306.CurrentX + char_width) ||
1004167a:	2b20      	cmp	r3, #32
1004167c:	dd01      	ble.n	10041682 <ssd1306_WriteChar+0x76>
    {
        // Not enough space on current line
        return 0;
1004167e:	2300      	movs	r3, #0
10041680:	e067      	b.n	10041752 <ssd1306_WriteChar+0x146>
    }
    
    // Use the font to write
    for(i = 0; i < Font.height; i++) {
10041682:	2300      	movs	r3, #0
10041684:	61fb      	str	r3, [r7, #28]
10041686:	e051      	b.n	1004172c <ssd1306_WriteChar+0x120>
        b = Font.data[(ch - 32) * Font.height + i];
10041688:	003b      	movs	r3, r7
1004168a:	685a      	ldr	r2, [r3, #4]
1004168c:	230f      	movs	r3, #15
1004168e:	18fb      	adds	r3, r7, r3
10041690:	781b      	ldrb	r3, [r3, #0]
10041692:	3b20      	subs	r3, #32
10041694:	0039      	movs	r1, r7
10041696:	7849      	ldrb	r1, [r1, #1]
10041698:	434b      	muls	r3, r1
1004169a:	0019      	movs	r1, r3
1004169c:	69fb      	ldr	r3, [r7, #28]
1004169e:	18cb      	adds	r3, r1, r3
100416a0:	005b      	lsls	r3, r3, #1
100416a2:	18d3      	adds	r3, r2, r3
100416a4:	881b      	ldrh	r3, [r3, #0]
100416a6:	613b      	str	r3, [r7, #16]
        for(j = 0; j < char_width; j++) {
100416a8:	2300      	movs	r3, #0
100416aa:	61bb      	str	r3, [r7, #24]
100416ac:	e035      	b.n	1004171a <ssd1306_WriteChar+0x10e>
            if((b << j) & 0x8000)  {
100416ae:	693a      	ldr	r2, [r7, #16]
100416b0:	69bb      	ldr	r3, [r7, #24]
100416b2:	409a      	lsls	r2, r3
100416b4:	2380      	movs	r3, #128	@ 0x80
100416b6:	021b      	lsls	r3, r3, #8
100416b8:	4013      	ands	r3, r2
100416ba:	d014      	beq.n	100416e6 <ssd1306_WriteChar+0xda>
                ssd1306_DrawPixel(SSD1306.CurrentX + j, (SSD1306.CurrentY + i), (SSD1306_COLOR) color);
100416bc:	4b27      	ldr	r3, [pc, #156]	@ (1004175c <ssd1306_WriteChar+0x150>)
100416be:	881b      	ldrh	r3, [r3, #0]
100416c0:	b2da      	uxtb	r2, r3
100416c2:	69bb      	ldr	r3, [r7, #24]
100416c4:	b2db      	uxtb	r3, r3
100416c6:	18d3      	adds	r3, r2, r3
100416c8:	b2d8      	uxtb	r0, r3
100416ca:	4b24      	ldr	r3, [pc, #144]	@ (1004175c <ssd1306_WriteChar+0x150>)
100416cc:	885b      	ldrh	r3, [r3, #2]
100416ce:	b2da      	uxtb	r2, r3
100416d0:	69fb      	ldr	r3, [r7, #28]
100416d2:	b2db      	uxtb	r3, r3
100416d4:	18d3      	adds	r3, r2, r3
100416d6:	b2d9      	uxtb	r1, r3
100416d8:	2330      	movs	r3, #48	@ 0x30
100416da:	18fb      	adds	r3, r7, r3
100416dc:	781b      	ldrb	r3, [r3, #0]
100416de:	001a      	movs	r2, r3
100416e0:	f7ff ff32 	bl	10041548 <ssd1306_DrawPixel>
100416e4:	e016      	b.n	10041714 <ssd1306_WriteChar+0x108>
            } else {
                ssd1306_DrawPixel(SSD1306.CurrentX + j, (SSD1306.CurrentY + i), (SSD1306_COLOR)!color);
100416e6:	4b1d      	ldr	r3, [pc, #116]	@ (1004175c <ssd1306_WriteChar+0x150>)
100416e8:	881b      	ldrh	r3, [r3, #0]
100416ea:	b2da      	uxtb	r2, r3
100416ec:	69bb      	ldr	r3, [r7, #24]
100416ee:	b2db      	uxtb	r3, r3
100416f0:	18d3      	adds	r3, r2, r3
100416f2:	b2d8      	uxtb	r0, r3
100416f4:	4b19      	ldr	r3, [pc, #100]	@ (1004175c <ssd1306_WriteChar+0x150>)
100416f6:	885b      	ldrh	r3, [r3, #2]
100416f8:	b2da      	uxtb	r2, r3
100416fa:	69fb      	ldr	r3, [r7, #28]
100416fc:	b2db      	uxtb	r3, r3
100416fe:	18d3      	adds	r3, r2, r3
10041700:	b2d9      	uxtb	r1, r3
10041702:	2330      	movs	r3, #48	@ 0x30
10041704:	18fb      	adds	r3, r7, r3
10041706:	781b      	ldrb	r3, [r3, #0]
10041708:	425a      	negs	r2, r3
1004170a:	4153      	adcs	r3, r2
1004170c:	b2db      	uxtb	r3, r3
1004170e:	001a      	movs	r2, r3
10041710:	f7ff ff1a 	bl	10041548 <ssd1306_DrawPixel>
        for(j = 0; j < char_width; j++) {
10041714:	69bb      	ldr	r3, [r7, #24]
10041716:	3301      	adds	r3, #1
10041718:	61bb      	str	r3, [r7, #24]
1004171a:	2317      	movs	r3, #23
1004171c:	18fb      	adds	r3, r7, r3
1004171e:	781b      	ldrb	r3, [r3, #0]
10041720:	69ba      	ldr	r2, [r7, #24]
10041722:	429a      	cmp	r2, r3
10041724:	d3c3      	bcc.n	100416ae <ssd1306_WriteChar+0xa2>
    for(i = 0; i < Font.height; i++) {
10041726:	69fb      	ldr	r3, [r7, #28]
10041728:	3301      	adds	r3, #1
1004172a:	61fb      	str	r3, [r7, #28]
1004172c:	003b      	movs	r3, r7
1004172e:	785b      	ldrb	r3, [r3, #1]
10041730:	001a      	movs	r2, r3
10041732:	69fb      	ldr	r3, [r7, #28]
10041734:	4293      	cmp	r3, r2
10041736:	d3a7      	bcc.n	10041688 <ssd1306_WriteChar+0x7c>
            }
        }
    }
    
    // The current space is now taken
    SSD1306.CurrentX += char_width;
10041738:	4b08      	ldr	r3, [pc, #32]	@ (1004175c <ssd1306_WriteChar+0x150>)
1004173a:	881a      	ldrh	r2, [r3, #0]
1004173c:	2317      	movs	r3, #23
1004173e:	18fb      	adds	r3, r7, r3
10041740:	781b      	ldrb	r3, [r3, #0]
10041742:	b29b      	uxth	r3, r3
10041744:	18d3      	adds	r3, r2, r3
10041746:	b29a      	uxth	r2, r3
10041748:	4b04      	ldr	r3, [pc, #16]	@ (1004175c <ssd1306_WriteChar+0x150>)
1004174a:	801a      	strh	r2, [r3, #0]
    
    // Return written char for validation
    return ch;
1004174c:	230f      	movs	r3, #15
1004174e:	18fb      	adds	r3, r7, r3
10041750:	781b      	ldrb	r3, [r3, #0]
}
10041752:	0018      	movs	r0, r3
10041754:	46bd      	mov	sp, r7
10041756:	b009      	add	sp, #36	@ 0x24
10041758:	bd90      	pop	{r4, r7, pc}
1004175a:	46c0      	nop			@ (mov r8, r8)
1004175c:	2000032c 	.word	0x2000032c

10041760 <ssd1306_WriteString>:

/* Write full string to screenbuffer */
char ssd1306_WriteString(char* str, SSD1306_Font_t Font, SSD1306_COLOR color) {
10041760:	b580      	push	{r7, lr}
10041762:	b086      	sub	sp, #24
10041764:	af02      	add	r7, sp, #8
10041766:	60f8      	str	r0, [r7, #12]
10041768:	0038      	movs	r0, r7
1004176a:	6001      	str	r1, [r0, #0]
1004176c:	6042      	str	r2, [r0, #4]
1004176e:	6083      	str	r3, [r0, #8]
    while (*str) {
10041770:	e017      	b.n	100417a2 <ssd1306_WriteString+0x42>
        if (ssd1306_WriteChar(*str, Font, color) != *str) {
10041772:	68fb      	ldr	r3, [r7, #12]
10041774:	7818      	ldrb	r0, [r3, #0]
10041776:	003b      	movs	r3, r7
10041778:	2218      	movs	r2, #24
1004177a:	18ba      	adds	r2, r7, r2
1004177c:	7812      	ldrb	r2, [r2, #0]
1004177e:	9200      	str	r2, [sp, #0]
10041780:	6819      	ldr	r1, [r3, #0]
10041782:	685a      	ldr	r2, [r3, #4]
10041784:	689b      	ldr	r3, [r3, #8]
10041786:	f7ff ff41 	bl	1004160c <ssd1306_WriteChar>
1004178a:	0003      	movs	r3, r0
1004178c:	001a      	movs	r2, r3
1004178e:	68fb      	ldr	r3, [r7, #12]
10041790:	781b      	ldrb	r3, [r3, #0]
10041792:	429a      	cmp	r2, r3
10041794:	d002      	beq.n	1004179c <ssd1306_WriteString+0x3c>
            // Char could not be written
            return *str;
10041796:	68fb      	ldr	r3, [r7, #12]
10041798:	781b      	ldrb	r3, [r3, #0]
1004179a:	e008      	b.n	100417ae <ssd1306_WriteString+0x4e>
        }
        str++;
1004179c:	68fb      	ldr	r3, [r7, #12]
1004179e:	3301      	adds	r3, #1
100417a0:	60fb      	str	r3, [r7, #12]
    while (*str) {
100417a2:	68fb      	ldr	r3, [r7, #12]
100417a4:	781b      	ldrb	r3, [r3, #0]
100417a6:	2b00      	cmp	r3, #0
100417a8:	d1e3      	bne.n	10041772 <ssd1306_WriteString+0x12>
    }
    
    // Everything ok
    return *str;
100417aa:	68fb      	ldr	r3, [r7, #12]
100417ac:	781b      	ldrb	r3, [r3, #0]
}
100417ae:	0018      	movs	r0, r3
100417b0:	46bd      	mov	sp, r7
100417b2:	b004      	add	sp, #16
100417b4:	bd80      	pop	{r7, pc}
	...

100417b8 <ssd1306_SetCursor>:

/* Position the cursor */
void ssd1306_SetCursor(uint8_t x, uint8_t y) {
100417b8:	b580      	push	{r7, lr}
100417ba:	b082      	sub	sp, #8
100417bc:	af00      	add	r7, sp, #0
100417be:	0002      	movs	r2, r0
100417c0:	1dfb      	adds	r3, r7, #7
100417c2:	701a      	strb	r2, [r3, #0]
100417c4:	1dbb      	adds	r3, r7, #6
100417c6:	1c0a      	adds	r2, r1, #0
100417c8:	701a      	strb	r2, [r3, #0]
    SSD1306.CurrentX = x;
100417ca:	1dfb      	adds	r3, r7, #7
100417cc:	781b      	ldrb	r3, [r3, #0]
100417ce:	b29a      	uxth	r2, r3
100417d0:	4b05      	ldr	r3, [pc, #20]	@ (100417e8 <ssd1306_SetCursor+0x30>)
100417d2:	801a      	strh	r2, [r3, #0]
    SSD1306.CurrentY = y;
100417d4:	1dbb      	adds	r3, r7, #6
100417d6:	781b      	ldrb	r3, [r3, #0]
100417d8:	b29a      	uxth	r2, r3
100417da:	4b03      	ldr	r3, [pc, #12]	@ (100417e8 <ssd1306_SetCursor+0x30>)
100417dc:	805a      	strh	r2, [r3, #2]
}
100417de:	46c0      	nop			@ (mov r8, r8)
100417e0:	46bd      	mov	sp, r7
100417e2:	b002      	add	sp, #8
100417e4:	bd80      	pop	{r7, pc}
100417e6:	46c0      	nop			@ (mov r8, r8)
100417e8:	2000032c 	.word	0x2000032c

100417ec <ssd1306_FillRectangle>:

    return;
}

/* Draw a filled rectangle */
void ssd1306_FillRectangle(uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2, SSD1306_COLOR color) {
100417ec:	b5b0      	push	{r4, r5, r7, lr}
100417ee:	b084      	sub	sp, #16
100417f0:	af00      	add	r7, sp, #0
100417f2:	0005      	movs	r5, r0
100417f4:	000c      	movs	r4, r1
100417f6:	0010      	movs	r0, r2
100417f8:	0019      	movs	r1, r3
100417fa:	1dfb      	adds	r3, r7, #7
100417fc:	1c2a      	adds	r2, r5, #0
100417fe:	701a      	strb	r2, [r3, #0]
10041800:	1dbb      	adds	r3, r7, #6
10041802:	1c22      	adds	r2, r4, #0
10041804:	701a      	strb	r2, [r3, #0]
10041806:	1d7b      	adds	r3, r7, #5
10041808:	1c02      	adds	r2, r0, #0
1004180a:	701a      	strb	r2, [r3, #0]
1004180c:	1d3b      	adds	r3, r7, #4
1004180e:	1c0a      	adds	r2, r1, #0
10041810:	701a      	strb	r2, [r3, #0]
    uint8_t x_start = ((x1<=x2) ? x1 : x2);
10041812:	230d      	movs	r3, #13
10041814:	18fa      	adds	r2, r7, r3
10041816:	1dfb      	adds	r3, r7, #7
10041818:	1d79      	adds	r1, r7, #5
1004181a:	780c      	ldrb	r4, [r1, #0]
1004181c:	781b      	ldrb	r3, [r3, #0]
1004181e:	b2d8      	uxtb	r0, r3
10041820:	b2e1      	uxtb	r1, r4
10041822:	4288      	cmp	r0, r1
10041824:	d900      	bls.n	10041828 <ssd1306_FillRectangle+0x3c>
10041826:	1c23      	adds	r3, r4, #0
10041828:	7013      	strb	r3, [r2, #0]
    uint8_t x_end   = ((x1<=x2) ? x2 : x1);
1004182a:	230c      	movs	r3, #12
1004182c:	18fa      	adds	r2, r7, r3
1004182e:	1d7b      	adds	r3, r7, #5
10041830:	1df9      	adds	r1, r7, #7
10041832:	780c      	ldrb	r4, [r1, #0]
10041834:	781b      	ldrb	r3, [r3, #0]
10041836:	b2d8      	uxtb	r0, r3
10041838:	b2e1      	uxtb	r1, r4
1004183a:	4288      	cmp	r0, r1
1004183c:	d200      	bcs.n	10041840 <ssd1306_FillRectangle+0x54>
1004183e:	1c23      	adds	r3, r4, #0
10041840:	7013      	strb	r3, [r2, #0]
    uint8_t y_start = ((y1<=y2) ? y1 : y2);
10041842:	230b      	movs	r3, #11
10041844:	18fa      	adds	r2, r7, r3
10041846:	1dbb      	adds	r3, r7, #6
10041848:	1d39      	adds	r1, r7, #4
1004184a:	780c      	ldrb	r4, [r1, #0]
1004184c:	781b      	ldrb	r3, [r3, #0]
1004184e:	b2d8      	uxtb	r0, r3
10041850:	b2e1      	uxtb	r1, r4
10041852:	4288      	cmp	r0, r1
10041854:	d900      	bls.n	10041858 <ssd1306_FillRectangle+0x6c>
10041856:	1c23      	adds	r3, r4, #0
10041858:	7013      	strb	r3, [r2, #0]
    uint8_t y_end   = ((y1<=y2) ? y2 : y1);
1004185a:	230a      	movs	r3, #10
1004185c:	18fa      	adds	r2, r7, r3
1004185e:	1d3b      	adds	r3, r7, #4
10041860:	1db9      	adds	r1, r7, #6
10041862:	780c      	ldrb	r4, [r1, #0]
10041864:	781b      	ldrb	r3, [r3, #0]
10041866:	b2d8      	uxtb	r0, r3
10041868:	b2e1      	uxtb	r1, r4
1004186a:	4288      	cmp	r0, r1
1004186c:	d200      	bcs.n	10041870 <ssd1306_FillRectangle+0x84>
1004186e:	1c23      	adds	r3, r4, #0
10041870:	7013      	strb	r3, [r2, #0]

    for (uint8_t y= y_start; (y<= y_end)&&(y<SSD1306_HEIGHT); y++) {
10041872:	230f      	movs	r3, #15
10041874:	18fb      	adds	r3, r7, r3
10041876:	220b      	movs	r2, #11
10041878:	18ba      	adds	r2, r7, r2
1004187a:	7812      	ldrb	r2, [r2, #0]
1004187c:	701a      	strb	r2, [r3, #0]
1004187e:	e02b      	b.n	100418d8 <ssd1306_FillRectangle+0xec>
        for (uint8_t x= x_start; (x<= x_end)&&(x<SSD1306_WIDTH); x++) {
10041880:	230e      	movs	r3, #14
10041882:	18fb      	adds	r3, r7, r3
10041884:	220d      	movs	r2, #13
10041886:	18ba      	adds	r2, r7, r2
10041888:	7812      	ldrb	r2, [r2, #0]
1004188a:	701a      	strb	r2, [r3, #0]
1004188c:	e011      	b.n	100418b2 <ssd1306_FillRectangle+0xc6>
            ssd1306_DrawPixel(x, y, color);
1004188e:	2320      	movs	r3, #32
10041890:	18fb      	adds	r3, r7, r3
10041892:	781a      	ldrb	r2, [r3, #0]
10041894:	230f      	movs	r3, #15
10041896:	18fb      	adds	r3, r7, r3
10041898:	7819      	ldrb	r1, [r3, #0]
1004189a:	240e      	movs	r4, #14
1004189c:	193b      	adds	r3, r7, r4
1004189e:	781b      	ldrb	r3, [r3, #0]
100418a0:	0018      	movs	r0, r3
100418a2:	f7ff fe51 	bl	10041548 <ssd1306_DrawPixel>
        for (uint8_t x= x_start; (x<= x_end)&&(x<SSD1306_WIDTH); x++) {
100418a6:	0021      	movs	r1, r4
100418a8:	187b      	adds	r3, r7, r1
100418aa:	781a      	ldrb	r2, [r3, #0]
100418ac:	187b      	adds	r3, r7, r1
100418ae:	3201      	adds	r2, #1
100418b0:	701a      	strb	r2, [r3, #0]
100418b2:	210e      	movs	r1, #14
100418b4:	187a      	adds	r2, r7, r1
100418b6:	230c      	movs	r3, #12
100418b8:	18fb      	adds	r3, r7, r3
100418ba:	7812      	ldrb	r2, [r2, #0]
100418bc:	781b      	ldrb	r3, [r3, #0]
100418be:	429a      	cmp	r2, r3
100418c0:	d804      	bhi.n	100418cc <ssd1306_FillRectangle+0xe0>
100418c2:	187b      	adds	r3, r7, r1
100418c4:	781b      	ldrb	r3, [r3, #0]
100418c6:	b25b      	sxtb	r3, r3
100418c8:	2b00      	cmp	r3, #0
100418ca:	dae0      	bge.n	1004188e <ssd1306_FillRectangle+0xa2>
    for (uint8_t y= y_start; (y<= y_end)&&(y<SSD1306_HEIGHT); y++) {
100418cc:	210f      	movs	r1, #15
100418ce:	187b      	adds	r3, r7, r1
100418d0:	781a      	ldrb	r2, [r3, #0]
100418d2:	187b      	adds	r3, r7, r1
100418d4:	3201      	adds	r2, #1
100418d6:	701a      	strb	r2, [r3, #0]
100418d8:	210f      	movs	r1, #15
100418da:	187a      	adds	r2, r7, r1
100418dc:	230a      	movs	r3, #10
100418de:	18fb      	adds	r3, r7, r3
100418e0:	7812      	ldrb	r2, [r2, #0]
100418e2:	781b      	ldrb	r3, [r3, #0]
100418e4:	429a      	cmp	r2, r3
100418e6:	d804      	bhi.n	100418f2 <ssd1306_FillRectangle+0x106>
100418e8:	187b      	adds	r3, r7, r1
100418ea:	781b      	ldrb	r3, [r3, #0]
100418ec:	2b1f      	cmp	r3, #31
100418ee:	d9c7      	bls.n	10041880 <ssd1306_FillRectangle+0x94>
        }
    }
    return;
100418f0:	46c0      	nop			@ (mov r8, r8)
100418f2:	46c0      	nop			@ (mov r8, r8)
}
100418f4:	46bd      	mov	sp, r7
100418f6:	b004      	add	sp, #16
100418f8:	bdb0      	pop	{r4, r5, r7, pc}

100418fa <ssd1306_SetContrast>:
        }
    }
    return;
}

void ssd1306_SetContrast(const uint8_t value) {
100418fa:	b580      	push	{r7, lr}
100418fc:	b084      	sub	sp, #16
100418fe:	af00      	add	r7, sp, #0
10041900:	0002      	movs	r2, r0
10041902:	1dfb      	adds	r3, r7, #7
10041904:	701a      	strb	r2, [r3, #0]
    const uint8_t kSetContrastControlRegister = 0x81;
10041906:	210f      	movs	r1, #15
10041908:	187b      	adds	r3, r7, r1
1004190a:	2281      	movs	r2, #129	@ 0x81
1004190c:	701a      	strb	r2, [r3, #0]
    ssd1306_WriteCommand(kSetContrastControlRegister);
1004190e:	187b      	adds	r3, r7, r1
10041910:	781b      	ldrb	r3, [r3, #0]
10041912:	0018      	movs	r0, r3
10041914:	f7ff fd30 	bl	10041378 <ssd1306_WriteCommand>
    ssd1306_WriteCommand(value);
10041918:	1dfb      	adds	r3, r7, #7
1004191a:	781b      	ldrb	r3, [r3, #0]
1004191c:	0018      	movs	r0, r3
1004191e:	f7ff fd2b 	bl	10041378 <ssd1306_WriteCommand>
}
10041922:	46c0      	nop			@ (mov r8, r8)
10041924:	46bd      	mov	sp, r7
10041926:	b004      	add	sp, #16
10041928:	bd80      	pop	{r7, pc}
	...

1004192c <ssd1306_SetDisplayOn>:

void ssd1306_SetDisplayOn(const uint8_t on) {
1004192c:	b580      	push	{r7, lr}
1004192e:	b084      	sub	sp, #16
10041930:	af00      	add	r7, sp, #0
10041932:	0002      	movs	r2, r0
10041934:	1dfb      	adds	r3, r7, #7
10041936:	701a      	strb	r2, [r3, #0]
    uint8_t value;
    if (on) {
10041938:	1dfb      	adds	r3, r7, #7
1004193a:	781b      	ldrb	r3, [r3, #0]
1004193c:	2b00      	cmp	r3, #0
1004193e:	d007      	beq.n	10041950 <ssd1306_SetDisplayOn+0x24>
        value = 0xAF;   // Display on
10041940:	230f      	movs	r3, #15
10041942:	18fb      	adds	r3, r7, r3
10041944:	22af      	movs	r2, #175	@ 0xaf
10041946:	701a      	strb	r2, [r3, #0]
        SSD1306.DisplayOn = 1;
10041948:	4b0a      	ldr	r3, [pc, #40]	@ (10041974 <ssd1306_SetDisplayOn+0x48>)
1004194a:	2201      	movs	r2, #1
1004194c:	715a      	strb	r2, [r3, #5]
1004194e:	e006      	b.n	1004195e <ssd1306_SetDisplayOn+0x32>
    } else {
        value = 0xAE;   // Display off
10041950:	230f      	movs	r3, #15
10041952:	18fb      	adds	r3, r7, r3
10041954:	22ae      	movs	r2, #174	@ 0xae
10041956:	701a      	strb	r2, [r3, #0]
        SSD1306.DisplayOn = 0;
10041958:	4b06      	ldr	r3, [pc, #24]	@ (10041974 <ssd1306_SetDisplayOn+0x48>)
1004195a:	2200      	movs	r2, #0
1004195c:	715a      	strb	r2, [r3, #5]
    }
    ssd1306_WriteCommand(value);
1004195e:	230f      	movs	r3, #15
10041960:	18fb      	adds	r3, r7, r3
10041962:	781b      	ldrb	r3, [r3, #0]
10041964:	0018      	movs	r0, r3
10041966:	f7ff fd07 	bl	10041378 <ssd1306_WriteCommand>
}
1004196a:	46c0      	nop			@ (mov r8, r8)
1004196c:	46bd      	mov	sp, r7
1004196e:	b004      	add	sp, #16
10041970:	bd80      	pop	{r7, pc}
10041972:	46c0      	nop			@ (mov r8, r8)
10041974:	2000032c 	.word	0x2000032c

10041978 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
10041978:	b580      	push	{r7, lr}
1004197a:	b082      	sub	sp, #8
1004197c:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef  status = HAL_OK;
1004197e:	1dfb      	adds	r3, r7, #7
10041980:	2200      	movs	r2, #0
10041982:	701a      	strb	r2, [r3, #0]

  /* Use SysTick as time base source and configure 1ms tick (default clock after Reset is MSI) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
10041984:	2003      	movs	r0, #3
10041986:	f000 f80f 	bl	100419a8 <HAL_InitTick>
1004198a:	1e03      	subs	r3, r0, #0
1004198c:	d003      	beq.n	10041996 <HAL_Init+0x1e>
  {
    status = HAL_ERROR;
1004198e:	1dfb      	adds	r3, r7, #7
10041990:	2201      	movs	r2, #1
10041992:	701a      	strb	r2, [r3, #0]
10041994:	e001      	b.n	1004199a <HAL_Init+0x22>
  }
  else
  {
    /* Init the low level hardware */
    HAL_MspInit();
10041996:	f7ff f883 	bl	10040aa0 <HAL_MspInit>
  }

  /* Return function status */
  return status;
1004199a:	1dfb      	adds	r3, r7, #7
1004199c:	781b      	ldrb	r3, [r3, #0]
}
1004199e:	0018      	movs	r0, r3
100419a0:	46bd      	mov	sp, r7
100419a2:	b002      	add	sp, #8
100419a4:	bd80      	pop	{r7, pc}
	...

100419a8 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
100419a8:	b590      	push	{r4, r7, lr}
100419aa:	b085      	sub	sp, #20
100419ac:	af00      	add	r7, sp, #0
100419ae:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef  status = HAL_OK;
100419b0:	230f      	movs	r3, #15
100419b2:	18fb      	adds	r3, r7, r3
100419b4:	2200      	movs	r2, #0
100419b6:	701a      	strb	r2, [r3, #0]

  if (uwTickFreq != 0U)
100419b8:	4b1d      	ldr	r3, [pc, #116]	@ (10041a30 <HAL_InitTick+0x88>)
100419ba:	781b      	ldrb	r3, [r3, #0]
100419bc:	2b00      	cmp	r3, #0
100419be:	d02c      	beq.n	10041a1a <HAL_InitTick+0x72>
  {
    /*Configure the SysTick to have interrupt in 1ms time basis*/
    if (HAL_SYSTICK_Config(HAL_RCC_GetSysClockFreq() / (1000U / uwTickFreq)) == 0U)
100419c0:	f001 fcd4 	bl	1004336c <HAL_RCC_GetSysClockFreq>
100419c4:	0004      	movs	r4, r0
100419c6:	4b1a      	ldr	r3, [pc, #104]	@ (10041a30 <HAL_InitTick+0x88>)
100419c8:	781b      	ldrb	r3, [r3, #0]
100419ca:	0019      	movs	r1, r3
100419cc:	23fa      	movs	r3, #250	@ 0xfa
100419ce:	0098      	lsls	r0, r3, #2
100419d0:	f7fe fb76 	bl	100400c0 <__udivsi3>
100419d4:	0003      	movs	r3, r0
100419d6:	0019      	movs	r1, r3
100419d8:	0020      	movs	r0, r4
100419da:	f7fe fb71 	bl	100400c0 <__udivsi3>
100419de:	0003      	movs	r3, r0
100419e0:	0018      	movs	r0, r3
100419e2:	f000 f944 	bl	10041c6e <HAL_SYSTICK_Config>
100419e6:	1e03      	subs	r3, r0, #0
100419e8:	d112      	bne.n	10041a10 <HAL_InitTick+0x68>
    {
      /* Configure the SysTick IRQ priority */
      if (TickPriority < (1UL << __NVIC_PRIO_BITS))
100419ea:	687b      	ldr	r3, [r7, #4]
100419ec:	2b03      	cmp	r3, #3
100419ee:	d80a      	bhi.n	10041a06 <HAL_InitTick+0x5e>
      {
        HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0);
100419f0:	6879      	ldr	r1, [r7, #4]
100419f2:	2301      	movs	r3, #1
100419f4:	425b      	negs	r3, r3
100419f6:	2200      	movs	r2, #0
100419f8:	0018      	movs	r0, r3
100419fa:	f000 f913 	bl	10041c24 <HAL_NVIC_SetPriority>
        uwTickPrio = TickPriority;
100419fe:	4b0d      	ldr	r3, [pc, #52]	@ (10041a34 <HAL_InitTick+0x8c>)
10041a00:	687a      	ldr	r2, [r7, #4]
10041a02:	601a      	str	r2, [r3, #0]
10041a04:	e00d      	b.n	10041a22 <HAL_InitTick+0x7a>
      }
      else
      {
        status = HAL_ERROR;
10041a06:	230f      	movs	r3, #15
10041a08:	18fb      	adds	r3, r7, r3
10041a0a:	2201      	movs	r2, #1
10041a0c:	701a      	strb	r2, [r3, #0]
10041a0e:	e008      	b.n	10041a22 <HAL_InitTick+0x7a>
      }
    }
    else
    {
      status = HAL_ERROR;
10041a10:	230f      	movs	r3, #15
10041a12:	18fb      	adds	r3, r7, r3
10041a14:	2201      	movs	r2, #1
10041a16:	701a      	strb	r2, [r3, #0]
10041a18:	e003      	b.n	10041a22 <HAL_InitTick+0x7a>
    }
  }
  else
  {
    status = HAL_ERROR;
10041a1a:	230f      	movs	r3, #15
10041a1c:	18fb      	adds	r3, r7, r3
10041a1e:	2201      	movs	r2, #1
10041a20:	701a      	strb	r2, [r3, #0]
  }

  /* Return function status */
  return status;
10041a22:	230f      	movs	r3, #15
10041a24:	18fb      	adds	r3, r7, r3
10041a26:	781b      	ldrb	r3, [r3, #0]
}
10041a28:	0018      	movs	r0, r3
10041a2a:	46bd      	mov	sp, r7
10041a2c:	b005      	add	sp, #20
10041a2e:	bd90      	pop	{r4, r7, pc}
10041a30:	20000370 	.word	0x20000370
10041a34:	2000036c 	.word	0x2000036c

10041a38 <HAL_IncTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
10041a38:	b580      	push	{r7, lr}
10041a3a:	af00      	add	r7, sp, #0
  uwTick += (uint32_t)uwTickFreq;
10041a3c:	4b05      	ldr	r3, [pc, #20]	@ (10041a54 <HAL_IncTick+0x1c>)
10041a3e:	781b      	ldrb	r3, [r3, #0]
10041a40:	001a      	movs	r2, r3
10041a42:	4b05      	ldr	r3, [pc, #20]	@ (10041a58 <HAL_IncTick+0x20>)
10041a44:	681b      	ldr	r3, [r3, #0]
10041a46:	18d2      	adds	r2, r2, r3
10041a48:	4b03      	ldr	r3, [pc, #12]	@ (10041a58 <HAL_IncTick+0x20>)
10041a4a:	601a      	str	r2, [r3, #0]
}
10041a4c:	46c0      	nop			@ (mov r8, r8)
10041a4e:	46bd      	mov	sp, r7
10041a50:	bd80      	pop	{r7, pc}
10041a52:	46c0      	nop			@ (mov r8, r8)
10041a54:	20000370 	.word	0x20000370
10041a58:	20000334 	.word	0x20000334

10041a5c <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
10041a5c:	b580      	push	{r7, lr}
10041a5e:	af00      	add	r7, sp, #0
  return uwTick;
10041a60:	4b02      	ldr	r3, [pc, #8]	@ (10041a6c <HAL_GetTick+0x10>)
10041a62:	681b      	ldr	r3, [r3, #0]
}
10041a64:	0018      	movs	r0, r3
10041a66:	46bd      	mov	sp, r7
10041a68:	bd80      	pop	{r7, pc}
10041a6a:	46c0      	nop			@ (mov r8, r8)
10041a6c:	20000334 	.word	0x20000334

10041a70 <HAL_GetTickPrio>:
/**
  * @brief This function returns a tick priority.
  * @retval tick priority
  */
uint32_t HAL_GetTickPrio(void)
{
10041a70:	b580      	push	{r7, lr}
10041a72:	af00      	add	r7, sp, #0
  return uwTickPrio;
10041a74:	4b02      	ldr	r3, [pc, #8]	@ (10041a80 <HAL_GetTickPrio+0x10>)
10041a76:	681b      	ldr	r3, [r3, #0]
}
10041a78:	0018      	movs	r0, r3
10041a7a:	46bd      	mov	sp, r7
10041a7c:	bd80      	pop	{r7, pc}
10041a7e:	46c0      	nop			@ (mov r8, r8)
10041a80:	2000036c 	.word	0x2000036c

10041a84 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
10041a84:	b580      	push	{r7, lr}
10041a86:	b084      	sub	sp, #16
10041a88:	af00      	add	r7, sp, #0
10041a8a:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
10041a8c:	f7ff ffe6 	bl	10041a5c <HAL_GetTick>
10041a90:	0003      	movs	r3, r0
10041a92:	60bb      	str	r3, [r7, #8]
  uint32_t wait = Delay;
10041a94:	687b      	ldr	r3, [r7, #4]
10041a96:	60fb      	str	r3, [r7, #12]

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
10041a98:	68fb      	ldr	r3, [r7, #12]
10041a9a:	3301      	adds	r3, #1
10041a9c:	d005      	beq.n	10041aaa <HAL_Delay+0x26>
  {
    wait += (uint32_t)(uwTickFreq);
10041a9e:	4b0a      	ldr	r3, [pc, #40]	@ (10041ac8 <HAL_Delay+0x44>)
10041aa0:	781b      	ldrb	r3, [r3, #0]
10041aa2:	001a      	movs	r2, r3
10041aa4:	68fb      	ldr	r3, [r7, #12]
10041aa6:	189b      	adds	r3, r3, r2
10041aa8:	60fb      	str	r3, [r7, #12]
  }

  while ((HAL_GetTick() - tickstart) < wait)
10041aaa:	46c0      	nop			@ (mov r8, r8)
10041aac:	f7ff ffd6 	bl	10041a5c <HAL_GetTick>
10041ab0:	0002      	movs	r2, r0
10041ab2:	68bb      	ldr	r3, [r7, #8]
10041ab4:	1ad3      	subs	r3, r2, r3
10041ab6:	68fa      	ldr	r2, [r7, #12]
10041ab8:	429a      	cmp	r2, r3
10041aba:	d8f7      	bhi.n	10041aac <HAL_Delay+0x28>
  {
  }
}
10041abc:	46c0      	nop			@ (mov r8, r8)
10041abe:	46c0      	nop			@ (mov r8, r8)
10041ac0:	46bd      	mov	sp, r7
10041ac2:	b004      	add	sp, #16
10041ac4:	bd80      	pop	{r7, pc}
10041ac6:	46c0      	nop			@ (mov r8, r8)
10041ac8:	20000370 	.word	0x20000370

10041acc <__NVIC_EnableIRQ>:
{
10041acc:	b580      	push	{r7, lr}
10041ace:	b082      	sub	sp, #8
10041ad0:	af00      	add	r7, sp, #0
10041ad2:	0002      	movs	r2, r0
10041ad4:	1dfb      	adds	r3, r7, #7
10041ad6:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
10041ad8:	1dfb      	adds	r3, r7, #7
10041ada:	781b      	ldrb	r3, [r3, #0]
10041adc:	2b7f      	cmp	r3, #127	@ 0x7f
10041ade:	d809      	bhi.n	10041af4 <__NVIC_EnableIRQ+0x28>
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
10041ae0:	1dfb      	adds	r3, r7, #7
10041ae2:	781b      	ldrb	r3, [r3, #0]
10041ae4:	001a      	movs	r2, r3
10041ae6:	231f      	movs	r3, #31
10041ae8:	401a      	ands	r2, r3
10041aea:	4b04      	ldr	r3, [pc, #16]	@ (10041afc <__NVIC_EnableIRQ+0x30>)
10041aec:	2101      	movs	r1, #1
10041aee:	4091      	lsls	r1, r2
10041af0:	000a      	movs	r2, r1
10041af2:	601a      	str	r2, [r3, #0]
}
10041af4:	46c0      	nop			@ (mov r8, r8)
10041af6:	46bd      	mov	sp, r7
10041af8:	b002      	add	sp, #8
10041afa:	bd80      	pop	{r7, pc}
10041afc:	e000e100 	.word	0xe000e100

10041b00 <__NVIC_SetPriority>:
{
10041b00:	b590      	push	{r4, r7, lr}
10041b02:	b083      	sub	sp, #12
10041b04:	af00      	add	r7, sp, #0
10041b06:	0002      	movs	r2, r0
10041b08:	6039      	str	r1, [r7, #0]
10041b0a:	1dfb      	adds	r3, r7, #7
10041b0c:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
10041b0e:	1dfb      	adds	r3, r7, #7
10041b10:	781b      	ldrb	r3, [r3, #0]
10041b12:	2b7f      	cmp	r3, #127	@ 0x7f
10041b14:	d828      	bhi.n	10041b68 <__NVIC_SetPriority+0x68>
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
10041b16:	4a2f      	ldr	r2, [pc, #188]	@ (10041bd4 <__NVIC_SetPriority+0xd4>)
10041b18:	1dfb      	adds	r3, r7, #7
10041b1a:	781b      	ldrb	r3, [r3, #0]
10041b1c:	b25b      	sxtb	r3, r3
10041b1e:	089b      	lsrs	r3, r3, #2
10041b20:	33c0      	adds	r3, #192	@ 0xc0
10041b22:	009b      	lsls	r3, r3, #2
10041b24:	589b      	ldr	r3, [r3, r2]
10041b26:	1dfa      	adds	r2, r7, #7
10041b28:	7812      	ldrb	r2, [r2, #0]
10041b2a:	0011      	movs	r1, r2
10041b2c:	2203      	movs	r2, #3
10041b2e:	400a      	ands	r2, r1
10041b30:	00d2      	lsls	r2, r2, #3
10041b32:	21ff      	movs	r1, #255	@ 0xff
10041b34:	4091      	lsls	r1, r2
10041b36:	000a      	movs	r2, r1
10041b38:	43d2      	mvns	r2, r2
10041b3a:	401a      	ands	r2, r3
10041b3c:	0011      	movs	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
10041b3e:	683b      	ldr	r3, [r7, #0]
10041b40:	019b      	lsls	r3, r3, #6
10041b42:	22ff      	movs	r2, #255	@ 0xff
10041b44:	401a      	ands	r2, r3
10041b46:	1dfb      	adds	r3, r7, #7
10041b48:	781b      	ldrb	r3, [r3, #0]
10041b4a:	0018      	movs	r0, r3
10041b4c:	2303      	movs	r3, #3
10041b4e:	4003      	ands	r3, r0
10041b50:	00db      	lsls	r3, r3, #3
10041b52:	409a      	lsls	r2, r3
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
10041b54:	481f      	ldr	r0, [pc, #124]	@ (10041bd4 <__NVIC_SetPriority+0xd4>)
10041b56:	1dfb      	adds	r3, r7, #7
10041b58:	781b      	ldrb	r3, [r3, #0]
10041b5a:	b25b      	sxtb	r3, r3
10041b5c:	089b      	lsrs	r3, r3, #2
10041b5e:	430a      	orrs	r2, r1
10041b60:	33c0      	adds	r3, #192	@ 0xc0
10041b62:	009b      	lsls	r3, r3, #2
10041b64:	501a      	str	r2, [r3, r0]
}
10041b66:	e031      	b.n	10041bcc <__NVIC_SetPriority+0xcc>
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
10041b68:	4a1b      	ldr	r2, [pc, #108]	@ (10041bd8 <__NVIC_SetPriority+0xd8>)
10041b6a:	1dfb      	adds	r3, r7, #7
10041b6c:	781b      	ldrb	r3, [r3, #0]
10041b6e:	0019      	movs	r1, r3
10041b70:	230f      	movs	r3, #15
10041b72:	400b      	ands	r3, r1
10041b74:	3b08      	subs	r3, #8
10041b76:	089b      	lsrs	r3, r3, #2
10041b78:	3306      	adds	r3, #6
10041b7a:	009b      	lsls	r3, r3, #2
10041b7c:	18d3      	adds	r3, r2, r3
10041b7e:	3304      	adds	r3, #4
10041b80:	681b      	ldr	r3, [r3, #0]
10041b82:	1dfa      	adds	r2, r7, #7
10041b84:	7812      	ldrb	r2, [r2, #0]
10041b86:	0011      	movs	r1, r2
10041b88:	2203      	movs	r2, #3
10041b8a:	400a      	ands	r2, r1
10041b8c:	00d2      	lsls	r2, r2, #3
10041b8e:	21ff      	movs	r1, #255	@ 0xff
10041b90:	4091      	lsls	r1, r2
10041b92:	000a      	movs	r2, r1
10041b94:	43d2      	mvns	r2, r2
10041b96:	401a      	ands	r2, r3
10041b98:	0011      	movs	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
10041b9a:	683b      	ldr	r3, [r7, #0]
10041b9c:	019b      	lsls	r3, r3, #6
10041b9e:	22ff      	movs	r2, #255	@ 0xff
10041ba0:	401a      	ands	r2, r3
10041ba2:	1dfb      	adds	r3, r7, #7
10041ba4:	781b      	ldrb	r3, [r3, #0]
10041ba6:	0018      	movs	r0, r3
10041ba8:	2303      	movs	r3, #3
10041baa:	4003      	ands	r3, r0
10041bac:	00db      	lsls	r3, r3, #3
10041bae:	409a      	lsls	r2, r3
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
10041bb0:	4809      	ldr	r0, [pc, #36]	@ (10041bd8 <__NVIC_SetPriority+0xd8>)
10041bb2:	1dfb      	adds	r3, r7, #7
10041bb4:	781b      	ldrb	r3, [r3, #0]
10041bb6:	001c      	movs	r4, r3
10041bb8:	230f      	movs	r3, #15
10041bba:	4023      	ands	r3, r4
10041bbc:	3b08      	subs	r3, #8
10041bbe:	089b      	lsrs	r3, r3, #2
10041bc0:	430a      	orrs	r2, r1
10041bc2:	3306      	adds	r3, #6
10041bc4:	009b      	lsls	r3, r3, #2
10041bc6:	18c3      	adds	r3, r0, r3
10041bc8:	3304      	adds	r3, #4
10041bca:	601a      	str	r2, [r3, #0]
}
10041bcc:	46c0      	nop			@ (mov r8, r8)
10041bce:	46bd      	mov	sp, r7
10041bd0:	b003      	add	sp, #12
10041bd2:	bd90      	pop	{r4, r7, pc}
10041bd4:	e000e100 	.word	0xe000e100
10041bd8:	e000ed00 	.word	0xe000ed00

10041bdc <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
10041bdc:	b580      	push	{r7, lr}
10041bde:	b082      	sub	sp, #8
10041be0:	af00      	add	r7, sp, #0
10041be2:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
10041be4:	687b      	ldr	r3, [r7, #4]
10041be6:	1e5a      	subs	r2, r3, #1
10041be8:	2380      	movs	r3, #128	@ 0x80
10041bea:	045b      	lsls	r3, r3, #17
10041bec:	429a      	cmp	r2, r3
10041bee:	d301      	bcc.n	10041bf4 <SysTick_Config+0x18>
  {
    return (1UL);                                                   /* Reload value impossible */
10041bf0:	2301      	movs	r3, #1
10041bf2:	e010      	b.n	10041c16 <SysTick_Config+0x3a>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
10041bf4:	4b0a      	ldr	r3, [pc, #40]	@ (10041c20 <SysTick_Config+0x44>)
10041bf6:	687a      	ldr	r2, [r7, #4]
10041bf8:	3a01      	subs	r2, #1
10041bfa:	605a      	str	r2, [r3, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
10041bfc:	2301      	movs	r3, #1
10041bfe:	425b      	negs	r3, r3
10041c00:	2103      	movs	r1, #3
10041c02:	0018      	movs	r0, r3
10041c04:	f7ff ff7c 	bl	10041b00 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
10041c08:	4b05      	ldr	r3, [pc, #20]	@ (10041c20 <SysTick_Config+0x44>)
10041c0a:	2200      	movs	r2, #0
10041c0c:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
10041c0e:	4b04      	ldr	r3, [pc, #16]	@ (10041c20 <SysTick_Config+0x44>)
10041c10:	2207      	movs	r2, #7
10041c12:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
10041c14:	2300      	movs	r3, #0
}
10041c16:	0018      	movs	r0, r3
10041c18:	46bd      	mov	sp, r7
10041c1a:	b002      	add	sp, #8
10041c1c:	bd80      	pop	{r7, pc}
10041c1e:	46c0      	nop			@ (mov r8, r8)
10041c20:	e000e010 	.word	0xe000e010

10041c24 <HAL_NVIC_SetPriority>:
  *         with stm32wl3x devices, this parameter is a dummy value and it is ignored, because
  *         no subpriority supported in Cortex M0+ based products.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
10041c24:	b580      	push	{r7, lr}
10041c26:	b084      	sub	sp, #16
10041c28:	af00      	add	r7, sp, #0
10041c2a:	60b9      	str	r1, [r7, #8]
10041c2c:	607a      	str	r2, [r7, #4]
10041c2e:	210f      	movs	r1, #15
10041c30:	187b      	adds	r3, r7, r1
10041c32:	1c02      	adds	r2, r0, #0
10041c34:	701a      	strb	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  NVIC_SetPriority(IRQn, PreemptPriority);
10041c36:	68ba      	ldr	r2, [r7, #8]
10041c38:	187b      	adds	r3, r7, r1
10041c3a:	781b      	ldrb	r3, [r3, #0]
10041c3c:	b25b      	sxtb	r3, r3
10041c3e:	0011      	movs	r1, r2
10041c40:	0018      	movs	r0, r3
10041c42:	f7ff ff5d 	bl	10041b00 <__NVIC_SetPriority>
}
10041c46:	46c0      	nop			@ (mov r8, r8)
10041c48:	46bd      	mov	sp, r7
10041c4a:	b004      	add	sp, #16
10041c4c:	bd80      	pop	{r7, pc}

10041c4e <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file)
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
10041c4e:	b580      	push	{r7, lr}
10041c50:	b082      	sub	sp, #8
10041c52:	af00      	add	r7, sp, #0
10041c54:	0002      	movs	r2, r0
10041c56:	1dfb      	adds	r3, r7, #7
10041c58:	701a      	strb	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
10041c5a:	1dfb      	adds	r3, r7, #7
10041c5c:	781b      	ldrb	r3, [r3, #0]
10041c5e:	b25b      	sxtb	r3, r3
10041c60:	0018      	movs	r0, r3
10041c62:	f7ff ff33 	bl	10041acc <__NVIC_EnableIRQ>
}
10041c66:	46c0      	nop			@ (mov r8, r8)
10041c68:	46bd      	mov	sp, r7
10041c6a:	b002      	add	sp, #8
10041c6c:	bd80      	pop	{r7, pc}

10041c6e <HAL_SYSTICK_Config>:
  * @param TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
10041c6e:	b580      	push	{r7, lr}
10041c70:	b082      	sub	sp, #8
10041c72:	af00      	add	r7, sp, #0
10041c74:	6078      	str	r0, [r7, #4]
  return SysTick_Config(TicksNumb);
10041c76:	687b      	ldr	r3, [r7, #4]
10041c78:	0018      	movs	r0, r3
10041c7a:	f7ff ffaf 	bl	10041bdc <SysTick_Config>
10041c7e:	0003      	movs	r3, r0
}
10041c80:	0018      	movs	r0, r3
10041c82:	46bd      	mov	sp, r7
10041c84:	b002      	add	sp, #8
10041c86:	bd80      	pop	{r7, pc}

10041c88 <HAL_GPIO_Init>:
  * @param GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
10041c88:	b580      	push	{r7, lr}
10041c8a:	b086      	sub	sp, #24
10041c8c:	af00      	add	r7, sp, #0
10041c8e:	6078      	str	r0, [r7, #4]
10041c90:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00u;
10041c92:	2300      	movs	r3, #0
10041c94:	617b      	str	r3, [r7, #20]
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00u)
10041c96:	e1a0      	b.n	10041fda <HAL_GPIO_Init+0x352>
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1uL << position);
10041c98:	683b      	ldr	r3, [r7, #0]
10041c9a:	681b      	ldr	r3, [r3, #0]
10041c9c:	2101      	movs	r1, #1
10041c9e:	697a      	ldr	r2, [r7, #20]
10041ca0:	4091      	lsls	r1, r2
10041ca2:	000a      	movs	r2, r1
10041ca4:	4013      	ands	r3, r2
10041ca6:	60fb      	str	r3, [r7, #12]

    if (iocurrent != 0x00u)
10041ca8:	68fb      	ldr	r3, [r7, #12]
10041caa:	2b00      	cmp	r3, #0
10041cac:	d100      	bne.n	10041cb0 <HAL_GPIO_Init+0x28>
10041cae:	e191      	b.n	10041fd4 <HAL_GPIO_Init+0x34c>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
10041cb0:	683b      	ldr	r3, [r7, #0]
10041cb2:	685b      	ldr	r3, [r3, #4]
10041cb4:	2203      	movs	r2, #3
10041cb6:	4013      	ands	r3, r2
10041cb8:	2b01      	cmp	r3, #1
10041cba:	d005      	beq.n	10041cc8 <HAL_GPIO_Init+0x40>
10041cbc:	683b      	ldr	r3, [r7, #0]
10041cbe:	685b      	ldr	r3, [r3, #4]
10041cc0:	2203      	movs	r2, #3
10041cc2:	4013      	ands	r3, r2
10041cc4:	2b02      	cmp	r3, #2
10041cc6:	d130      	bne.n	10041d2a <HAL_GPIO_Init+0xa2>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
10041cc8:	687b      	ldr	r3, [r7, #4]
10041cca:	689b      	ldr	r3, [r3, #8]
10041ccc:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2u));
10041cce:	697b      	ldr	r3, [r7, #20]
10041cd0:	005b      	lsls	r3, r3, #1
10041cd2:	2203      	movs	r2, #3
10041cd4:	409a      	lsls	r2, r3
10041cd6:	0013      	movs	r3, r2
10041cd8:	43da      	mvns	r2, r3
10041cda:	693b      	ldr	r3, [r7, #16]
10041cdc:	4013      	ands	r3, r2
10041cde:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_Init->Speed << (position * 2u));
10041ce0:	683b      	ldr	r3, [r7, #0]
10041ce2:	68da      	ldr	r2, [r3, #12]
10041ce4:	697b      	ldr	r3, [r7, #20]
10041ce6:	005b      	lsls	r3, r3, #1
10041ce8:	409a      	lsls	r2, r3
10041cea:	0013      	movs	r3, r2
10041cec:	693a      	ldr	r2, [r7, #16]
10041cee:	4313      	orrs	r3, r2
10041cf0:	613b      	str	r3, [r7, #16]
        GPIOx->OSPEEDR = temp;
10041cf2:	687b      	ldr	r3, [r7, #4]
10041cf4:	693a      	ldr	r2, [r7, #16]
10041cf6:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
10041cf8:	687b      	ldr	r3, [r7, #4]
10041cfa:	685b      	ldr	r3, [r3, #4]
10041cfc:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
10041cfe:	2201      	movs	r2, #1
10041d00:	697b      	ldr	r3, [r7, #20]
10041d02:	409a      	lsls	r2, r3
10041d04:	0013      	movs	r3, r2
10041d06:	43da      	mvns	r2, r3
10041d08:	693b      	ldr	r3, [r7, #16]
10041d0a:	4013      	ands	r3, r2
10041d0c:	613b      	str	r3, [r7, #16]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
10041d0e:	683b      	ldr	r3, [r7, #0]
10041d10:	685b      	ldr	r3, [r3, #4]
10041d12:	091b      	lsrs	r3, r3, #4
10041d14:	2201      	movs	r2, #1
10041d16:	401a      	ands	r2, r3
10041d18:	697b      	ldr	r3, [r7, #20]
10041d1a:	409a      	lsls	r2, r3
10041d1c:	0013      	movs	r3, r2
10041d1e:	693a      	ldr	r2, [r7, #16]
10041d20:	4313      	orrs	r3, r2
10041d22:	613b      	str	r3, [r7, #16]
        GPIOx->OTYPER = temp;
10041d24:	687b      	ldr	r3, [r7, #4]
10041d26:	693a      	ldr	r2, [r7, #16]
10041d28:	605a      	str	r2, [r3, #4]
      }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      if ((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
10041d2a:	683b      	ldr	r3, [r7, #0]
10041d2c:	685b      	ldr	r3, [r3, #4]
10041d2e:	2203      	movs	r2, #3
10041d30:	4013      	ands	r3, r2
10041d32:	2b03      	cmp	r3, #3
10041d34:	d018      	beq.n	10041d68 <HAL_GPIO_Init+0xe0>
      {
        temp = GPIOx->PUPDR;
10041d36:	687b      	ldr	r3, [r7, #4]
10041d38:	68db      	ldr	r3, [r3, #12]
10041d3a:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
10041d3c:	697b      	ldr	r3, [r7, #20]
10041d3e:	005b      	lsls	r3, r3, #1
10041d40:	2203      	movs	r2, #3
10041d42:	409a      	lsls	r2, r3
10041d44:	0013      	movs	r3, r2
10041d46:	43da      	mvns	r2, r3
10041d48:	693b      	ldr	r3, [r7, #16]
10041d4a:	4013      	ands	r3, r2
10041d4c:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Pull) << (position * 2U));
10041d4e:	683b      	ldr	r3, [r7, #0]
10041d50:	689a      	ldr	r2, [r3, #8]
10041d52:	697b      	ldr	r3, [r7, #20]
10041d54:	005b      	lsls	r3, r3, #1
10041d56:	409a      	lsls	r2, r3
10041d58:	0013      	movs	r3, r2
10041d5a:	693a      	ldr	r2, [r7, #16]
10041d5c:	4313      	orrs	r3, r2
10041d5e:	613b      	str	r3, [r7, #16]
        GPIOx->PUPDR = temp;
10041d60:	687b      	ldr	r3, [r7, #4]
10041d62:	693a      	ldr	r2, [r7, #16]
10041d64:	60da      	str	r2, [r3, #12]
10041d66:	e00e      	b.n	10041d86 <HAL_GPIO_Init+0xfe>
      }
      else
      {
        temp = GPIOx->PUPDR;
10041d68:	687b      	ldr	r3, [r7, #4]
10041d6a:	68db      	ldr	r3, [r3, #12]
10041d6c:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
10041d6e:	697b      	ldr	r3, [r7, #20]
10041d70:	005b      	lsls	r3, r3, #1
10041d72:	2203      	movs	r2, #3
10041d74:	409a      	lsls	r2, r3
10041d76:	0013      	movs	r3, r2
10041d78:	43da      	mvns	r2, r3
10041d7a:	693b      	ldr	r3, [r7, #16]
10041d7c:	4013      	ands	r3, r2
10041d7e:	613b      	str	r3, [r7, #16]
        GPIOx->PUPDR = temp;
10041d80:	687b      	ldr	r3, [r7, #4]
10041d82:	693a      	ldr	r2, [r7, #16]
10041d84:	60da      	str	r2, [r3, #12]
      }

      /* In case of Alternate function mode selection */
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
10041d86:	683b      	ldr	r3, [r7, #0]
10041d88:	685b      	ldr	r3, [r3, #4]
10041d8a:	2203      	movs	r2, #3
10041d8c:	4013      	ands	r3, r2
10041d8e:	2b02      	cmp	r3, #2
10041d90:	d123      	bne.n	10041dda <HAL_GPIO_Init+0x152>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3u];
10041d92:	697b      	ldr	r3, [r7, #20]
10041d94:	08da      	lsrs	r2, r3, #3
10041d96:	687b      	ldr	r3, [r7, #4]
10041d98:	3208      	adds	r2, #8
10041d9a:	0092      	lsls	r2, r2, #2
10041d9c:	58d3      	ldr	r3, [r2, r3]
10041d9e:	613b      	str	r3, [r7, #16]
        temp &= ~(0xFu << ((position & 0x07u) * 4u));
10041da0:	697b      	ldr	r3, [r7, #20]
10041da2:	2207      	movs	r2, #7
10041da4:	4013      	ands	r3, r2
10041da6:	009b      	lsls	r3, r3, #2
10041da8:	220f      	movs	r2, #15
10041daa:	409a      	lsls	r2, r3
10041dac:	0013      	movs	r3, r2
10041dae:	43da      	mvns	r2, r3
10041db0:	693b      	ldr	r3, [r7, #16]
10041db2:	4013      	ands	r3, r2
10041db4:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07u) * 4u));
10041db6:	683b      	ldr	r3, [r7, #0]
10041db8:	691a      	ldr	r2, [r3, #16]
10041dba:	697b      	ldr	r3, [r7, #20]
10041dbc:	2107      	movs	r1, #7
10041dbe:	400b      	ands	r3, r1
10041dc0:	009b      	lsls	r3, r3, #2
10041dc2:	409a      	lsls	r2, r3
10041dc4:	0013      	movs	r3, r2
10041dc6:	693a      	ldr	r2, [r7, #16]
10041dc8:	4313      	orrs	r3, r2
10041dca:	613b      	str	r3, [r7, #16]
        GPIOx->AFR[position >> 3u] = temp;
10041dcc:	697b      	ldr	r3, [r7, #20]
10041dce:	08da      	lsrs	r2, r3, #3
10041dd0:	687b      	ldr	r3, [r7, #4]
10041dd2:	3208      	adds	r2, #8
10041dd4:	0092      	lsls	r2, r2, #2
10041dd6:	6939      	ldr	r1, [r7, #16]
10041dd8:	50d1      	str	r1, [r2, r3]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
10041dda:	687b      	ldr	r3, [r7, #4]
10041ddc:	681b      	ldr	r3, [r3, #0]
10041dde:	613b      	str	r3, [r7, #16]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2u));
10041de0:	697b      	ldr	r3, [r7, #20]
10041de2:	005b      	lsls	r3, r3, #1
10041de4:	2203      	movs	r2, #3
10041de6:	409a      	lsls	r2, r3
10041de8:	0013      	movs	r3, r2
10041dea:	43da      	mvns	r2, r3
10041dec:	693b      	ldr	r3, [r7, #16]
10041dee:	4013      	ands	r3, r2
10041df0:	613b      	str	r3, [r7, #16]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2u));
10041df2:	683b      	ldr	r3, [r7, #0]
10041df4:	685b      	ldr	r3, [r3, #4]
10041df6:	2203      	movs	r2, #3
10041df8:	401a      	ands	r2, r3
10041dfa:	697b      	ldr	r3, [r7, #20]
10041dfc:	005b      	lsls	r3, r3, #1
10041dfe:	409a      	lsls	r2, r3
10041e00:	0013      	movs	r3, r2
10041e02:	693a      	ldr	r2, [r7, #16]
10041e04:	4313      	orrs	r3, r2
10041e06:	613b      	str	r3, [r7, #16]
      GPIOx->MODER = temp;
10041e08:	687b      	ldr	r3, [r7, #4]
10041e0a:	693a      	ldr	r2, [r7, #16]
10041e0c:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
10041e0e:	683b      	ldr	r3, [r7, #0]
10041e10:	685a      	ldr	r2, [r3, #4]
10041e12:	23c0      	movs	r3, #192	@ 0xc0
10041e14:	029b      	lsls	r3, r3, #10
10041e16:	4013      	ands	r3, r2
10041e18:	d100      	bne.n	10041e1c <HAL_GPIO_Init+0x194>
10041e1a:	e0db      	b.n	10041fd4 <HAL_GPIO_Init+0x34c>
      {

        /* Edge/Level line configuration */
        if ((GPIO_Init->Mode & DETECTION_TYPE) != 0x00u)
10041e1c:	683b      	ldr	r3, [r7, #0]
10041e1e:	685a      	ldr	r2, [r3, #4]
10041e20:	2380      	movs	r3, #128	@ 0x80
10041e22:	02db      	lsls	r3, r3, #11
10041e24:	4013      	ands	r3, r2
10041e26:	d030      	beq.n	10041e8a <HAL_GPIO_Init+0x202>
        {
          temp = SYSCFG->IO_DTR;
10041e28:	2380      	movs	r3, #128	@ 0x80
10041e2a:	05db      	lsls	r3, r3, #23
10041e2c:	68db      	ldr	r3, [r3, #12]
10041e2e:	613b      	str	r3, [r7, #16]
          if (GPIOx == GPIOA)
10041e30:	687a      	ldr	r2, [r7, #4]
10041e32:	2390      	movs	r3, #144	@ 0x90
10041e34:	05db      	lsls	r3, r3, #23
10041e36:	429a      	cmp	r2, r3
10041e38:	d111      	bne.n	10041e5e <HAL_GPIO_Init+0x1d6>
          {
            temp &= ~(1 << position);
10041e3a:	2201      	movs	r2, #1
10041e3c:	697b      	ldr	r3, [r7, #20]
10041e3e:	409a      	lsls	r2, r3
10041e40:	0013      	movs	r3, r2
10041e42:	43db      	mvns	r3, r3
10041e44:	001a      	movs	r2, r3
10041e46:	693b      	ldr	r3, [r7, #16]
10041e48:	4013      	ands	r3, r2
10041e4a:	613b      	str	r3, [r7, #16]
            temp |= (1 << position);
10041e4c:	2201      	movs	r2, #1
10041e4e:	697b      	ldr	r3, [r7, #20]
10041e50:	409a      	lsls	r2, r3
10041e52:	0013      	movs	r3, r2
10041e54:	001a      	movs	r2, r3
10041e56:	693b      	ldr	r3, [r7, #16]
10041e58:	4313      	orrs	r3, r2
10041e5a:	613b      	str	r3, [r7, #16]
10041e5c:	e011      	b.n	10041e82 <HAL_GPIO_Init+0x1fa>
          }
          else
          {
            temp &= ~((1 << position) << 16);
10041e5e:	2201      	movs	r2, #1
10041e60:	697b      	ldr	r3, [r7, #20]
10041e62:	409a      	lsls	r2, r3
10041e64:	0013      	movs	r3, r2
10041e66:	041b      	lsls	r3, r3, #16
10041e68:	43db      	mvns	r3, r3
10041e6a:	001a      	movs	r2, r3
10041e6c:	693b      	ldr	r3, [r7, #16]
10041e6e:	4013      	ands	r3, r2
10041e70:	613b      	str	r3, [r7, #16]
            temp |= ((1 << position) << 16);
10041e72:	2201      	movs	r2, #1
10041e74:	697b      	ldr	r3, [r7, #20]
10041e76:	409a      	lsls	r2, r3
10041e78:	0013      	movs	r3, r2
10041e7a:	041b      	lsls	r3, r3, #16
10041e7c:	693a      	ldr	r2, [r7, #16]
10041e7e:	4313      	orrs	r3, r2
10041e80:	613b      	str	r3, [r7, #16]
          }
          SYSCFG->IO_DTR = temp;
10041e82:	2380      	movs	r3, #128	@ 0x80
10041e84:	05db      	lsls	r3, r3, #23
10041e86:	693a      	ldr	r2, [r7, #16]
10041e88:	60da      	str	r2, [r3, #12]
        }

		/* Edge selection configuration */
		if ((GPIO_Init->Mode & EDGE_SELECTION) != 0x00u)
10041e8a:	683b      	ldr	r3, [r7, #0]
10041e8c:	685a      	ldr	r2, [r3, #4]
10041e8e:	2380      	movs	r3, #128	@ 0x80
10041e90:	035b      	lsls	r3, r3, #13
10041e92:	4013      	ands	r3, r2
10041e94:	d030      	beq.n	10041ef8 <HAL_GPIO_Init+0x270>
        {
          temp = SYSCFG->IO_IBER;
10041e96:	2380      	movs	r3, #128	@ 0x80
10041e98:	05db      	lsls	r3, r3, #23
10041e9a:	691b      	ldr	r3, [r3, #16]
10041e9c:	613b      	str	r3, [r7, #16]

          if (GPIOx == GPIOA)
10041e9e:	687a      	ldr	r2, [r7, #4]
10041ea0:	2390      	movs	r3, #144	@ 0x90
10041ea2:	05db      	lsls	r3, r3, #23
10041ea4:	429a      	cmp	r2, r3
10041ea6:	d111      	bne.n	10041ecc <HAL_GPIO_Init+0x244>
          {
            temp &= ~(1 << position);
10041ea8:	2201      	movs	r2, #1
10041eaa:	697b      	ldr	r3, [r7, #20]
10041eac:	409a      	lsls	r2, r3
10041eae:	0013      	movs	r3, r2
10041eb0:	43db      	mvns	r3, r3
10041eb2:	001a      	movs	r2, r3
10041eb4:	693b      	ldr	r3, [r7, #16]
10041eb6:	4013      	ands	r3, r2
10041eb8:	613b      	str	r3, [r7, #16]
            temp |= (1 << position);
10041eba:	2201      	movs	r2, #1
10041ebc:	697b      	ldr	r3, [r7, #20]
10041ebe:	409a      	lsls	r2, r3
10041ec0:	0013      	movs	r3, r2
10041ec2:	001a      	movs	r2, r3
10041ec4:	693b      	ldr	r3, [r7, #16]
10041ec6:	4313      	orrs	r3, r2
10041ec8:	613b      	str	r3, [r7, #16]
10041eca:	e011      	b.n	10041ef0 <HAL_GPIO_Init+0x268>
          }
          else
          {
            temp &= ~((1 << position) << 16);
10041ecc:	2201      	movs	r2, #1
10041ece:	697b      	ldr	r3, [r7, #20]
10041ed0:	409a      	lsls	r2, r3
10041ed2:	0013      	movs	r3, r2
10041ed4:	041b      	lsls	r3, r3, #16
10041ed6:	43db      	mvns	r3, r3
10041ed8:	001a      	movs	r2, r3
10041eda:	693b      	ldr	r3, [r7, #16]
10041edc:	4013      	ands	r3, r2
10041ede:	613b      	str	r3, [r7, #16]
            temp |= ((1 << position) << 16);
10041ee0:	2201      	movs	r2, #1
10041ee2:	697b      	ldr	r3, [r7, #20]
10041ee4:	409a      	lsls	r2, r3
10041ee6:	0013      	movs	r3, r2
10041ee8:	041b      	lsls	r3, r3, #16
10041eea:	693a      	ldr	r2, [r7, #16]
10041eec:	4313      	orrs	r3, r2
10041eee:	613b      	str	r3, [r7, #16]
          }
          SYSCFG->IO_IBER= temp;
10041ef0:	2380      	movs	r3, #128	@ 0x80
10041ef2:	05db      	lsls	r3, r3, #23
10041ef4:	693a      	ldr	r2, [r7, #16]
10041ef6:	611a      	str	r2, [r3, #16]
        }

        /* Trigger mode configuration */
		if ((GPIO_Init->Mode & TRIGGER_MODE) != 0x00u)
10041ef8:	683b      	ldr	r3, [r7, #0]
10041efa:	685a      	ldr	r2, [r3, #4]
10041efc:	2380      	movs	r3, #128	@ 0x80
10041efe:	03db      	lsls	r3, r3, #15
10041f00:	4013      	ands	r3, r2
10041f02:	d030      	beq.n	10041f66 <HAL_GPIO_Init+0x2de>
        {
          temp = SYSCFG->IO_IEVR;
10041f04:	2380      	movs	r3, #128	@ 0x80
10041f06:	05db      	lsls	r3, r3, #23
10041f08:	695b      	ldr	r3, [r3, #20]
10041f0a:	613b      	str	r3, [r7, #16]

          if (GPIOx == GPIOA)
10041f0c:	687a      	ldr	r2, [r7, #4]
10041f0e:	2390      	movs	r3, #144	@ 0x90
10041f10:	05db      	lsls	r3, r3, #23
10041f12:	429a      	cmp	r2, r3
10041f14:	d111      	bne.n	10041f3a <HAL_GPIO_Init+0x2b2>
          {
            temp &= ~(1 << position);
10041f16:	2201      	movs	r2, #1
10041f18:	697b      	ldr	r3, [r7, #20]
10041f1a:	409a      	lsls	r2, r3
10041f1c:	0013      	movs	r3, r2
10041f1e:	43db      	mvns	r3, r3
10041f20:	001a      	movs	r2, r3
10041f22:	693b      	ldr	r3, [r7, #16]
10041f24:	4013      	ands	r3, r2
10041f26:	613b      	str	r3, [r7, #16]
            temp |= (1 << position);
10041f28:	2201      	movs	r2, #1
10041f2a:	697b      	ldr	r3, [r7, #20]
10041f2c:	409a      	lsls	r2, r3
10041f2e:	0013      	movs	r3, r2
10041f30:	001a      	movs	r2, r3
10041f32:	693b      	ldr	r3, [r7, #16]
10041f34:	4313      	orrs	r3, r2
10041f36:	613b      	str	r3, [r7, #16]
10041f38:	e011      	b.n	10041f5e <HAL_GPIO_Init+0x2d6>
          }
          else
          {
            temp &= ~((1 << position) << 16);
10041f3a:	2201      	movs	r2, #1
10041f3c:	697b      	ldr	r3, [r7, #20]
10041f3e:	409a      	lsls	r2, r3
10041f40:	0013      	movs	r3, r2
10041f42:	041b      	lsls	r3, r3, #16
10041f44:	43db      	mvns	r3, r3
10041f46:	001a      	movs	r2, r3
10041f48:	693b      	ldr	r3, [r7, #16]
10041f4a:	4013      	ands	r3, r2
10041f4c:	613b      	str	r3, [r7, #16]
            temp |= ((1 << position) << 16);
10041f4e:	2201      	movs	r2, #1
10041f50:	697b      	ldr	r3, [r7, #20]
10041f52:	409a      	lsls	r2, r3
10041f54:	0013      	movs	r3, r2
10041f56:	041b      	lsls	r3, r3, #16
10041f58:	693a      	ldr	r2, [r7, #16]
10041f5a:	4313      	orrs	r3, r2
10041f5c:	613b      	str	r3, [r7, #16]
          }
          SYSCFG->IO_IEVR= temp;
10041f5e:	2380      	movs	r3, #128	@ 0x80
10041f60:	05db      	lsls	r3, r3, #23
10041f62:	693a      	ldr	r2, [r7, #16]
10041f64:	615a      	str	r2, [r3, #20]
        }

        /* Enable the specified EXTI interrupt line */
        if ((GPIO_Init->Mode & EXTI_IT) == EXTI_IT)
10041f66:	683b      	ldr	r3, [r7, #0]
10041f68:	685a      	ldr	r2, [r3, #4]
10041f6a:	2380      	movs	r3, #128	@ 0x80
10041f6c:	025b      	lsls	r3, r3, #9
10041f6e:	4013      	ands	r3, r2
10041f70:	d030      	beq.n	10041fd4 <HAL_GPIO_Init+0x34c>
        {
          temp = SYSCFG->IO_IER;
10041f72:	2380      	movs	r3, #128	@ 0x80
10041f74:	05db      	lsls	r3, r3, #23
10041f76:	699b      	ldr	r3, [r3, #24]
10041f78:	613b      	str	r3, [r7, #16]

          if (GPIOx == GPIOA)
10041f7a:	687a      	ldr	r2, [r7, #4]
10041f7c:	2390      	movs	r3, #144	@ 0x90
10041f7e:	05db      	lsls	r3, r3, #23
10041f80:	429a      	cmp	r2, r3
10041f82:	d111      	bne.n	10041fa8 <HAL_GPIO_Init+0x320>
          {
            temp &= ~(1 << position);
10041f84:	2201      	movs	r2, #1
10041f86:	697b      	ldr	r3, [r7, #20]
10041f88:	409a      	lsls	r2, r3
10041f8a:	0013      	movs	r3, r2
10041f8c:	43db      	mvns	r3, r3
10041f8e:	001a      	movs	r2, r3
10041f90:	693b      	ldr	r3, [r7, #16]
10041f92:	4013      	ands	r3, r2
10041f94:	613b      	str	r3, [r7, #16]
            temp |= (1 << position);
10041f96:	2201      	movs	r2, #1
10041f98:	697b      	ldr	r3, [r7, #20]
10041f9a:	409a      	lsls	r2, r3
10041f9c:	0013      	movs	r3, r2
10041f9e:	001a      	movs	r2, r3
10041fa0:	693b      	ldr	r3, [r7, #16]
10041fa2:	4313      	orrs	r3, r2
10041fa4:	613b      	str	r3, [r7, #16]
10041fa6:	e011      	b.n	10041fcc <HAL_GPIO_Init+0x344>
          }
          else
          {
            temp &= ~((1 << position) << 16);
10041fa8:	2201      	movs	r2, #1
10041faa:	697b      	ldr	r3, [r7, #20]
10041fac:	409a      	lsls	r2, r3
10041fae:	0013      	movs	r3, r2
10041fb0:	041b      	lsls	r3, r3, #16
10041fb2:	43db      	mvns	r3, r3
10041fb4:	001a      	movs	r2, r3
10041fb6:	693b      	ldr	r3, [r7, #16]
10041fb8:	4013      	ands	r3, r2
10041fba:	613b      	str	r3, [r7, #16]
            temp |= ((1 << position) << 16);
10041fbc:	2201      	movs	r2, #1
10041fbe:	697b      	ldr	r3, [r7, #20]
10041fc0:	409a      	lsls	r2, r3
10041fc2:	0013      	movs	r3, r2
10041fc4:	041b      	lsls	r3, r3, #16
10041fc6:	693a      	ldr	r2, [r7, #16]
10041fc8:	4313      	orrs	r3, r2
10041fca:	613b      	str	r3, [r7, #16]
          }
          SYSCFG->IO_IER= temp;
10041fcc:	2380      	movs	r3, #128	@ 0x80
10041fce:	05db      	lsls	r3, r3, #23
10041fd0:	693a      	ldr	r2, [r7, #16]
10041fd2:	619a      	str	r2, [r3, #24]
        }
      }
    }

    position++;
10041fd4:	697b      	ldr	r3, [r7, #20]
10041fd6:	3301      	adds	r3, #1
10041fd8:	617b      	str	r3, [r7, #20]
  while (((GPIO_Init->Pin) >> position) != 0x00u)
10041fda:	683b      	ldr	r3, [r7, #0]
10041fdc:	681a      	ldr	r2, [r3, #0]
10041fde:	697b      	ldr	r3, [r7, #20]
10041fe0:	40da      	lsrs	r2, r3
10041fe2:	1e13      	subs	r3, r2, #0
10041fe4:	d000      	beq.n	10041fe8 <HAL_GPIO_Init+0x360>
10041fe6:	e657      	b.n	10041c98 <HAL_GPIO_Init+0x10>
  }
}
10041fe8:	46c0      	nop			@ (mov r8, r8)
10041fea:	46c0      	nop			@ (mov r8, r8)
10041fec:	46bd      	mov	sp, r7
10041fee:	b006      	add	sp, #24
10041ff0:	bd80      	pop	{r7, pc}

10041ff2 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
10041ff2:	b580      	push	{r7, lr}
10041ff4:	b082      	sub	sp, #8
10041ff6:	af00      	add	r7, sp, #0
10041ff8:	6078      	str	r0, [r7, #4]
10041ffa:	0008      	movs	r0, r1
10041ffc:	0011      	movs	r1, r2
10041ffe:	1cbb      	adds	r3, r7, #2
10042000:	1c02      	adds	r2, r0, #0
10042002:	801a      	strh	r2, [r3, #0]
10042004:	1c7b      	adds	r3, r7, #1
10042006:	1c0a      	adds	r2, r1, #0
10042008:	701a      	strb	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
1004200a:	1c7b      	adds	r3, r7, #1
1004200c:	781b      	ldrb	r3, [r3, #0]
1004200e:	2b00      	cmp	r3, #0
10042010:	d004      	beq.n	1004201c <HAL_GPIO_WritePin+0x2a>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
10042012:	1cbb      	adds	r3, r7, #2
10042014:	881a      	ldrh	r2, [r3, #0]
10042016:	687b      	ldr	r3, [r7, #4]
10042018:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
  }
}
1004201a:	e003      	b.n	10042024 <HAL_GPIO_WritePin+0x32>
    GPIOx->BRR = (uint32_t)GPIO_Pin;
1004201c:	1cbb      	adds	r3, r7, #2
1004201e:	881a      	ldrh	r2, [r3, #0]
10042020:	687b      	ldr	r3, [r7, #4]
10042022:	629a      	str	r2, [r3, #40]	@ 0x28
}
10042024:	46c0      	nop			@ (mov r8, r8)
10042026:	46bd      	mov	sp, r7
10042028:	b002      	add	sp, #8
1004202a:	bd80      	pop	{r7, pc}

1004202c <HAL_I2C_Init>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
{
1004202c:	b580      	push	{r7, lr}
1004202e:	b082      	sub	sp, #8
10042030:	af00      	add	r7, sp, #0
10042032:	6078      	str	r0, [r7, #4]
  /* Check the I2C handle allocation */
  if (hi2c == NULL)
10042034:	687b      	ldr	r3, [r7, #4]
10042036:	2b00      	cmp	r3, #0
10042038:	d101      	bne.n	1004203e <HAL_I2C_Init+0x12>
  {
    return HAL_ERROR;
1004203a:	2301      	movs	r3, #1
1004203c:	e08f      	b.n	1004215e <HAL_I2C_Init+0x132>
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
  assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));

  if (hi2c->State == HAL_I2C_STATE_RESET)
1004203e:	687b      	ldr	r3, [r7, #4]
10042040:	2241      	movs	r2, #65	@ 0x41
10042042:	5c9b      	ldrb	r3, [r3, r2]
10042044:	b2db      	uxtb	r3, r3
10042046:	2b00      	cmp	r3, #0
10042048:	d107      	bne.n	1004205a <HAL_I2C_Init+0x2e>
  {
    /* Allocate lock resource and initialize it */
    hi2c->Lock = HAL_UNLOCKED;
1004204a:	687b      	ldr	r3, [r7, #4]
1004204c:	2240      	movs	r2, #64	@ 0x40
1004204e:	2100      	movs	r1, #0
10042050:	5499      	strb	r1, [r3, r2]

    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    hi2c->MspInitCallback(hi2c);
#else
    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    HAL_I2C_MspInit(hi2c);
10042052:	687b      	ldr	r3, [r7, #4]
10042054:	0018      	movs	r0, r3
10042056:	f7fe fd2d 	bl	10040ab4 <HAL_I2C_MspInit>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }

  hi2c->State = HAL_I2C_STATE_BUSY;
1004205a:	687b      	ldr	r3, [r7, #4]
1004205c:	2241      	movs	r2, #65	@ 0x41
1004205e:	2124      	movs	r1, #36	@ 0x24
10042060:	5499      	strb	r1, [r3, r2]

  /* Disable the selected I2C peripheral */
  __HAL_I2C_DISABLE(hi2c);
10042062:	687b      	ldr	r3, [r7, #4]
10042064:	681b      	ldr	r3, [r3, #0]
10042066:	681a      	ldr	r2, [r3, #0]
10042068:	687b      	ldr	r3, [r7, #4]
1004206a:	681b      	ldr	r3, [r3, #0]
1004206c:	2101      	movs	r1, #1
1004206e:	438a      	bics	r2, r1
10042070:	601a      	str	r2, [r3, #0]

  /*---------------------------- I2Cx TIMINGR Configuration ------------------*/
  /* Configure I2Cx: Frequency range */
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
10042072:	687b      	ldr	r3, [r7, #4]
10042074:	685a      	ldr	r2, [r3, #4]
10042076:	687b      	ldr	r3, [r7, #4]
10042078:	681b      	ldr	r3, [r3, #0]
1004207a:	493b      	ldr	r1, [pc, #236]	@ (10042168 <HAL_I2C_Init+0x13c>)
1004207c:	400a      	ands	r2, r1
1004207e:	611a      	str	r2, [r3, #16]

  /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
  /* Disable Own Address1 before set the Own Address1 configuration */
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
10042080:	687b      	ldr	r3, [r7, #4]
10042082:	681b      	ldr	r3, [r3, #0]
10042084:	689a      	ldr	r2, [r3, #8]
10042086:	687b      	ldr	r3, [r7, #4]
10042088:	681b      	ldr	r3, [r3, #0]
1004208a:	4938      	ldr	r1, [pc, #224]	@ (1004216c <HAL_I2C_Init+0x140>)
1004208c:	400a      	ands	r2, r1
1004208e:	609a      	str	r2, [r3, #8]

  /* Configure I2Cx: Own Address1 and ack own address1 mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
10042090:	687b      	ldr	r3, [r7, #4]
10042092:	68db      	ldr	r3, [r3, #12]
10042094:	2b01      	cmp	r3, #1
10042096:	d108      	bne.n	100420aa <HAL_I2C_Init+0x7e>
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
10042098:	687b      	ldr	r3, [r7, #4]
1004209a:	689a      	ldr	r2, [r3, #8]
1004209c:	687b      	ldr	r3, [r7, #4]
1004209e:	681b      	ldr	r3, [r3, #0]
100420a0:	2180      	movs	r1, #128	@ 0x80
100420a2:	0209      	lsls	r1, r1, #8
100420a4:	430a      	orrs	r2, r1
100420a6:	609a      	str	r2, [r3, #8]
100420a8:	e007      	b.n	100420ba <HAL_I2C_Init+0x8e>
  }
  else /* I2C_ADDRESSINGMODE_10BIT */
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
100420aa:	687b      	ldr	r3, [r7, #4]
100420ac:	689a      	ldr	r2, [r3, #8]
100420ae:	687b      	ldr	r3, [r7, #4]
100420b0:	681b      	ldr	r3, [r3, #0]
100420b2:	2184      	movs	r1, #132	@ 0x84
100420b4:	0209      	lsls	r1, r1, #8
100420b6:	430a      	orrs	r2, r1
100420b8:	609a      	str	r2, [r3, #8]
  }

  /*---------------------------- I2Cx CR2 Configuration ----------------------*/
  /* Configure I2Cx: Addressing Master mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
100420ba:	687b      	ldr	r3, [r7, #4]
100420bc:	68db      	ldr	r3, [r3, #12]
100420be:	2b02      	cmp	r3, #2
100420c0:	d109      	bne.n	100420d6 <HAL_I2C_Init+0xaa>
  {
    SET_BIT(hi2c->Instance->CR2, I2C_CR2_ADD10);
100420c2:	687b      	ldr	r3, [r7, #4]
100420c4:	681b      	ldr	r3, [r3, #0]
100420c6:	685a      	ldr	r2, [r3, #4]
100420c8:	687b      	ldr	r3, [r7, #4]
100420ca:	681b      	ldr	r3, [r3, #0]
100420cc:	2180      	movs	r1, #128	@ 0x80
100420ce:	0109      	lsls	r1, r1, #4
100420d0:	430a      	orrs	r2, r1
100420d2:	605a      	str	r2, [r3, #4]
100420d4:	e007      	b.n	100420e6 <HAL_I2C_Init+0xba>
  }
  else
  {
    /* Clear the I2C ADD10 bit */
    CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_ADD10);
100420d6:	687b      	ldr	r3, [r7, #4]
100420d8:	681b      	ldr	r3, [r3, #0]
100420da:	685a      	ldr	r2, [r3, #4]
100420dc:	687b      	ldr	r3, [r7, #4]
100420de:	681b      	ldr	r3, [r3, #0]
100420e0:	4923      	ldr	r1, [pc, #140]	@ (10042170 <HAL_I2C_Init+0x144>)
100420e2:	400a      	ands	r2, r1
100420e4:	605a      	str	r2, [r3, #4]
  }
  /* Enable the AUTOEND by default, and enable NACK (should be disable only during Slave process */
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
100420e6:	687b      	ldr	r3, [r7, #4]
100420e8:	681b      	ldr	r3, [r3, #0]
100420ea:	685a      	ldr	r2, [r3, #4]
100420ec:	687b      	ldr	r3, [r7, #4]
100420ee:	681b      	ldr	r3, [r3, #0]
100420f0:	4920      	ldr	r1, [pc, #128]	@ (10042174 <HAL_I2C_Init+0x148>)
100420f2:	430a      	orrs	r2, r1
100420f4:	605a      	str	r2, [r3, #4]

  /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
  /* Disable Own Address2 before set the Own Address2 configuration */
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
100420f6:	687b      	ldr	r3, [r7, #4]
100420f8:	681b      	ldr	r3, [r3, #0]
100420fa:	68da      	ldr	r2, [r3, #12]
100420fc:	687b      	ldr	r3, [r7, #4]
100420fe:	681b      	ldr	r3, [r3, #0]
10042100:	491a      	ldr	r1, [pc, #104]	@ (1004216c <HAL_I2C_Init+0x140>)
10042102:	400a      	ands	r2, r1
10042104:	60da      	str	r2, [r3, #12]

  /* Configure I2Cx: Dual mode and Own Address2 */
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | \
10042106:	687b      	ldr	r3, [r7, #4]
10042108:	691a      	ldr	r2, [r3, #16]
1004210a:	687b      	ldr	r3, [r7, #4]
1004210c:	695b      	ldr	r3, [r3, #20]
1004210e:	431a      	orrs	r2, r3
10042110:	0011      	movs	r1, r2
                          (hi2c->Init.OwnAddress2Masks << 8));
10042112:	687b      	ldr	r3, [r7, #4]
10042114:	699b      	ldr	r3, [r3, #24]
10042116:	021a      	lsls	r2, r3, #8
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | \
10042118:	687b      	ldr	r3, [r7, #4]
1004211a:	681b      	ldr	r3, [r3, #0]
1004211c:	430a      	orrs	r2, r1
1004211e:	60da      	str	r2, [r3, #12]

  /*---------------------------- I2Cx CR1 Configuration ----------------------*/
  /* Configure I2Cx: Generalcall and NoStretch mode */
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
10042120:	687b      	ldr	r3, [r7, #4]
10042122:	69d9      	ldr	r1, [r3, #28]
10042124:	687b      	ldr	r3, [r7, #4]
10042126:	6a1a      	ldr	r2, [r3, #32]
10042128:	687b      	ldr	r3, [r7, #4]
1004212a:	681b      	ldr	r3, [r3, #0]
1004212c:	430a      	orrs	r2, r1
1004212e:	601a      	str	r2, [r3, #0]

  /* Enable the selected I2C peripheral */
  __HAL_I2C_ENABLE(hi2c);
10042130:	687b      	ldr	r3, [r7, #4]
10042132:	681b      	ldr	r3, [r3, #0]
10042134:	681a      	ldr	r2, [r3, #0]
10042136:	687b      	ldr	r3, [r7, #4]
10042138:	681b      	ldr	r3, [r3, #0]
1004213a:	2101      	movs	r1, #1
1004213c:	430a      	orrs	r2, r1
1004213e:	601a      	str	r2, [r3, #0]

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
10042140:	687b      	ldr	r3, [r7, #4]
10042142:	2200      	movs	r2, #0
10042144:	645a      	str	r2, [r3, #68]	@ 0x44
  hi2c->State = HAL_I2C_STATE_READY;
10042146:	687b      	ldr	r3, [r7, #4]
10042148:	2241      	movs	r2, #65	@ 0x41
1004214a:	2120      	movs	r1, #32
1004214c:	5499      	strb	r1, [r3, r2]
  hi2c->PreviousState = I2C_STATE_NONE;
1004214e:	687b      	ldr	r3, [r7, #4]
10042150:	2200      	movs	r2, #0
10042152:	631a      	str	r2, [r3, #48]	@ 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
10042154:	687b      	ldr	r3, [r7, #4]
10042156:	2242      	movs	r2, #66	@ 0x42
10042158:	2100      	movs	r1, #0
1004215a:	5499      	strb	r1, [r3, r2]

  return HAL_OK;
1004215c:	2300      	movs	r3, #0
}
1004215e:	0018      	movs	r0, r3
10042160:	46bd      	mov	sp, r7
10042162:	b002      	add	sp, #8
10042164:	bd80      	pop	{r7, pc}
10042166:	46c0      	nop			@ (mov r8, r8)
10042168:	f0ffffff 	.word	0xf0ffffff
1004216c:	ffff7fff 	.word	0xffff7fff
10042170:	fffff7ff 	.word	0xfffff7ff
10042174:	02008000 	.word	0x02008000

10042178 <HAL_I2C_Mem_Write>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,
                                    uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
10042178:	b590      	push	{r4, r7, lr}
1004217a:	b089      	sub	sp, #36	@ 0x24
1004217c:	af02      	add	r7, sp, #8
1004217e:	60f8      	str	r0, [r7, #12]
10042180:	000c      	movs	r4, r1
10042182:	0010      	movs	r0, r2
10042184:	0019      	movs	r1, r3
10042186:	230a      	movs	r3, #10
10042188:	18fb      	adds	r3, r7, r3
1004218a:	1c22      	adds	r2, r4, #0
1004218c:	801a      	strh	r2, [r3, #0]
1004218e:	2308      	movs	r3, #8
10042190:	18fb      	adds	r3, r7, r3
10042192:	1c02      	adds	r2, r0, #0
10042194:	801a      	strh	r2, [r3, #0]
10042196:	1dbb      	adds	r3, r7, #6
10042198:	1c0a      	adds	r2, r1, #0
1004219a:	801a      	strh	r2, [r3, #0]
  uint32_t tickstart;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
1004219c:	68fb      	ldr	r3, [r7, #12]
1004219e:	2241      	movs	r2, #65	@ 0x41
100421a0:	5c9b      	ldrb	r3, [r3, r2]
100421a2:	b2db      	uxtb	r3, r3
100421a4:	2b20      	cmp	r3, #32
100421a6:	d000      	beq.n	100421aa <HAL_I2C_Mem_Write+0x32>
100421a8:	e10c      	b.n	100423c4 <HAL_I2C_Mem_Write+0x24c>
  {
    if ((pData == NULL) || (Size == 0U))
100421aa:	6abb      	ldr	r3, [r7, #40]	@ 0x28
100421ac:	2b00      	cmp	r3, #0
100421ae:	d004      	beq.n	100421ba <HAL_I2C_Mem_Write+0x42>
100421b0:	232c      	movs	r3, #44	@ 0x2c
100421b2:	18fb      	adds	r3, r7, r3
100421b4:	881b      	ldrh	r3, [r3, #0]
100421b6:	2b00      	cmp	r3, #0
100421b8:	d105      	bne.n	100421c6 <HAL_I2C_Mem_Write+0x4e>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
100421ba:	68fb      	ldr	r3, [r7, #12]
100421bc:	2280      	movs	r2, #128	@ 0x80
100421be:	0092      	lsls	r2, r2, #2
100421c0:	645a      	str	r2, [r3, #68]	@ 0x44
      return  HAL_ERROR;
100421c2:	2301      	movs	r3, #1
100421c4:	e0ff      	b.n	100423c6 <HAL_I2C_Mem_Write+0x24e>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
100421c6:	68fb      	ldr	r3, [r7, #12]
100421c8:	2240      	movs	r2, #64	@ 0x40
100421ca:	5c9b      	ldrb	r3, [r3, r2]
100421cc:	2b01      	cmp	r3, #1
100421ce:	d101      	bne.n	100421d4 <HAL_I2C_Mem_Write+0x5c>
100421d0:	2302      	movs	r3, #2
100421d2:	e0f8      	b.n	100423c6 <HAL_I2C_Mem_Write+0x24e>
100421d4:	68fb      	ldr	r3, [r7, #12]
100421d6:	2240      	movs	r2, #64	@ 0x40
100421d8:	2101      	movs	r1, #1
100421da:	5499      	strb	r1, [r3, r2]

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
100421dc:	f7ff fc3e 	bl	10041a5c <HAL_GetTick>
100421e0:	0003      	movs	r3, r0
100421e2:	617b      	str	r3, [r7, #20]

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
100421e4:	2380      	movs	r3, #128	@ 0x80
100421e6:	0219      	lsls	r1, r3, #8
100421e8:	68f8      	ldr	r0, [r7, #12]
100421ea:	697b      	ldr	r3, [r7, #20]
100421ec:	9300      	str	r3, [sp, #0]
100421ee:	2319      	movs	r3, #25
100421f0:	2201      	movs	r2, #1
100421f2:	f000 f975 	bl	100424e0 <I2C_WaitOnFlagUntilTimeout>
100421f6:	1e03      	subs	r3, r0, #0
100421f8:	d001      	beq.n	100421fe <HAL_I2C_Mem_Write+0x86>
    {
      return HAL_ERROR;
100421fa:	2301      	movs	r3, #1
100421fc:	e0e3      	b.n	100423c6 <HAL_I2C_Mem_Write+0x24e>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
100421fe:	68fb      	ldr	r3, [r7, #12]
10042200:	2241      	movs	r2, #65	@ 0x41
10042202:	2121      	movs	r1, #33	@ 0x21
10042204:	5499      	strb	r1, [r3, r2]
    hi2c->Mode      = HAL_I2C_MODE_MEM;
10042206:	68fb      	ldr	r3, [r7, #12]
10042208:	2242      	movs	r2, #66	@ 0x42
1004220a:	2140      	movs	r1, #64	@ 0x40
1004220c:	5499      	strb	r1, [r3, r2]
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
1004220e:	68fb      	ldr	r3, [r7, #12]
10042210:	2200      	movs	r2, #0
10042212:	645a      	str	r2, [r3, #68]	@ 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
10042214:	68fb      	ldr	r3, [r7, #12]
10042216:	6aba      	ldr	r2, [r7, #40]	@ 0x28
10042218:	625a      	str	r2, [r3, #36]	@ 0x24
    hi2c->XferCount = Size;
1004221a:	68fb      	ldr	r3, [r7, #12]
1004221c:	222c      	movs	r2, #44	@ 0x2c
1004221e:	18ba      	adds	r2, r7, r2
10042220:	8812      	ldrh	r2, [r2, #0]
10042222:	855a      	strh	r2, [r3, #42]	@ 0x2a
    hi2c->XferISR   = NULL;
10042224:	68fb      	ldr	r3, [r7, #12]
10042226:	2200      	movs	r2, #0
10042228:	635a      	str	r2, [r3, #52]	@ 0x34

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
1004222a:	1dbb      	adds	r3, r7, #6
1004222c:	881c      	ldrh	r4, [r3, #0]
1004222e:	2308      	movs	r3, #8
10042230:	18fb      	adds	r3, r7, r3
10042232:	881a      	ldrh	r2, [r3, #0]
10042234:	230a      	movs	r3, #10
10042236:	18fb      	adds	r3, r7, r3
10042238:	8819      	ldrh	r1, [r3, #0]
1004223a:	68f8      	ldr	r0, [r7, #12]
1004223c:	697b      	ldr	r3, [r7, #20]
1004223e:	9301      	str	r3, [sp, #4]
10042240:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
10042242:	9300      	str	r3, [sp, #0]
10042244:	0023      	movs	r3, r4
10042246:	f000 f8c5 	bl	100423d4 <I2C_RequestMemoryWrite>
1004224a:	1e03      	subs	r3, r0, #0
1004224c:	d005      	beq.n	1004225a <HAL_I2C_Mem_Write+0xe2>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
1004224e:	68fb      	ldr	r3, [r7, #12]
10042250:	2240      	movs	r2, #64	@ 0x40
10042252:	2100      	movs	r1, #0
10042254:	5499      	strb	r1, [r3, r2]
      return HAL_ERROR;
10042256:	2301      	movs	r3, #1
10042258:	e0b5      	b.n	100423c6 <HAL_I2C_Mem_Write+0x24e>
    }

    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
1004225a:	68fb      	ldr	r3, [r7, #12]
1004225c:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
1004225e:	b29b      	uxth	r3, r3
10042260:	2bff      	cmp	r3, #255	@ 0xff
10042262:	d911      	bls.n	10042288 <HAL_I2C_Mem_Write+0x110>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
10042264:	68fb      	ldr	r3, [r7, #12]
10042266:	22ff      	movs	r2, #255	@ 0xff
10042268:	851a      	strh	r2, [r3, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
1004226a:	68fb      	ldr	r3, [r7, #12]
1004226c:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
1004226e:	b2da      	uxtb	r2, r3
10042270:	2380      	movs	r3, #128	@ 0x80
10042272:	045c      	lsls	r4, r3, #17
10042274:	230a      	movs	r3, #10
10042276:	18fb      	adds	r3, r7, r3
10042278:	8819      	ldrh	r1, [r3, #0]
1004227a:	68f8      	ldr	r0, [r7, #12]
1004227c:	2300      	movs	r3, #0
1004227e:	9300      	str	r3, [sp, #0]
10042280:	0023      	movs	r3, r4
10042282:	f000 fb07 	bl	10042894 <I2C_TransferConfig>
10042286:	e012      	b.n	100422ae <HAL_I2C_Mem_Write+0x136>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
10042288:	68fb      	ldr	r3, [r7, #12]
1004228a:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
1004228c:	b29a      	uxth	r2, r3
1004228e:	68fb      	ldr	r3, [r7, #12]
10042290:	851a      	strh	r2, [r3, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
10042292:	68fb      	ldr	r3, [r7, #12]
10042294:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
10042296:	b2da      	uxtb	r2, r3
10042298:	2380      	movs	r3, #128	@ 0x80
1004229a:	049c      	lsls	r4, r3, #18
1004229c:	230a      	movs	r3, #10
1004229e:	18fb      	adds	r3, r7, r3
100422a0:	8819      	ldrh	r1, [r3, #0]
100422a2:	68f8      	ldr	r0, [r7, #12]
100422a4:	2300      	movs	r3, #0
100422a6:	9300      	str	r3, [sp, #0]
100422a8:	0023      	movs	r3, r4
100422aa:	f000 faf3 	bl	10042894 <I2C_TransferConfig>
    }

    do
    {
      /* Wait until TXIS flag is set */
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
100422ae:	697a      	ldr	r2, [r7, #20]
100422b0:	6b39      	ldr	r1, [r7, #48]	@ 0x30
100422b2:	68fb      	ldr	r3, [r7, #12]
100422b4:	0018      	movs	r0, r3
100422b6:	f000 f96b 	bl	10042590 <I2C_WaitOnTXISFlagUntilTimeout>
100422ba:	1e03      	subs	r3, r0, #0
100422bc:	d001      	beq.n	100422c2 <HAL_I2C_Mem_Write+0x14a>
      {
        return HAL_ERROR;
100422be:	2301      	movs	r3, #1
100422c0:	e081      	b.n	100423c6 <HAL_I2C_Mem_Write+0x24e>
      }

      /* Write data to TXDR */
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
100422c2:	68fb      	ldr	r3, [r7, #12]
100422c4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
100422c6:	781a      	ldrb	r2, [r3, #0]
100422c8:	68fb      	ldr	r3, [r7, #12]
100422ca:	681b      	ldr	r3, [r3, #0]
100422cc:	629a      	str	r2, [r3, #40]	@ 0x28

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
100422ce:	68fb      	ldr	r3, [r7, #12]
100422d0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
100422d2:	1c5a      	adds	r2, r3, #1
100422d4:	68fb      	ldr	r3, [r7, #12]
100422d6:	625a      	str	r2, [r3, #36]	@ 0x24

      hi2c->XferCount--;
100422d8:	68fb      	ldr	r3, [r7, #12]
100422da:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
100422dc:	b29b      	uxth	r3, r3
100422de:	3b01      	subs	r3, #1
100422e0:	b29a      	uxth	r2, r3
100422e2:	68fb      	ldr	r3, [r7, #12]
100422e4:	855a      	strh	r2, [r3, #42]	@ 0x2a
      hi2c->XferSize--;
100422e6:	68fb      	ldr	r3, [r7, #12]
100422e8:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
100422ea:	3b01      	subs	r3, #1
100422ec:	b29a      	uxth	r2, r3
100422ee:	68fb      	ldr	r3, [r7, #12]
100422f0:	851a      	strh	r2, [r3, #40]	@ 0x28

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
100422f2:	68fb      	ldr	r3, [r7, #12]
100422f4:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
100422f6:	b29b      	uxth	r3, r3
100422f8:	2b00      	cmp	r3, #0
100422fa:	d03a      	beq.n	10042372 <HAL_I2C_Mem_Write+0x1fa>
100422fc:	68fb      	ldr	r3, [r7, #12]
100422fe:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
10042300:	2b00      	cmp	r3, #0
10042302:	d136      	bne.n	10042372 <HAL_I2C_Mem_Write+0x1fa>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
10042304:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
10042306:	68f8      	ldr	r0, [r7, #12]
10042308:	697b      	ldr	r3, [r7, #20]
1004230a:	9300      	str	r3, [sp, #0]
1004230c:	0013      	movs	r3, r2
1004230e:	2200      	movs	r2, #0
10042310:	2180      	movs	r1, #128	@ 0x80
10042312:	f000 f8e5 	bl	100424e0 <I2C_WaitOnFlagUntilTimeout>
10042316:	1e03      	subs	r3, r0, #0
10042318:	d001      	beq.n	1004231e <HAL_I2C_Mem_Write+0x1a6>
        {
          return HAL_ERROR;
1004231a:	2301      	movs	r3, #1
1004231c:	e053      	b.n	100423c6 <HAL_I2C_Mem_Write+0x24e>
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
1004231e:	68fb      	ldr	r3, [r7, #12]
10042320:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
10042322:	b29b      	uxth	r3, r3
10042324:	2bff      	cmp	r3, #255	@ 0xff
10042326:	d911      	bls.n	1004234c <HAL_I2C_Mem_Write+0x1d4>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
10042328:	68fb      	ldr	r3, [r7, #12]
1004232a:	22ff      	movs	r2, #255	@ 0xff
1004232c:	851a      	strh	r2, [r3, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
1004232e:	68fb      	ldr	r3, [r7, #12]
10042330:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
10042332:	b2da      	uxtb	r2, r3
10042334:	2380      	movs	r3, #128	@ 0x80
10042336:	045c      	lsls	r4, r3, #17
10042338:	230a      	movs	r3, #10
1004233a:	18fb      	adds	r3, r7, r3
1004233c:	8819      	ldrh	r1, [r3, #0]
1004233e:	68f8      	ldr	r0, [r7, #12]
10042340:	2300      	movs	r3, #0
10042342:	9300      	str	r3, [sp, #0]
10042344:	0023      	movs	r3, r4
10042346:	f000 faa5 	bl	10042894 <I2C_TransferConfig>
1004234a:	e012      	b.n	10042372 <HAL_I2C_Mem_Write+0x1fa>
                             I2C_NO_STARTSTOP);
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
1004234c:	68fb      	ldr	r3, [r7, #12]
1004234e:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
10042350:	b29a      	uxth	r2, r3
10042352:	68fb      	ldr	r3, [r7, #12]
10042354:	851a      	strh	r2, [r3, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
10042356:	68fb      	ldr	r3, [r7, #12]
10042358:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
1004235a:	b2da      	uxtb	r2, r3
1004235c:	2380      	movs	r3, #128	@ 0x80
1004235e:	049c      	lsls	r4, r3, #18
10042360:	230a      	movs	r3, #10
10042362:	18fb      	adds	r3, r7, r3
10042364:	8819      	ldrh	r1, [r3, #0]
10042366:	68f8      	ldr	r0, [r7, #12]
10042368:	2300      	movs	r3, #0
1004236a:	9300      	str	r3, [sp, #0]
1004236c:	0023      	movs	r3, r4
1004236e:	f000 fa91 	bl	10042894 <I2C_TransferConfig>
                             I2C_NO_STARTSTOP);
        }
      }

    } while (hi2c->XferCount > 0U);
10042372:	68fb      	ldr	r3, [r7, #12]
10042374:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
10042376:	b29b      	uxth	r3, r3
10042378:	2b00      	cmp	r3, #0
1004237a:	d198      	bne.n	100422ae <HAL_I2C_Mem_Write+0x136>

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is reset */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
1004237c:	697a      	ldr	r2, [r7, #20]
1004237e:	6b39      	ldr	r1, [r7, #48]	@ 0x30
10042380:	68fb      	ldr	r3, [r7, #12]
10042382:	0018      	movs	r0, r3
10042384:	f000 f94a 	bl	1004261c <I2C_WaitOnSTOPFlagUntilTimeout>
10042388:	1e03      	subs	r3, r0, #0
1004238a:	d001      	beq.n	10042390 <HAL_I2C_Mem_Write+0x218>
    {
      return HAL_ERROR;
1004238c:	2301      	movs	r3, #1
1004238e:	e01a      	b.n	100423c6 <HAL_I2C_Mem_Write+0x24e>
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
10042390:	68fb      	ldr	r3, [r7, #12]
10042392:	681b      	ldr	r3, [r3, #0]
10042394:	2220      	movs	r2, #32
10042396:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
10042398:	68fb      	ldr	r3, [r7, #12]
1004239a:	681b      	ldr	r3, [r3, #0]
1004239c:	685a      	ldr	r2, [r3, #4]
1004239e:	68fb      	ldr	r3, [r7, #12]
100423a0:	681b      	ldr	r3, [r3, #0]
100423a2:	490b      	ldr	r1, [pc, #44]	@ (100423d0 <HAL_I2C_Mem_Write+0x258>)
100423a4:	400a      	ands	r2, r1
100423a6:	605a      	str	r2, [r3, #4]

    hi2c->State = HAL_I2C_STATE_READY;
100423a8:	68fb      	ldr	r3, [r7, #12]
100423aa:	2241      	movs	r2, #65	@ 0x41
100423ac:	2120      	movs	r1, #32
100423ae:	5499      	strb	r1, [r3, r2]
    hi2c->Mode  = HAL_I2C_MODE_NONE;
100423b0:	68fb      	ldr	r3, [r7, #12]
100423b2:	2242      	movs	r2, #66	@ 0x42
100423b4:	2100      	movs	r1, #0
100423b6:	5499      	strb	r1, [r3, r2]

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
100423b8:	68fb      	ldr	r3, [r7, #12]
100423ba:	2240      	movs	r2, #64	@ 0x40
100423bc:	2100      	movs	r1, #0
100423be:	5499      	strb	r1, [r3, r2]

    return HAL_OK;
100423c0:	2300      	movs	r3, #0
100423c2:	e000      	b.n	100423c6 <HAL_I2C_Mem_Write+0x24e>
  }
  else
  {
    return HAL_BUSY;
100423c4:	2302      	movs	r3, #2
  }
}
100423c6:	0018      	movs	r0, r3
100423c8:	46bd      	mov	sp, r7
100423ca:	b007      	add	sp, #28
100423cc:	bd90      	pop	{r4, r7, pc}
100423ce:	46c0      	nop			@ (mov r8, r8)
100423d0:	fe00e800 	.word	0xfe00e800

100423d4 <I2C_RequestMemoryWrite>:
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress,
                                                uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout,
                                                uint32_t Tickstart)
{
100423d4:	b5b0      	push	{r4, r5, r7, lr}
100423d6:	b086      	sub	sp, #24
100423d8:	af02      	add	r7, sp, #8
100423da:	60f8      	str	r0, [r7, #12]
100423dc:	000c      	movs	r4, r1
100423de:	0010      	movs	r0, r2
100423e0:	0019      	movs	r1, r3
100423e2:	250a      	movs	r5, #10
100423e4:	197b      	adds	r3, r7, r5
100423e6:	1c22      	adds	r2, r4, #0
100423e8:	801a      	strh	r2, [r3, #0]
100423ea:	2308      	movs	r3, #8
100423ec:	18fb      	adds	r3, r7, r3
100423ee:	1c02      	adds	r2, r0, #0
100423f0:	801a      	strh	r2, [r3, #0]
100423f2:	1dbb      	adds	r3, r7, #6
100423f4:	1c0a      	adds	r2, r1, #0
100423f6:	801a      	strh	r2, [r3, #0]
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
100423f8:	1dbb      	adds	r3, r7, #6
100423fa:	881b      	ldrh	r3, [r3, #0]
100423fc:	b2da      	uxtb	r2, r3
100423fe:	2380      	movs	r3, #128	@ 0x80
10042400:	045c      	lsls	r4, r3, #17
10042402:	197b      	adds	r3, r7, r5
10042404:	8819      	ldrh	r1, [r3, #0]
10042406:	68f8      	ldr	r0, [r7, #12]
10042408:	4b23      	ldr	r3, [pc, #140]	@ (10042498 <I2C_RequestMemoryWrite+0xc4>)
1004240a:	9300      	str	r3, [sp, #0]
1004240c:	0023      	movs	r3, r4
1004240e:	f000 fa41 	bl	10042894 <I2C_TransferConfig>

  /* Wait until TXIS flag is set */
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
10042412:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
10042414:	6a39      	ldr	r1, [r7, #32]
10042416:	68fb      	ldr	r3, [r7, #12]
10042418:	0018      	movs	r0, r3
1004241a:	f000 f8b9 	bl	10042590 <I2C_WaitOnTXISFlagUntilTimeout>
1004241e:	1e03      	subs	r3, r0, #0
10042420:	d001      	beq.n	10042426 <I2C_RequestMemoryWrite+0x52>
  {
    return HAL_ERROR;
10042422:	2301      	movs	r3, #1
10042424:	e033      	b.n	1004248e <I2C_RequestMemoryWrite+0xba>
  }

  /* If Memory address size is 8Bit */
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
10042426:	1dbb      	adds	r3, r7, #6
10042428:	881b      	ldrh	r3, [r3, #0]
1004242a:	2b01      	cmp	r3, #1
1004242c:	d107      	bne.n	1004243e <I2C_RequestMemoryWrite+0x6a>
  {
    /* Send Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
1004242e:	2308      	movs	r3, #8
10042430:	18fb      	adds	r3, r7, r3
10042432:	881b      	ldrh	r3, [r3, #0]
10042434:	b2da      	uxtb	r2, r3
10042436:	68fb      	ldr	r3, [r7, #12]
10042438:	681b      	ldr	r3, [r3, #0]
1004243a:	629a      	str	r2, [r3, #40]	@ 0x28
1004243c:	e019      	b.n	10042472 <I2C_RequestMemoryWrite+0x9e>
  }
  /* If Memory address size is 16Bit */
  else
  {
    /* Send MSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
1004243e:	2308      	movs	r3, #8
10042440:	18fb      	adds	r3, r7, r3
10042442:	881b      	ldrh	r3, [r3, #0]
10042444:	0a1b      	lsrs	r3, r3, #8
10042446:	b29b      	uxth	r3, r3
10042448:	b2da      	uxtb	r2, r3
1004244a:	68fb      	ldr	r3, [r7, #12]
1004244c:	681b      	ldr	r3, [r3, #0]
1004244e:	629a      	str	r2, [r3, #40]	@ 0x28

    /* Wait until TXIS flag is set */
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
10042450:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
10042452:	6a39      	ldr	r1, [r7, #32]
10042454:	68fb      	ldr	r3, [r7, #12]
10042456:	0018      	movs	r0, r3
10042458:	f000 f89a 	bl	10042590 <I2C_WaitOnTXISFlagUntilTimeout>
1004245c:	1e03      	subs	r3, r0, #0
1004245e:	d001      	beq.n	10042464 <I2C_RequestMemoryWrite+0x90>
    {
      return HAL_ERROR;
10042460:	2301      	movs	r3, #1
10042462:	e014      	b.n	1004248e <I2C_RequestMemoryWrite+0xba>
    }

    /* Send LSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
10042464:	2308      	movs	r3, #8
10042466:	18fb      	adds	r3, r7, r3
10042468:	881b      	ldrh	r3, [r3, #0]
1004246a:	b2da      	uxtb	r2, r3
1004246c:	68fb      	ldr	r3, [r7, #12]
1004246e:	681b      	ldr	r3, [r3, #0]
10042470:	629a      	str	r2, [r3, #40]	@ 0x28
  }

  /* Wait until TCR flag is set */
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, Tickstart) != HAL_OK)
10042472:	6a3a      	ldr	r2, [r7, #32]
10042474:	68f8      	ldr	r0, [r7, #12]
10042476:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10042478:	9300      	str	r3, [sp, #0]
1004247a:	0013      	movs	r3, r2
1004247c:	2200      	movs	r2, #0
1004247e:	2180      	movs	r1, #128	@ 0x80
10042480:	f000 f82e 	bl	100424e0 <I2C_WaitOnFlagUntilTimeout>
10042484:	1e03      	subs	r3, r0, #0
10042486:	d001      	beq.n	1004248c <I2C_RequestMemoryWrite+0xb8>
  {
    return HAL_ERROR;
10042488:	2301      	movs	r3, #1
1004248a:	e000      	b.n	1004248e <I2C_RequestMemoryWrite+0xba>
  }

  return HAL_OK;
1004248c:	2300      	movs	r3, #0
}
1004248e:	0018      	movs	r0, r3
10042490:	46bd      	mov	sp, r7
10042492:	b004      	add	sp, #16
10042494:	bdb0      	pop	{r4, r5, r7, pc}
10042496:	46c0      	nop			@ (mov r8, r8)
10042498:	80002000 	.word	0x80002000

1004249c <I2C_Flush_TXDR>:
  * @brief  I2C Tx data register flush process.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_Flush_TXDR(I2C_HandleTypeDef *hi2c)
{
1004249c:	b580      	push	{r7, lr}
1004249e:	b082      	sub	sp, #8
100424a0:	af00      	add	r7, sp, #0
100424a2:	6078      	str	r0, [r7, #4]
  /* If a pending TXIS flag is set */
  /* Write a dummy data in TXDR to clear it */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
100424a4:	687b      	ldr	r3, [r7, #4]
100424a6:	681b      	ldr	r3, [r3, #0]
100424a8:	699b      	ldr	r3, [r3, #24]
100424aa:	2202      	movs	r2, #2
100424ac:	4013      	ands	r3, r2
100424ae:	2b02      	cmp	r3, #2
100424b0:	d103      	bne.n	100424ba <I2C_Flush_TXDR+0x1e>
  {
    hi2c->Instance->TXDR = 0x00U;
100424b2:	687b      	ldr	r3, [r7, #4]
100424b4:	681b      	ldr	r3, [r3, #0]
100424b6:	2200      	movs	r2, #0
100424b8:	629a      	str	r2, [r3, #40]	@ 0x28
  }

  /* Flush TX register if not empty */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
100424ba:	687b      	ldr	r3, [r7, #4]
100424bc:	681b      	ldr	r3, [r3, #0]
100424be:	699b      	ldr	r3, [r3, #24]
100424c0:	2201      	movs	r2, #1
100424c2:	4013      	ands	r3, r2
100424c4:	2b01      	cmp	r3, #1
100424c6:	d007      	beq.n	100424d8 <I2C_Flush_TXDR+0x3c>
  {
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
100424c8:	687b      	ldr	r3, [r7, #4]
100424ca:	681b      	ldr	r3, [r3, #0]
100424cc:	699a      	ldr	r2, [r3, #24]
100424ce:	687b      	ldr	r3, [r7, #4]
100424d0:	681b      	ldr	r3, [r3, #0]
100424d2:	2101      	movs	r1, #1
100424d4:	430a      	orrs	r2, r1
100424d6:	619a      	str	r2, [r3, #24]
  }
}
100424d8:	46c0      	nop			@ (mov r8, r8)
100424da:	46bd      	mov	sp, r7
100424dc:	b002      	add	sp, #8
100424de:	bd80      	pop	{r7, pc}

100424e0 <I2C_WaitOnFlagUntilTimeout>:
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status,
                                                    uint32_t Timeout, uint32_t Tickstart)
{
100424e0:	b580      	push	{r7, lr}
100424e2:	b084      	sub	sp, #16
100424e4:	af00      	add	r7, sp, #0
100424e6:	60f8      	str	r0, [r7, #12]
100424e8:	60b9      	str	r1, [r7, #8]
100424ea:	603b      	str	r3, [r7, #0]
100424ec:	1dfb      	adds	r3, r7, #7
100424ee:	701a      	strb	r2, [r3, #0]
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
100424f0:	e03a      	b.n	10042568 <I2C_WaitOnFlagUntilTimeout+0x88>
  {
    /* Check if an error is detected */
    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)
100424f2:	69ba      	ldr	r2, [r7, #24]
100424f4:	6839      	ldr	r1, [r7, #0]
100424f6:	68fb      	ldr	r3, [r7, #12]
100424f8:	0018      	movs	r0, r3
100424fa:	f000 f8d3 	bl	100426a4 <I2C_IsErrorOccurred>
100424fe:	1e03      	subs	r3, r0, #0
10042500:	d001      	beq.n	10042506 <I2C_WaitOnFlagUntilTimeout+0x26>
    {
      return HAL_ERROR;
10042502:	2301      	movs	r3, #1
10042504:	e040      	b.n	10042588 <I2C_WaitOnFlagUntilTimeout+0xa8>
    }

    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
10042506:	683b      	ldr	r3, [r7, #0]
10042508:	3301      	adds	r3, #1
1004250a:	d02d      	beq.n	10042568 <I2C_WaitOnFlagUntilTimeout+0x88>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
1004250c:	f7ff faa6 	bl	10041a5c <HAL_GetTick>
10042510:	0002      	movs	r2, r0
10042512:	69bb      	ldr	r3, [r7, #24]
10042514:	1ad3      	subs	r3, r2, r3
10042516:	683a      	ldr	r2, [r7, #0]
10042518:	429a      	cmp	r2, r3
1004251a:	d302      	bcc.n	10042522 <I2C_WaitOnFlagUntilTimeout+0x42>
1004251c:	683b      	ldr	r3, [r7, #0]
1004251e:	2b00      	cmp	r3, #0
10042520:	d122      	bne.n	10042568 <I2C_WaitOnFlagUntilTimeout+0x88>
      {
        if ((__HAL_I2C_GET_FLAG(hi2c, Flag) == Status))
10042522:	68fb      	ldr	r3, [r7, #12]
10042524:	681b      	ldr	r3, [r3, #0]
10042526:	699b      	ldr	r3, [r3, #24]
10042528:	68ba      	ldr	r2, [r7, #8]
1004252a:	4013      	ands	r3, r2
1004252c:	68ba      	ldr	r2, [r7, #8]
1004252e:	1ad3      	subs	r3, r2, r3
10042530:	425a      	negs	r2, r3
10042532:	4153      	adcs	r3, r2
10042534:	b2db      	uxtb	r3, r3
10042536:	001a      	movs	r2, r3
10042538:	1dfb      	adds	r3, r7, #7
1004253a:	781b      	ldrb	r3, [r3, #0]
1004253c:	429a      	cmp	r2, r3
1004253e:	d113      	bne.n	10042568 <I2C_WaitOnFlagUntilTimeout+0x88>
        {
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
10042540:	68fb      	ldr	r3, [r7, #12]
10042542:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
10042544:	2220      	movs	r2, #32
10042546:	431a      	orrs	r2, r3
10042548:	68fb      	ldr	r3, [r7, #12]
1004254a:	645a      	str	r2, [r3, #68]	@ 0x44
          hi2c->State = HAL_I2C_STATE_READY;
1004254c:	68fb      	ldr	r3, [r7, #12]
1004254e:	2241      	movs	r2, #65	@ 0x41
10042550:	2120      	movs	r1, #32
10042552:	5499      	strb	r1, [r3, r2]
          hi2c->Mode = HAL_I2C_MODE_NONE;
10042554:	68fb      	ldr	r3, [r7, #12]
10042556:	2242      	movs	r2, #66	@ 0x42
10042558:	2100      	movs	r1, #0
1004255a:	5499      	strb	r1, [r3, r2]

          /* Process Unlocked */
          __HAL_UNLOCK(hi2c);
1004255c:	68fb      	ldr	r3, [r7, #12]
1004255e:	2240      	movs	r2, #64	@ 0x40
10042560:	2100      	movs	r1, #0
10042562:	5499      	strb	r1, [r3, r2]
          return HAL_ERROR;
10042564:	2301      	movs	r3, #1
10042566:	e00f      	b.n	10042588 <I2C_WaitOnFlagUntilTimeout+0xa8>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
10042568:	68fb      	ldr	r3, [r7, #12]
1004256a:	681b      	ldr	r3, [r3, #0]
1004256c:	699b      	ldr	r3, [r3, #24]
1004256e:	68ba      	ldr	r2, [r7, #8]
10042570:	4013      	ands	r3, r2
10042572:	68ba      	ldr	r2, [r7, #8]
10042574:	1ad3      	subs	r3, r2, r3
10042576:	425a      	negs	r2, r3
10042578:	4153      	adcs	r3, r2
1004257a:	b2db      	uxtb	r3, r3
1004257c:	001a      	movs	r2, r3
1004257e:	1dfb      	adds	r3, r7, #7
10042580:	781b      	ldrb	r3, [r3, #0]
10042582:	429a      	cmp	r2, r3
10042584:	d0b5      	beq.n	100424f2 <I2C_WaitOnFlagUntilTimeout+0x12>
        }
      }
    }
  }
  return HAL_OK;
10042586:	2300      	movs	r3, #0
}
10042588:	0018      	movs	r0, r3
1004258a:	46bd      	mov	sp, r7
1004258c:	b004      	add	sp, #16
1004258e:	bd80      	pop	{r7, pc}

10042590 <I2C_WaitOnTXISFlagUntilTimeout>:
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnTXISFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout,
                                                        uint32_t Tickstart)
{
10042590:	b580      	push	{r7, lr}
10042592:	b084      	sub	sp, #16
10042594:	af00      	add	r7, sp, #0
10042596:	60f8      	str	r0, [r7, #12]
10042598:	60b9      	str	r1, [r7, #8]
1004259a:	607a      	str	r2, [r7, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
1004259c:	e032      	b.n	10042604 <I2C_WaitOnTXISFlagUntilTimeout+0x74>
  {
    /* Check if an error is detected */
    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)
1004259e:	687a      	ldr	r2, [r7, #4]
100425a0:	68b9      	ldr	r1, [r7, #8]
100425a2:	68fb      	ldr	r3, [r7, #12]
100425a4:	0018      	movs	r0, r3
100425a6:	f000 f87d 	bl	100426a4 <I2C_IsErrorOccurred>
100425aa:	1e03      	subs	r3, r0, #0
100425ac:	d001      	beq.n	100425b2 <I2C_WaitOnTXISFlagUntilTimeout+0x22>
    {
      return HAL_ERROR;
100425ae:	2301      	movs	r3, #1
100425b0:	e030      	b.n	10042614 <I2C_WaitOnTXISFlagUntilTimeout+0x84>
    }

    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
100425b2:	68bb      	ldr	r3, [r7, #8]
100425b4:	3301      	adds	r3, #1
100425b6:	d025      	beq.n	10042604 <I2C_WaitOnTXISFlagUntilTimeout+0x74>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
100425b8:	f7ff fa50 	bl	10041a5c <HAL_GetTick>
100425bc:	0002      	movs	r2, r0
100425be:	687b      	ldr	r3, [r7, #4]
100425c0:	1ad3      	subs	r3, r2, r3
100425c2:	68ba      	ldr	r2, [r7, #8]
100425c4:	429a      	cmp	r2, r3
100425c6:	d302      	bcc.n	100425ce <I2C_WaitOnTXISFlagUntilTimeout+0x3e>
100425c8:	68bb      	ldr	r3, [r7, #8]
100425ca:	2b00      	cmp	r3, #0
100425cc:	d11a      	bne.n	10042604 <I2C_WaitOnTXISFlagUntilTimeout+0x74>
      {
        if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET))
100425ce:	68fb      	ldr	r3, [r7, #12]
100425d0:	681b      	ldr	r3, [r3, #0]
100425d2:	699b      	ldr	r3, [r3, #24]
100425d4:	2202      	movs	r2, #2
100425d6:	4013      	ands	r3, r2
100425d8:	2b02      	cmp	r3, #2
100425da:	d013      	beq.n	10042604 <I2C_WaitOnTXISFlagUntilTimeout+0x74>
        {
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
100425dc:	68fb      	ldr	r3, [r7, #12]
100425de:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
100425e0:	2220      	movs	r2, #32
100425e2:	431a      	orrs	r2, r3
100425e4:	68fb      	ldr	r3, [r7, #12]
100425e6:	645a      	str	r2, [r3, #68]	@ 0x44
          hi2c->State = HAL_I2C_STATE_READY;
100425e8:	68fb      	ldr	r3, [r7, #12]
100425ea:	2241      	movs	r2, #65	@ 0x41
100425ec:	2120      	movs	r1, #32
100425ee:	5499      	strb	r1, [r3, r2]
          hi2c->Mode = HAL_I2C_MODE_NONE;
100425f0:	68fb      	ldr	r3, [r7, #12]
100425f2:	2242      	movs	r2, #66	@ 0x42
100425f4:	2100      	movs	r1, #0
100425f6:	5499      	strb	r1, [r3, r2]

          /* Process Unlocked */
          __HAL_UNLOCK(hi2c);
100425f8:	68fb      	ldr	r3, [r7, #12]
100425fa:	2240      	movs	r2, #64	@ 0x40
100425fc:	2100      	movs	r1, #0
100425fe:	5499      	strb	r1, [r3, r2]

          return HAL_ERROR;
10042600:	2301      	movs	r3, #1
10042602:	e007      	b.n	10042614 <I2C_WaitOnTXISFlagUntilTimeout+0x84>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
10042604:	68fb      	ldr	r3, [r7, #12]
10042606:	681b      	ldr	r3, [r3, #0]
10042608:	699b      	ldr	r3, [r3, #24]
1004260a:	2202      	movs	r2, #2
1004260c:	4013      	ands	r3, r2
1004260e:	2b02      	cmp	r3, #2
10042610:	d1c5      	bne.n	1004259e <I2C_WaitOnTXISFlagUntilTimeout+0xe>
        }
      }
    }
  }
  return HAL_OK;
10042612:	2300      	movs	r3, #0
}
10042614:	0018      	movs	r0, r3
10042616:	46bd      	mov	sp, r7
10042618:	b004      	add	sp, #16
1004261a:	bd80      	pop	{r7, pc}

1004261c <I2C_WaitOnSTOPFlagUntilTimeout>:
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnSTOPFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout,
                                                        uint32_t Tickstart)
{
1004261c:	b580      	push	{r7, lr}
1004261e:	b084      	sub	sp, #16
10042620:	af00      	add	r7, sp, #0
10042622:	60f8      	str	r0, [r7, #12]
10042624:	60b9      	str	r1, [r7, #8]
10042626:	607a      	str	r2, [r7, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
10042628:	e02f      	b.n	1004268a <I2C_WaitOnSTOPFlagUntilTimeout+0x6e>
  {
    /* Check if an error is detected */
    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)
1004262a:	687a      	ldr	r2, [r7, #4]
1004262c:	68b9      	ldr	r1, [r7, #8]
1004262e:	68fb      	ldr	r3, [r7, #12]
10042630:	0018      	movs	r0, r3
10042632:	f000 f837 	bl	100426a4 <I2C_IsErrorOccurred>
10042636:	1e03      	subs	r3, r0, #0
10042638:	d001      	beq.n	1004263e <I2C_WaitOnSTOPFlagUntilTimeout+0x22>
    {
      return HAL_ERROR;
1004263a:	2301      	movs	r3, #1
1004263c:	e02d      	b.n	1004269a <I2C_WaitOnSTOPFlagUntilTimeout+0x7e>
    }

    /* Check for the Timeout */
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
1004263e:	f7ff fa0d 	bl	10041a5c <HAL_GetTick>
10042642:	0002      	movs	r2, r0
10042644:	687b      	ldr	r3, [r7, #4]
10042646:	1ad3      	subs	r3, r2, r3
10042648:	68ba      	ldr	r2, [r7, #8]
1004264a:	429a      	cmp	r2, r3
1004264c:	d302      	bcc.n	10042654 <I2C_WaitOnSTOPFlagUntilTimeout+0x38>
1004264e:	68bb      	ldr	r3, [r7, #8]
10042650:	2b00      	cmp	r3, #0
10042652:	d11a      	bne.n	1004268a <I2C_WaitOnSTOPFlagUntilTimeout+0x6e>
    {
      if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET))
10042654:	68fb      	ldr	r3, [r7, #12]
10042656:	681b      	ldr	r3, [r3, #0]
10042658:	699b      	ldr	r3, [r3, #24]
1004265a:	2220      	movs	r2, #32
1004265c:	4013      	ands	r3, r2
1004265e:	2b20      	cmp	r3, #32
10042660:	d013      	beq.n	1004268a <I2C_WaitOnSTOPFlagUntilTimeout+0x6e>
      {
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
10042662:	68fb      	ldr	r3, [r7, #12]
10042664:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
10042666:	2220      	movs	r2, #32
10042668:	431a      	orrs	r2, r3
1004266a:	68fb      	ldr	r3, [r7, #12]
1004266c:	645a      	str	r2, [r3, #68]	@ 0x44
        hi2c->State = HAL_I2C_STATE_READY;
1004266e:	68fb      	ldr	r3, [r7, #12]
10042670:	2241      	movs	r2, #65	@ 0x41
10042672:	2120      	movs	r1, #32
10042674:	5499      	strb	r1, [r3, r2]
        hi2c->Mode = HAL_I2C_MODE_NONE;
10042676:	68fb      	ldr	r3, [r7, #12]
10042678:	2242      	movs	r2, #66	@ 0x42
1004267a:	2100      	movs	r1, #0
1004267c:	5499      	strb	r1, [r3, r2]

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
1004267e:	68fb      	ldr	r3, [r7, #12]
10042680:	2240      	movs	r2, #64	@ 0x40
10042682:	2100      	movs	r1, #0
10042684:	5499      	strb	r1, [r3, r2]

        return HAL_ERROR;
10042686:	2301      	movs	r3, #1
10042688:	e007      	b.n	1004269a <I2C_WaitOnSTOPFlagUntilTimeout+0x7e>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
1004268a:	68fb      	ldr	r3, [r7, #12]
1004268c:	681b      	ldr	r3, [r3, #0]
1004268e:	699b      	ldr	r3, [r3, #24]
10042690:	2220      	movs	r2, #32
10042692:	4013      	ands	r3, r2
10042694:	2b20      	cmp	r3, #32
10042696:	d1c8      	bne.n	1004262a <I2C_WaitOnSTOPFlagUntilTimeout+0xe>
      }
    }
  }
  return HAL_OK;
10042698:	2300      	movs	r3, #0
}
1004269a:	0018      	movs	r0, r3
1004269c:	46bd      	mov	sp, r7
1004269e:	b004      	add	sp, #16
100426a0:	bd80      	pop	{r7, pc}
	...

100426a4 <I2C_IsErrorOccurred>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_IsErrorOccurred(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
100426a4:	b580      	push	{r7, lr}
100426a6:	b08a      	sub	sp, #40	@ 0x28
100426a8:	af00      	add	r7, sp, #0
100426aa:	60f8      	str	r0, [r7, #12]
100426ac:	60b9      	str	r1, [r7, #8]
100426ae:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
100426b0:	2327      	movs	r3, #39	@ 0x27
100426b2:	18fb      	adds	r3, r7, r3
100426b4:	2200      	movs	r2, #0
100426b6:	701a      	strb	r2, [r3, #0]
  uint32_t itflag   = hi2c->Instance->ISR;
100426b8:	68fb      	ldr	r3, [r7, #12]
100426ba:	681b      	ldr	r3, [r3, #0]
100426bc:	699b      	ldr	r3, [r3, #24]
100426be:	61bb      	str	r3, [r7, #24]
  uint32_t error_code = 0;
100426c0:	2300      	movs	r3, #0
100426c2:	623b      	str	r3, [r7, #32]
  uint32_t tickstart = Tickstart;
100426c4:	687b      	ldr	r3, [r7, #4]
100426c6:	61fb      	str	r3, [r7, #28]
  uint32_t tmp1;
  HAL_I2C_ModeTypeDef tmp2;

  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_AF))
100426c8:	69bb      	ldr	r3, [r7, #24]
100426ca:	2210      	movs	r2, #16
100426cc:	4013      	ands	r3, r2
100426ce:	d100      	bne.n	100426d2 <I2C_IsErrorOccurred+0x2e>
100426d0:	e079      	b.n	100427c6 <I2C_IsErrorOccurred+0x122>
  {
    /* Clear NACKF Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
100426d2:	68fb      	ldr	r3, [r7, #12]
100426d4:	681b      	ldr	r3, [r3, #0]
100426d6:	2210      	movs	r2, #16
100426d8:	61da      	str	r2, [r3, #28]

    /* Wait until STOP Flag is set or timeout occurred */
    /* AutoEnd should be initiate after AF */
    while ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (status == HAL_OK))
100426da:	e057      	b.n	1004278c <I2C_IsErrorOccurred+0xe8>
100426dc:	2227      	movs	r2, #39	@ 0x27
100426de:	18bb      	adds	r3, r7, r2
100426e0:	18ba      	adds	r2, r7, r2
100426e2:	7812      	ldrb	r2, [r2, #0]
100426e4:	701a      	strb	r2, [r3, #0]
    {
      /* Check for the Timeout */
      if (Timeout != HAL_MAX_DELAY)
100426e6:	68bb      	ldr	r3, [r7, #8]
100426e8:	3301      	adds	r3, #1
100426ea:	d04f      	beq.n	1004278c <I2C_IsErrorOccurred+0xe8>
      {
        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
100426ec:	f7ff f9b6 	bl	10041a5c <HAL_GetTick>
100426f0:	0002      	movs	r2, r0
100426f2:	69fb      	ldr	r3, [r7, #28]
100426f4:	1ad3      	subs	r3, r2, r3
100426f6:	68ba      	ldr	r2, [r7, #8]
100426f8:	429a      	cmp	r2, r3
100426fa:	d302      	bcc.n	10042702 <I2C_IsErrorOccurred+0x5e>
100426fc:	68bb      	ldr	r3, [r7, #8]
100426fe:	2b00      	cmp	r3, #0
10042700:	d144      	bne.n	1004278c <I2C_IsErrorOccurred+0xe8>
        {
          tmp1 = (uint32_t)(hi2c->Instance->CR2 & I2C_CR2_STOP);
10042702:	68fb      	ldr	r3, [r7, #12]
10042704:	681b      	ldr	r3, [r3, #0]
10042706:	685a      	ldr	r2, [r3, #4]
10042708:	2380      	movs	r3, #128	@ 0x80
1004270a:	01db      	lsls	r3, r3, #7
1004270c:	4013      	ands	r3, r2
1004270e:	617b      	str	r3, [r7, #20]
          tmp2 = hi2c->Mode;
10042710:	2013      	movs	r0, #19
10042712:	183b      	adds	r3, r7, r0
10042714:	68fa      	ldr	r2, [r7, #12]
10042716:	2142      	movs	r1, #66	@ 0x42
10042718:	5c52      	ldrb	r2, [r2, r1]
1004271a:	701a      	strb	r2, [r3, #0]

          /* In case of I2C still busy, try to regenerate a STOP manually */
          if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET) && \
1004271c:	68fb      	ldr	r3, [r7, #12]
1004271e:	681b      	ldr	r3, [r3, #0]
10042720:	699a      	ldr	r2, [r3, #24]
10042722:	2380      	movs	r3, #128	@ 0x80
10042724:	021b      	lsls	r3, r3, #8
10042726:	401a      	ands	r2, r3
10042728:	2380      	movs	r3, #128	@ 0x80
1004272a:	021b      	lsls	r3, r3, #8
1004272c:	429a      	cmp	r2, r3
1004272e:	d126      	bne.n	1004277e <I2C_IsErrorOccurred+0xda>
10042730:	697a      	ldr	r2, [r7, #20]
10042732:	2380      	movs	r3, #128	@ 0x80
10042734:	01db      	lsls	r3, r3, #7
10042736:	429a      	cmp	r2, r3
10042738:	d021      	beq.n	1004277e <I2C_IsErrorOccurred+0xda>
              (tmp1 != I2C_CR2_STOP) && \
1004273a:	183b      	adds	r3, r7, r0
1004273c:	781b      	ldrb	r3, [r3, #0]
1004273e:	2b20      	cmp	r3, #32
10042740:	d01d      	beq.n	1004277e <I2C_IsErrorOccurred+0xda>
              (tmp2 != HAL_I2C_MODE_SLAVE))
          {
            /* Generate Stop */
            hi2c->Instance->CR2 |= I2C_CR2_STOP;
10042742:	68fb      	ldr	r3, [r7, #12]
10042744:	681b      	ldr	r3, [r3, #0]
10042746:	685a      	ldr	r2, [r3, #4]
10042748:	68fb      	ldr	r3, [r7, #12]
1004274a:	681b      	ldr	r3, [r3, #0]
1004274c:	2180      	movs	r1, #128	@ 0x80
1004274e:	01c9      	lsls	r1, r1, #7
10042750:	430a      	orrs	r2, r1
10042752:	605a      	str	r2, [r3, #4]

            /* Update Tick with new reference */
            tickstart = HAL_GetTick();
10042754:	f7ff f982 	bl	10041a5c <HAL_GetTick>
10042758:	0003      	movs	r3, r0
1004275a:	61fb      	str	r3, [r7, #28]
          }

          while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
1004275c:	e00f      	b.n	1004277e <I2C_IsErrorOccurred+0xda>
          {
            /* Check for the Timeout */
            if ((HAL_GetTick() - tickstart) > I2C_TIMEOUT_STOPF)
1004275e:	f7ff f97d 	bl	10041a5c <HAL_GetTick>
10042762:	0002      	movs	r2, r0
10042764:	69fb      	ldr	r3, [r7, #28]
10042766:	1ad3      	subs	r3, r2, r3
10042768:	2b19      	cmp	r3, #25
1004276a:	d908      	bls.n	1004277e <I2C_IsErrorOccurred+0xda>
            {
              error_code |= HAL_I2C_ERROR_TIMEOUT;
1004276c:	6a3b      	ldr	r3, [r7, #32]
1004276e:	2220      	movs	r2, #32
10042770:	4313      	orrs	r3, r2
10042772:	623b      	str	r3, [r7, #32]

              status = HAL_ERROR;
10042774:	2327      	movs	r3, #39	@ 0x27
10042776:	18fb      	adds	r3, r7, r3
10042778:	2201      	movs	r2, #1
1004277a:	701a      	strb	r2, [r3, #0]

              break;
1004277c:	e006      	b.n	1004278c <I2C_IsErrorOccurred+0xe8>
          while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
1004277e:	68fb      	ldr	r3, [r7, #12]
10042780:	681b      	ldr	r3, [r3, #0]
10042782:	699b      	ldr	r3, [r3, #24]
10042784:	2220      	movs	r2, #32
10042786:	4013      	ands	r3, r2
10042788:	2b20      	cmp	r3, #32
1004278a:	d1e8      	bne.n	1004275e <I2C_IsErrorOccurred+0xba>
    while ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (status == HAL_OK))
1004278c:	68fb      	ldr	r3, [r7, #12]
1004278e:	681b      	ldr	r3, [r3, #0]
10042790:	699b      	ldr	r3, [r3, #24]
10042792:	2220      	movs	r2, #32
10042794:	4013      	ands	r3, r2
10042796:	2b20      	cmp	r3, #32
10042798:	d004      	beq.n	100427a4 <I2C_IsErrorOccurred+0x100>
1004279a:	2327      	movs	r3, #39	@ 0x27
1004279c:	18fb      	adds	r3, r7, r3
1004279e:	781b      	ldrb	r3, [r3, #0]
100427a0:	2b00      	cmp	r3, #0
100427a2:	d09b      	beq.n	100426dc <I2C_IsErrorOccurred+0x38>
        }
      }
    }

    /* In case STOP Flag is detected, clear it */
    if (status == HAL_OK)
100427a4:	2327      	movs	r3, #39	@ 0x27
100427a6:	18fb      	adds	r3, r7, r3
100427a8:	781b      	ldrb	r3, [r3, #0]
100427aa:	2b00      	cmp	r3, #0
100427ac:	d103      	bne.n	100427b6 <I2C_IsErrorOccurred+0x112>
    {
      /* Clear STOP Flag */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
100427ae:	68fb      	ldr	r3, [r7, #12]
100427b0:	681b      	ldr	r3, [r3, #0]
100427b2:	2220      	movs	r2, #32
100427b4:	61da      	str	r2, [r3, #28]
    }

    error_code |= HAL_I2C_ERROR_AF;
100427b6:	6a3b      	ldr	r3, [r7, #32]
100427b8:	2204      	movs	r2, #4
100427ba:	4313      	orrs	r3, r2
100427bc:	623b      	str	r3, [r7, #32]

    status = HAL_ERROR;
100427be:	2327      	movs	r3, #39	@ 0x27
100427c0:	18fb      	adds	r3, r7, r3
100427c2:	2201      	movs	r2, #1
100427c4:	701a      	strb	r2, [r3, #0]
  }

  /* Refresh Content of Status register */
  itflag = hi2c->Instance->ISR;
100427c6:	68fb      	ldr	r3, [r7, #12]
100427c8:	681b      	ldr	r3, [r3, #0]
100427ca:	699b      	ldr	r3, [r3, #24]
100427cc:	61bb      	str	r3, [r7, #24]

  /* Then verify if an additional errors occurs */
  /* Check if a Bus error occurred */
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_BERR))
100427ce:	69ba      	ldr	r2, [r7, #24]
100427d0:	2380      	movs	r3, #128	@ 0x80
100427d2:	005b      	lsls	r3, r3, #1
100427d4:	4013      	ands	r3, r2
100427d6:	d00c      	beq.n	100427f2 <I2C_IsErrorOccurred+0x14e>
  {
    error_code |= HAL_I2C_ERROR_BERR;
100427d8:	6a3b      	ldr	r3, [r7, #32]
100427da:	2201      	movs	r2, #1
100427dc:	4313      	orrs	r3, r2
100427de:	623b      	str	r3, [r7, #32]

    /* Clear BERR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
100427e0:	68fb      	ldr	r3, [r7, #12]
100427e2:	681b      	ldr	r3, [r3, #0]
100427e4:	2280      	movs	r2, #128	@ 0x80
100427e6:	0052      	lsls	r2, r2, #1
100427e8:	61da      	str	r2, [r3, #28]

    status = HAL_ERROR;
100427ea:	2327      	movs	r3, #39	@ 0x27
100427ec:	18fb      	adds	r3, r7, r3
100427ee:	2201      	movs	r2, #1
100427f0:	701a      	strb	r2, [r3, #0]
  }

  /* Check if an Over-Run/Under-Run error occurred */
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_OVR))
100427f2:	69ba      	ldr	r2, [r7, #24]
100427f4:	2380      	movs	r3, #128	@ 0x80
100427f6:	00db      	lsls	r3, r3, #3
100427f8:	4013      	ands	r3, r2
100427fa:	d00c      	beq.n	10042816 <I2C_IsErrorOccurred+0x172>
  {
    error_code |= HAL_I2C_ERROR_OVR;
100427fc:	6a3b      	ldr	r3, [r7, #32]
100427fe:	2208      	movs	r2, #8
10042800:	4313      	orrs	r3, r2
10042802:	623b      	str	r3, [r7, #32]

    /* Clear OVR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
10042804:	68fb      	ldr	r3, [r7, #12]
10042806:	681b      	ldr	r3, [r3, #0]
10042808:	2280      	movs	r2, #128	@ 0x80
1004280a:	00d2      	lsls	r2, r2, #3
1004280c:	61da      	str	r2, [r3, #28]

    status = HAL_ERROR;
1004280e:	2327      	movs	r3, #39	@ 0x27
10042810:	18fb      	adds	r3, r7, r3
10042812:	2201      	movs	r2, #1
10042814:	701a      	strb	r2, [r3, #0]
  }

  /* Check if an Arbitration Loss error occurred */
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_ARLO))
10042816:	69ba      	ldr	r2, [r7, #24]
10042818:	2380      	movs	r3, #128	@ 0x80
1004281a:	009b      	lsls	r3, r3, #2
1004281c:	4013      	ands	r3, r2
1004281e:	d00c      	beq.n	1004283a <I2C_IsErrorOccurred+0x196>
  {
    error_code |= HAL_I2C_ERROR_ARLO;
10042820:	6a3b      	ldr	r3, [r7, #32]
10042822:	2202      	movs	r2, #2
10042824:	4313      	orrs	r3, r2
10042826:	623b      	str	r3, [r7, #32]

    /* Clear ARLO flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
10042828:	68fb      	ldr	r3, [r7, #12]
1004282a:	681b      	ldr	r3, [r3, #0]
1004282c:	2280      	movs	r2, #128	@ 0x80
1004282e:	0092      	lsls	r2, r2, #2
10042830:	61da      	str	r2, [r3, #28]

    status = HAL_ERROR;
10042832:	2327      	movs	r3, #39	@ 0x27
10042834:	18fb      	adds	r3, r7, r3
10042836:	2201      	movs	r2, #1
10042838:	701a      	strb	r2, [r3, #0]
  }

  if (status != HAL_OK)
1004283a:	2327      	movs	r3, #39	@ 0x27
1004283c:	18fb      	adds	r3, r7, r3
1004283e:	781b      	ldrb	r3, [r3, #0]
10042840:	2b00      	cmp	r3, #0
10042842:	d01d      	beq.n	10042880 <I2C_IsErrorOccurred+0x1dc>
  {
    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);
10042844:	68fb      	ldr	r3, [r7, #12]
10042846:	0018      	movs	r0, r3
10042848:	f7ff fe28 	bl	1004249c <I2C_Flush_TXDR>

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
1004284c:	68fb      	ldr	r3, [r7, #12]
1004284e:	681b      	ldr	r3, [r3, #0]
10042850:	685a      	ldr	r2, [r3, #4]
10042852:	68fb      	ldr	r3, [r7, #12]
10042854:	681b      	ldr	r3, [r3, #0]
10042856:	490e      	ldr	r1, [pc, #56]	@ (10042890 <I2C_IsErrorOccurred+0x1ec>)
10042858:	400a      	ands	r2, r1
1004285a:	605a      	str	r2, [r3, #4]

    hi2c->ErrorCode |= error_code;
1004285c:	68fb      	ldr	r3, [r7, #12]
1004285e:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
10042860:	6a3b      	ldr	r3, [r7, #32]
10042862:	431a      	orrs	r2, r3
10042864:	68fb      	ldr	r3, [r7, #12]
10042866:	645a      	str	r2, [r3, #68]	@ 0x44
    hi2c->State = HAL_I2C_STATE_READY;
10042868:	68fb      	ldr	r3, [r7, #12]
1004286a:	2241      	movs	r2, #65	@ 0x41
1004286c:	2120      	movs	r1, #32
1004286e:	5499      	strb	r1, [r3, r2]
    hi2c->Mode = HAL_I2C_MODE_NONE;
10042870:	68fb      	ldr	r3, [r7, #12]
10042872:	2242      	movs	r2, #66	@ 0x42
10042874:	2100      	movs	r1, #0
10042876:	5499      	strb	r1, [r3, r2]

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
10042878:	68fb      	ldr	r3, [r7, #12]
1004287a:	2240      	movs	r2, #64	@ 0x40
1004287c:	2100      	movs	r1, #0
1004287e:	5499      	strb	r1, [r3, r2]
  }

  return status;
10042880:	2327      	movs	r3, #39	@ 0x27
10042882:	18fb      	adds	r3, r7, r3
10042884:	781b      	ldrb	r3, [r3, #0]
}
10042886:	0018      	movs	r0, r3
10042888:	46bd      	mov	sp, r7
1004288a:	b00a      	add	sp, #40	@ 0x28
1004288c:	bd80      	pop	{r7, pc}
1004288e:	46c0      	nop			@ (mov r8, r8)
10042890:	fe00e800 	.word	0xfe00e800

10042894 <I2C_TransferConfig>:
  *     @arg @ref I2C_GENERATE_START_WRITE Generate Restart for write request.
  * @retval None
  */
static void I2C_TransferConfig(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t Size, uint32_t Mode,
                               uint32_t Request)
{
10042894:	b590      	push	{r4, r7, lr}
10042896:	b087      	sub	sp, #28
10042898:	af00      	add	r7, sp, #0
1004289a:	60f8      	str	r0, [r7, #12]
1004289c:	0008      	movs	r0, r1
1004289e:	0011      	movs	r1, r2
100428a0:	607b      	str	r3, [r7, #4]
100428a2:	240a      	movs	r4, #10
100428a4:	193b      	adds	r3, r7, r4
100428a6:	1c02      	adds	r2, r0, #0
100428a8:	801a      	strh	r2, [r3, #0]
100428aa:	2009      	movs	r0, #9
100428ac:	183b      	adds	r3, r7, r0
100428ae:	1c0a      	adds	r2, r1, #0
100428b0:	701a      	strb	r2, [r3, #0]
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));

  /* Declaration of tmp to prevent undefined behavior of volatile usage */
  tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
100428b2:	193b      	adds	r3, r7, r4
100428b4:	881b      	ldrh	r3, [r3, #0]
100428b6:	059b      	lsls	r3, r3, #22
100428b8:	0d9a      	lsrs	r2, r3, #22
                    (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | \
100428ba:	183b      	adds	r3, r7, r0
100428bc:	781b      	ldrb	r3, [r3, #0]
100428be:	0419      	lsls	r1, r3, #16
100428c0:	23ff      	movs	r3, #255	@ 0xff
100428c2:	041b      	lsls	r3, r3, #16
100428c4:	400b      	ands	r3, r1
  tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
100428c6:	431a      	orrs	r2, r3
                    (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | \
100428c8:	687b      	ldr	r3, [r7, #4]
100428ca:	431a      	orrs	r2, r3
  tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
100428cc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
100428ce:	4313      	orrs	r3, r2
100428d0:	005b      	lsls	r3, r3, #1
100428d2:	085b      	lsrs	r3, r3, #1
100428d4:	617b      	str	r3, [r7, #20]
                    (uint32_t)Mode | (uint32_t)Request) & (~0x80000000U));

  /* update CR2 register */
  MODIFY_REG(hi2c->Instance->CR2, \
100428d6:	68fb      	ldr	r3, [r7, #12]
100428d8:	681b      	ldr	r3, [r3, #0]
100428da:	685b      	ldr	r3, [r3, #4]
100428dc:	6aba      	ldr	r2, [r7, #40]	@ 0x28
100428de:	0d51      	lsrs	r1, r2, #21
100428e0:	2280      	movs	r2, #128	@ 0x80
100428e2:	00d2      	lsls	r2, r2, #3
100428e4:	400a      	ands	r2, r1
100428e6:	4907      	ldr	r1, [pc, #28]	@ (10042904 <I2C_TransferConfig+0x70>)
100428e8:	430a      	orrs	r2, r1
100428ea:	43d2      	mvns	r2, r2
100428ec:	401a      	ands	r2, r3
100428ee:	0011      	movs	r1, r2
100428f0:	68fb      	ldr	r3, [r7, #12]
100428f2:	681b      	ldr	r3, [r3, #0]
100428f4:	697a      	ldr	r2, [r7, #20]
100428f6:	430a      	orrs	r2, r1
100428f8:	605a      	str	r2, [r3, #4]
             ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | \
               (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | \
               I2C_CR2_START | I2C_CR2_STOP)), tmp);
}
100428fa:	46c0      	nop			@ (mov r8, r8)
100428fc:	46bd      	mov	sp, r7
100428fe:	b007      	add	sp, #28
10042900:	bd90      	pop	{r4, r7, pc}
10042902:	46c0      	nop			@ (mov r8, r8)
10042904:	03ff63ff 	.word	0x03ff63ff

10042908 <HAL_I2CEx_ConfigAnalogFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  AnalogFilter New state of the Analog filter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigAnalogFilter(I2C_HandleTypeDef *hi2c, uint32_t AnalogFilter)
{
10042908:	b580      	push	{r7, lr}
1004290a:	b082      	sub	sp, #8
1004290c:	af00      	add	r7, sp, #0
1004290e:	6078      	str	r0, [r7, #4]
10042910:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
10042912:	687b      	ldr	r3, [r7, #4]
10042914:	2241      	movs	r2, #65	@ 0x41
10042916:	5c9b      	ldrb	r3, [r3, r2]
10042918:	b2db      	uxtb	r3, r3
1004291a:	2b20      	cmp	r3, #32
1004291c:	d138      	bne.n	10042990 <HAL_I2CEx_ConfigAnalogFilter+0x88>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
1004291e:	687b      	ldr	r3, [r7, #4]
10042920:	2240      	movs	r2, #64	@ 0x40
10042922:	5c9b      	ldrb	r3, [r3, r2]
10042924:	2b01      	cmp	r3, #1
10042926:	d101      	bne.n	1004292c <HAL_I2CEx_ConfigAnalogFilter+0x24>
10042928:	2302      	movs	r3, #2
1004292a:	e032      	b.n	10042992 <HAL_I2CEx_ConfigAnalogFilter+0x8a>
1004292c:	687b      	ldr	r3, [r7, #4]
1004292e:	2240      	movs	r2, #64	@ 0x40
10042930:	2101      	movs	r1, #1
10042932:	5499      	strb	r1, [r3, r2]

    hi2c->State = HAL_I2C_STATE_BUSY;
10042934:	687b      	ldr	r3, [r7, #4]
10042936:	2241      	movs	r2, #65	@ 0x41
10042938:	2124      	movs	r1, #36	@ 0x24
1004293a:	5499      	strb	r1, [r3, r2]

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
1004293c:	687b      	ldr	r3, [r7, #4]
1004293e:	681b      	ldr	r3, [r3, #0]
10042940:	681a      	ldr	r2, [r3, #0]
10042942:	687b      	ldr	r3, [r7, #4]
10042944:	681b      	ldr	r3, [r3, #0]
10042946:	2101      	movs	r1, #1
10042948:	438a      	bics	r2, r1
1004294a:	601a      	str	r2, [r3, #0]

    /* Reset I2Cx ANOFF bit */
    hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);
1004294c:	687b      	ldr	r3, [r7, #4]
1004294e:	681b      	ldr	r3, [r3, #0]
10042950:	681a      	ldr	r2, [r3, #0]
10042952:	687b      	ldr	r3, [r7, #4]
10042954:	681b      	ldr	r3, [r3, #0]
10042956:	4911      	ldr	r1, [pc, #68]	@ (1004299c <HAL_I2CEx_ConfigAnalogFilter+0x94>)
10042958:	400a      	ands	r2, r1
1004295a:	601a      	str	r2, [r3, #0]

    /* Set analog filter bit*/
    hi2c->Instance->CR1 |= AnalogFilter;
1004295c:	687b      	ldr	r3, [r7, #4]
1004295e:	681b      	ldr	r3, [r3, #0]
10042960:	6819      	ldr	r1, [r3, #0]
10042962:	687b      	ldr	r3, [r7, #4]
10042964:	681b      	ldr	r3, [r3, #0]
10042966:	683a      	ldr	r2, [r7, #0]
10042968:	430a      	orrs	r2, r1
1004296a:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
1004296c:	687b      	ldr	r3, [r7, #4]
1004296e:	681b      	ldr	r3, [r3, #0]
10042970:	681a      	ldr	r2, [r3, #0]
10042972:	687b      	ldr	r3, [r7, #4]
10042974:	681b      	ldr	r3, [r3, #0]
10042976:	2101      	movs	r1, #1
10042978:	430a      	orrs	r2, r1
1004297a:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
1004297c:	687b      	ldr	r3, [r7, #4]
1004297e:	2241      	movs	r2, #65	@ 0x41
10042980:	2120      	movs	r1, #32
10042982:	5499      	strb	r1, [r3, r2]

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
10042984:	687b      	ldr	r3, [r7, #4]
10042986:	2240      	movs	r2, #64	@ 0x40
10042988:	2100      	movs	r1, #0
1004298a:	5499      	strb	r1, [r3, r2]

    return HAL_OK;
1004298c:	2300      	movs	r3, #0
1004298e:	e000      	b.n	10042992 <HAL_I2CEx_ConfigAnalogFilter+0x8a>
  }
  else
  {
    return HAL_BUSY;
10042990:	2302      	movs	r3, #2
  }
}
10042992:	0018      	movs	r0, r3
10042994:	46bd      	mov	sp, r7
10042996:	b002      	add	sp, #8
10042998:	bd80      	pop	{r7, pc}
1004299a:	46c0      	nop			@ (mov r8, r8)
1004299c:	ffffefff 	.word	0xffffefff

100429a0 <HAL_I2CEx_ConfigDigitalFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  DigitalFilter Coefficient of digital noise filter between Min_Data=0x00 and Max_Data=0x0F.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigDigitalFilter(I2C_HandleTypeDef *hi2c, uint32_t DigitalFilter)
{
100429a0:	b580      	push	{r7, lr}
100429a2:	b084      	sub	sp, #16
100429a4:	af00      	add	r7, sp, #0
100429a6:	6078      	str	r0, [r7, #4]
100429a8:	6039      	str	r1, [r7, #0]

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
100429aa:	687b      	ldr	r3, [r7, #4]
100429ac:	2241      	movs	r2, #65	@ 0x41
100429ae:	5c9b      	ldrb	r3, [r3, r2]
100429b0:	b2db      	uxtb	r3, r3
100429b2:	2b20      	cmp	r3, #32
100429b4:	d139      	bne.n	10042a2a <HAL_I2CEx_ConfigDigitalFilter+0x8a>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
100429b6:	687b      	ldr	r3, [r7, #4]
100429b8:	2240      	movs	r2, #64	@ 0x40
100429ba:	5c9b      	ldrb	r3, [r3, r2]
100429bc:	2b01      	cmp	r3, #1
100429be:	d101      	bne.n	100429c4 <HAL_I2CEx_ConfigDigitalFilter+0x24>
100429c0:	2302      	movs	r3, #2
100429c2:	e033      	b.n	10042a2c <HAL_I2CEx_ConfigDigitalFilter+0x8c>
100429c4:	687b      	ldr	r3, [r7, #4]
100429c6:	2240      	movs	r2, #64	@ 0x40
100429c8:	2101      	movs	r1, #1
100429ca:	5499      	strb	r1, [r3, r2]

    hi2c->State = HAL_I2C_STATE_BUSY;
100429cc:	687b      	ldr	r3, [r7, #4]
100429ce:	2241      	movs	r2, #65	@ 0x41
100429d0:	2124      	movs	r1, #36	@ 0x24
100429d2:	5499      	strb	r1, [r3, r2]

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
100429d4:	687b      	ldr	r3, [r7, #4]
100429d6:	681b      	ldr	r3, [r3, #0]
100429d8:	681a      	ldr	r2, [r3, #0]
100429da:	687b      	ldr	r3, [r7, #4]
100429dc:	681b      	ldr	r3, [r3, #0]
100429de:	2101      	movs	r1, #1
100429e0:	438a      	bics	r2, r1
100429e2:	601a      	str	r2, [r3, #0]

    /* Get the old register value */
    tmpreg = hi2c->Instance->CR1;
100429e4:	687b      	ldr	r3, [r7, #4]
100429e6:	681b      	ldr	r3, [r3, #0]
100429e8:	681b      	ldr	r3, [r3, #0]
100429ea:	60fb      	str	r3, [r7, #12]

    /* Reset I2Cx DNF bits [11:8] */
    tmpreg &= ~(I2C_CR1_DNF);
100429ec:	68fb      	ldr	r3, [r7, #12]
100429ee:	4a11      	ldr	r2, [pc, #68]	@ (10042a34 <HAL_I2CEx_ConfigDigitalFilter+0x94>)
100429f0:	4013      	ands	r3, r2
100429f2:	60fb      	str	r3, [r7, #12]

    /* Set I2Cx DNF coefficient */
    tmpreg |= DigitalFilter << 8U;
100429f4:	683b      	ldr	r3, [r7, #0]
100429f6:	021b      	lsls	r3, r3, #8
100429f8:	68fa      	ldr	r2, [r7, #12]
100429fa:	4313      	orrs	r3, r2
100429fc:	60fb      	str	r3, [r7, #12]

    /* Store the new register value */
    hi2c->Instance->CR1 = tmpreg;
100429fe:	687b      	ldr	r3, [r7, #4]
10042a00:	681b      	ldr	r3, [r3, #0]
10042a02:	68fa      	ldr	r2, [r7, #12]
10042a04:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
10042a06:	687b      	ldr	r3, [r7, #4]
10042a08:	681b      	ldr	r3, [r3, #0]
10042a0a:	681a      	ldr	r2, [r3, #0]
10042a0c:	687b      	ldr	r3, [r7, #4]
10042a0e:	681b      	ldr	r3, [r3, #0]
10042a10:	2101      	movs	r1, #1
10042a12:	430a      	orrs	r2, r1
10042a14:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
10042a16:	687b      	ldr	r3, [r7, #4]
10042a18:	2241      	movs	r2, #65	@ 0x41
10042a1a:	2120      	movs	r1, #32
10042a1c:	5499      	strb	r1, [r3, r2]

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
10042a1e:	687b      	ldr	r3, [r7, #4]
10042a20:	2240      	movs	r2, #64	@ 0x40
10042a22:	2100      	movs	r1, #0
10042a24:	5499      	strb	r1, [r3, r2]

    return HAL_OK;
10042a26:	2300      	movs	r3, #0
10042a28:	e000      	b.n	10042a2c <HAL_I2CEx_ConfigDigitalFilter+0x8c>
  }
  else
  {
    return HAL_BUSY;
10042a2a:	2302      	movs	r3, #2
  }
}
10042a2c:	0018      	movs	r0, r3
10042a2e:	46bd      	mov	sp, r7
10042a30:	b004      	add	sp, #16
10042a32:	bd80      	pop	{r7, pc}
10042a34:	fffff0ff 	.word	0xfffff0ff

10042a38 <HAL_PWREx_EnableGPIOPullUp>:
  *         PWR_GPIO_BIT_0, ..., PWR_GPIO_BIT_15 or the logical OR
  *         of several of them to setseveral bits for a given port in a single API call.
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_PWREx_EnableGPIOPullUp(uint32_t GPIO, uint32_t GPIONumber)
{
10042a38:	b580      	push	{r7, lr}
10042a3a:	b084      	sub	sp, #16
10042a3c:	af00      	add	r7, sp, #0
10042a3e:	6078      	str	r0, [r7, #4]
10042a40:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
10042a42:	230f      	movs	r3, #15
10042a44:	18fb      	adds	r3, r7, r3
10042a46:	2200      	movs	r2, #0
10042a48:	701a      	strb	r2, [r3, #0]

  assert_param(IS_PWR_GPIO(GPIO));
  assert_param(IS_PWR_GPIO_BIT_NUMBER(GPIONumber));

  switch (GPIO)
10042a4a:	687b      	ldr	r3, [r7, #4]
10042a4c:	2b00      	cmp	r3, #0
10042a4e:	d003      	beq.n	10042a58 <HAL_PWREx_EnableGPIOPullUp+0x20>
10042a50:	687b      	ldr	r3, [r7, #4]
10042a52:	2b01      	cmp	r3, #1
10042a54:	d00e      	beq.n	10042a74 <HAL_PWREx_EnableGPIOPullUp+0x3c>
10042a56:	e01b      	b.n	10042a90 <HAL_PWREx_EnableGPIOPullUp+0x58>
  {
    case PWR_GPIO_A:
      SET_BIT(PWR->PUCRA, GPIONumber);
10042a58:	4b13      	ldr	r3, [pc, #76]	@ (10042aa8 <HAL_PWREx_EnableGPIOPullUp+0x70>)
10042a5a:	6a19      	ldr	r1, [r3, #32]
10042a5c:	4b12      	ldr	r3, [pc, #72]	@ (10042aa8 <HAL_PWREx_EnableGPIOPullUp+0x70>)
10042a5e:	683a      	ldr	r2, [r7, #0]
10042a60:	430a      	orrs	r2, r1
10042a62:	621a      	str	r2, [r3, #32]
      CLEAR_BIT(PWR->PDCRA, GPIONumber);
10042a64:	4b10      	ldr	r3, [pc, #64]	@ (10042aa8 <HAL_PWREx_EnableGPIOPullUp+0x70>)
10042a66:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
10042a68:	683b      	ldr	r3, [r7, #0]
10042a6a:	43d9      	mvns	r1, r3
10042a6c:	4b0e      	ldr	r3, [pc, #56]	@ (10042aa8 <HAL_PWREx_EnableGPIOPullUp+0x70>)
10042a6e:	400a      	ands	r2, r1
10042a70:	625a      	str	r2, [r3, #36]	@ 0x24
      break;
10042a72:	e012      	b.n	10042a9a <HAL_PWREx_EnableGPIOPullUp+0x62>
    case PWR_GPIO_B:
      SET_BIT(PWR->PUCRB, GPIONumber);
10042a74:	4b0c      	ldr	r3, [pc, #48]	@ (10042aa8 <HAL_PWREx_EnableGPIOPullUp+0x70>)
10042a76:	6a99      	ldr	r1, [r3, #40]	@ 0x28
10042a78:	4b0b      	ldr	r3, [pc, #44]	@ (10042aa8 <HAL_PWREx_EnableGPIOPullUp+0x70>)
10042a7a:	683a      	ldr	r2, [r7, #0]
10042a7c:	430a      	orrs	r2, r1
10042a7e:	629a      	str	r2, [r3, #40]	@ 0x28
      CLEAR_BIT(PWR->PDCRB, GPIONumber);
10042a80:	4b09      	ldr	r3, [pc, #36]	@ (10042aa8 <HAL_PWREx_EnableGPIOPullUp+0x70>)
10042a82:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
10042a84:	683b      	ldr	r3, [r7, #0]
10042a86:	43d9      	mvns	r1, r3
10042a88:	4b07      	ldr	r3, [pc, #28]	@ (10042aa8 <HAL_PWREx_EnableGPIOPullUp+0x70>)
10042a8a:	400a      	ands	r2, r1
10042a8c:	62da      	str	r2, [r3, #44]	@ 0x2c
      break;
10042a8e:	e004      	b.n	10042a9a <HAL_PWREx_EnableGPIOPullUp+0x62>
    default:
      status = HAL_ERROR;
10042a90:	230f      	movs	r3, #15
10042a92:	18fb      	adds	r3, r7, r3
10042a94:	2201      	movs	r2, #1
10042a96:	701a      	strb	r2, [r3, #0]
      break;
10042a98:	46c0      	nop			@ (mov r8, r8)
  }

  return status;
10042a9a:	230f      	movs	r3, #15
10042a9c:	18fb      	adds	r3, r7, r3
10042a9e:	781b      	ldrb	r3, [r3, #0]
}
10042aa0:	0018      	movs	r0, r3
10042aa2:	46bd      	mov	sp, r7
10042aa4:	b004      	add	sp, #16
10042aa6:	bd80      	pop	{r7, pc}
10042aa8:	48500000 	.word	0x48500000

10042aac <HAL_PWREx_DisableGPIOPullUp>:
  *         or the logical OR of several of them to reset
  *         several bits for a given port in a single API call.
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_PWREx_DisableGPIOPullUp(uint32_t GPIO, uint32_t GPIONumber)
{
10042aac:	b580      	push	{r7, lr}
10042aae:	b084      	sub	sp, #16
10042ab0:	af00      	add	r7, sp, #0
10042ab2:	6078      	str	r0, [r7, #4]
10042ab4:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
10042ab6:	230f      	movs	r3, #15
10042ab8:	18fb      	adds	r3, r7, r3
10042aba:	2200      	movs	r2, #0
10042abc:	701a      	strb	r2, [r3, #0]

  assert_param(IS_PWR_GPIO(GPIO));
  assert_param(IS_PWR_GPIO_BIT_NUMBER(GPIONumber));

  switch (GPIO)
10042abe:	687b      	ldr	r3, [r7, #4]
10042ac0:	2b00      	cmp	r3, #0
10042ac2:	d003      	beq.n	10042acc <HAL_PWREx_DisableGPIOPullUp+0x20>
10042ac4:	687b      	ldr	r3, [r7, #4]
10042ac6:	2b01      	cmp	r3, #1
10042ac8:	d008      	beq.n	10042adc <HAL_PWREx_DisableGPIOPullUp+0x30>
10042aca:	e00f      	b.n	10042aec <HAL_PWREx_DisableGPIOPullUp+0x40>
  {
    case PWR_GPIO_A:
      CLEAR_BIT(PWR->PUCRA, GPIONumber);
10042acc:	4b0d      	ldr	r3, [pc, #52]	@ (10042b04 <HAL_PWREx_DisableGPIOPullUp+0x58>)
10042ace:	6a1a      	ldr	r2, [r3, #32]
10042ad0:	683b      	ldr	r3, [r7, #0]
10042ad2:	43d9      	mvns	r1, r3
10042ad4:	4b0b      	ldr	r3, [pc, #44]	@ (10042b04 <HAL_PWREx_DisableGPIOPullUp+0x58>)
10042ad6:	400a      	ands	r2, r1
10042ad8:	621a      	str	r2, [r3, #32]
      break;
10042ada:	e00c      	b.n	10042af6 <HAL_PWREx_DisableGPIOPullUp+0x4a>
    case PWR_GPIO_B:
      CLEAR_BIT(PWR->PUCRB, GPIONumber);
10042adc:	4b09      	ldr	r3, [pc, #36]	@ (10042b04 <HAL_PWREx_DisableGPIOPullUp+0x58>)
10042ade:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
10042ae0:	683b      	ldr	r3, [r7, #0]
10042ae2:	43d9      	mvns	r1, r3
10042ae4:	4b07      	ldr	r3, [pc, #28]	@ (10042b04 <HAL_PWREx_DisableGPIOPullUp+0x58>)
10042ae6:	400a      	ands	r2, r1
10042ae8:	629a      	str	r2, [r3, #40]	@ 0x28
      break;
10042aea:	e004      	b.n	10042af6 <HAL_PWREx_DisableGPIOPullUp+0x4a>
    default:
      status = HAL_ERROR;
10042aec:	230f      	movs	r3, #15
10042aee:	18fb      	adds	r3, r7, r3
10042af0:	2201      	movs	r2, #1
10042af2:	701a      	strb	r2, [r3, #0]
      break;
10042af4:	46c0      	nop			@ (mov r8, r8)
  }

  return status;
10042af6:	230f      	movs	r3, #15
10042af8:	18fb      	adds	r3, r7, r3
10042afa:	781b      	ldrb	r3, [r3, #0]
}
10042afc:	0018      	movs	r0, r3
10042afe:	46bd      	mov	sp, r7
10042b00:	b004      	add	sp, #16
10042b02:	bd80      	pop	{r7, pc}
10042b04:	48500000 	.word	0x48500000

10042b08 <HAL_PWREx_DisableGPIOPullDown>:
  *         or the logical OR of several of them to reset
  *         several bits for a given port in a single API call.
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_PWREx_DisableGPIOPullDown(uint32_t GPIO, uint32_t GPIONumber)
{
10042b08:	b580      	push	{r7, lr}
10042b0a:	b084      	sub	sp, #16
10042b0c:	af00      	add	r7, sp, #0
10042b0e:	6078      	str	r0, [r7, #4]
10042b10:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
10042b12:	230f      	movs	r3, #15
10042b14:	18fb      	adds	r3, r7, r3
10042b16:	2200      	movs	r2, #0
10042b18:	701a      	strb	r2, [r3, #0]

  assert_param(IS_PWR_GPIO(GPIO));
  assert_param(IS_PWR_GPIO_BIT_NUMBER(GPIONumber));

  switch (GPIO)
10042b1a:	687b      	ldr	r3, [r7, #4]
10042b1c:	2b00      	cmp	r3, #0
10042b1e:	d003      	beq.n	10042b28 <HAL_PWREx_DisableGPIOPullDown+0x20>
10042b20:	687b      	ldr	r3, [r7, #4]
10042b22:	2b01      	cmp	r3, #1
10042b24:	d008      	beq.n	10042b38 <HAL_PWREx_DisableGPIOPullDown+0x30>
10042b26:	e00f      	b.n	10042b48 <HAL_PWREx_DisableGPIOPullDown+0x40>
  {
    case PWR_GPIO_A:
      CLEAR_BIT(PWR->PDCRA, GPIONumber);
10042b28:	4b0d      	ldr	r3, [pc, #52]	@ (10042b60 <HAL_PWREx_DisableGPIOPullDown+0x58>)
10042b2a:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
10042b2c:	683b      	ldr	r3, [r7, #0]
10042b2e:	43d9      	mvns	r1, r3
10042b30:	4b0b      	ldr	r3, [pc, #44]	@ (10042b60 <HAL_PWREx_DisableGPIOPullDown+0x58>)
10042b32:	400a      	ands	r2, r1
10042b34:	625a      	str	r2, [r3, #36]	@ 0x24
      break;
10042b36:	e00c      	b.n	10042b52 <HAL_PWREx_DisableGPIOPullDown+0x4a>
    case PWR_GPIO_B:
      CLEAR_BIT(PWR->PDCRB, GPIONumber);
10042b38:	4b09      	ldr	r3, [pc, #36]	@ (10042b60 <HAL_PWREx_DisableGPIOPullDown+0x58>)
10042b3a:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
10042b3c:	683b      	ldr	r3, [r7, #0]
10042b3e:	43d9      	mvns	r1, r3
10042b40:	4b07      	ldr	r3, [pc, #28]	@ (10042b60 <HAL_PWREx_DisableGPIOPullDown+0x58>)
10042b42:	400a      	ands	r2, r1
10042b44:	62da      	str	r2, [r3, #44]	@ 0x2c
      break;
10042b46:	e004      	b.n	10042b52 <HAL_PWREx_DisableGPIOPullDown+0x4a>
    default:
      status = HAL_ERROR;
10042b48:	230f      	movs	r3, #15
10042b4a:	18fb      	adds	r3, r7, r3
10042b4c:	2201      	movs	r2, #1
10042b4e:	701a      	strb	r2, [r3, #0]
      break;
10042b50:	46c0      	nop			@ (mov r8, r8)
  }

  return status;
10042b52:	230f      	movs	r3, #15
10042b54:	18fb      	adds	r3, r7, r3
10042b56:	781b      	ldrb	r3, [r3, #0]
}
10042b58:	0018      	movs	r0, r3
10042b5a:	46bd      	mov	sp, r7
10042b5c:	b004      	add	sp, #16
10042b5e:	bd80      	pop	{r7, pc}
10042b60:	48500000 	.word	0x48500000

10042b64 <LL_PWR_SetNoPullB>:
  * @retval None
  * @note   Please refer the user manual to know which IOs are able for this
  *         feature.
  */
__STATIC_INLINE void LL_PWR_SetNoPullB(uint32_t IO)
{
10042b64:	b580      	push	{r7, lr}
10042b66:	b082      	sub	sp, #8
10042b68:	af00      	add	r7, sp, #0
10042b6a:	6078      	str	r0, [r7, #4]
  CLEAR_BIT(PWR->PUCRB, IO);
10042b6c:	4b08      	ldr	r3, [pc, #32]	@ (10042b90 <LL_PWR_SetNoPullB+0x2c>)
10042b6e:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
10042b70:	687b      	ldr	r3, [r7, #4]
10042b72:	43d9      	mvns	r1, r3
10042b74:	4b06      	ldr	r3, [pc, #24]	@ (10042b90 <LL_PWR_SetNoPullB+0x2c>)
10042b76:	400a      	ands	r2, r1
10042b78:	629a      	str	r2, [r3, #40]	@ 0x28
  CLEAR_BIT(PWR->PDCRB, IO);
10042b7a:	4b05      	ldr	r3, [pc, #20]	@ (10042b90 <LL_PWR_SetNoPullB+0x2c>)
10042b7c:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
10042b7e:	687b      	ldr	r3, [r7, #4]
10042b80:	43d9      	mvns	r1, r3
10042b82:	4b03      	ldr	r3, [pc, #12]	@ (10042b90 <LL_PWR_SetNoPullB+0x2c>)
10042b84:	400a      	ands	r2, r1
10042b86:	62da      	str	r2, [r3, #44]	@ 0x2c
}
10042b88:	46c0      	nop			@ (mov r8, r8)
10042b8a:	46bd      	mov	sp, r7
10042b8c:	b002      	add	sp, #8
10042b8e:	bd80      	pop	{r7, pc}
10042b90:	48500000 	.word	0x48500000

10042b94 <LL_RCC_HSE_Enable>:
  * @brief  Enable HSE crystal oscillator (HSE ON)
  * @rmtoll CR           HSEON         LL_RCC_HSE_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_HSE_Enable(void)
{
10042b94:	b580      	push	{r7, lr}
10042b96:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CR, RCC_CR_HSEON);
10042b98:	4b04      	ldr	r3, [pc, #16]	@ (10042bac <LL_RCC_HSE_Enable+0x18>)
10042b9a:	681a      	ldr	r2, [r3, #0]
10042b9c:	4b03      	ldr	r3, [pc, #12]	@ (10042bac <LL_RCC_HSE_Enable+0x18>)
10042b9e:	2180      	movs	r1, #128	@ 0x80
10042ba0:	0249      	lsls	r1, r1, #9
10042ba2:	430a      	orrs	r2, r1
10042ba4:	601a      	str	r2, [r3, #0]
}
10042ba6:	46c0      	nop			@ (mov r8, r8)
10042ba8:	46bd      	mov	sp, r7
10042baa:	bd80      	pop	{r7, pc}
10042bac:	48400000 	.word	0x48400000

10042bb0 <LL_RCC_HSE_Disable>:
  * @brief  Disable HSE crystal oscillator (HSE ON)
  * @rmtoll CR           HSEON         LL_RCC_HSE_Disable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_HSE_Disable(void)
{
10042bb0:	b580      	push	{r7, lr}
10042bb2:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CR, RCC_CR_HSEON);
10042bb4:	4b04      	ldr	r3, [pc, #16]	@ (10042bc8 <LL_RCC_HSE_Disable+0x18>)
10042bb6:	681a      	ldr	r2, [r3, #0]
10042bb8:	4b03      	ldr	r3, [pc, #12]	@ (10042bc8 <LL_RCC_HSE_Disable+0x18>)
10042bba:	4904      	ldr	r1, [pc, #16]	@ (10042bcc <LL_RCC_HSE_Disable+0x1c>)
10042bbc:	400a      	ands	r2, r1
10042bbe:	601a      	str	r2, [r3, #0]
}
10042bc0:	46c0      	nop			@ (mov r8, r8)
10042bc2:	46bd      	mov	sp, r7
10042bc4:	bd80      	pop	{r7, pc}
10042bc6:	46c0      	nop			@ (mov r8, r8)
10042bc8:	48400000 	.word	0x48400000
10042bcc:	fffeffff 	.word	0xfffeffff

10042bd0 <LL_RCC_HSE_IsReady>:
  * @brief  Check if HSE oscillator Ready
  * @rmtoll CR           HSERDY        LL_RCC_HSE_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_HSE_IsReady(void)
{
10042bd0:	b580      	push	{r7, lr}
10042bd2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_HSERDY) == (RCC_CR_HSERDY)) ? 1UL : 0UL);
10042bd4:	4b07      	ldr	r3, [pc, #28]	@ (10042bf4 <LL_RCC_HSE_IsReady+0x24>)
10042bd6:	681a      	ldr	r2, [r3, #0]
10042bd8:	2380      	movs	r3, #128	@ 0x80
10042bda:	029b      	lsls	r3, r3, #10
10042bdc:	401a      	ands	r2, r3
10042bde:	2380      	movs	r3, #128	@ 0x80
10042be0:	029b      	lsls	r3, r3, #10
10042be2:	429a      	cmp	r2, r3
10042be4:	d101      	bne.n	10042bea <LL_RCC_HSE_IsReady+0x1a>
10042be6:	2301      	movs	r3, #1
10042be8:	e000      	b.n	10042bec <LL_RCC_HSE_IsReady+0x1c>
10042bea:	2300      	movs	r3, #0
}
10042bec:	0018      	movs	r0, r3
10042bee:	46bd      	mov	sp, r7
10042bf0:	bd80      	pop	{r7, pc}
10042bf2:	46c0      	nop			@ (mov r8, r8)
10042bf4:	48400000 	.word	0x48400000

10042bf8 <LL_RCC_HSE_SetCapacitorTuning>:
  * @rmtoll RFSWHSECR        SWXOTUNE       LL_RCC_HSE_SetCapacitorTuning
  * @param  Value Between Min_Data = 0 and Max_Data = 63
  * @retval None
  */
__STATIC_INLINE void LL_RCC_HSE_SetCapacitorTuning(uint32_t Value)
{
10042bf8:	b580      	push	{r7, lr}
10042bfa:	b082      	sub	sp, #8
10042bfc:	af00      	add	r7, sp, #0
10042bfe:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->RFSWHSECR, RCC_RFSWHSECR_SWXOTUNE, Value << RCC_RFSWHSECR_SWXOTUNE_Pos);
10042c00:	4a0b      	ldr	r2, [pc, #44]	@ (10042c30 <LL_RCC_HSE_SetCapacitorTuning+0x38>)
10042c02:	2398      	movs	r3, #152	@ 0x98
10042c04:	58d3      	ldr	r3, [r2, r3]
10042c06:	4a0b      	ldr	r2, [pc, #44]	@ (10042c34 <LL_RCC_HSE_SetCapacitorTuning+0x3c>)
10042c08:	401a      	ands	r2, r3
10042c0a:	687b      	ldr	r3, [r7, #4]
10042c0c:	021b      	lsls	r3, r3, #8
10042c0e:	4908      	ldr	r1, [pc, #32]	@ (10042c30 <LL_RCC_HSE_SetCapacitorTuning+0x38>)
10042c10:	4313      	orrs	r3, r2
10042c12:	2298      	movs	r2, #152	@ 0x98
10042c14:	508b      	str	r3, [r1, r2]
  SET_BIT(RCC->RFSWHSECR, RCC_RFSWHSECR_SWXOTUNEEN);
10042c16:	4a06      	ldr	r2, [pc, #24]	@ (10042c30 <LL_RCC_HSE_SetCapacitorTuning+0x38>)
10042c18:	2398      	movs	r3, #152	@ 0x98
10042c1a:	58d3      	ldr	r3, [r2, r3]
10042c1c:	4904      	ldr	r1, [pc, #16]	@ (10042c30 <LL_RCC_HSE_SetCapacitorTuning+0x38>)
10042c1e:	2280      	movs	r2, #128	@ 0x80
10042c20:	4313      	orrs	r3, r2
10042c22:	2298      	movs	r2, #152	@ 0x98
10042c24:	508b      	str	r3, [r1, r2]
}
10042c26:	46c0      	nop			@ (mov r8, r8)
10042c28:	46bd      	mov	sp, r7
10042c2a:	b002      	add	sp, #8
10042c2c:	bd80      	pop	{r7, pc}
10042c2e:	46c0      	nop			@ (mov r8, r8)
10042c30:	48400000 	.word	0x48400000
10042c34:	ffffc0ff 	.word	0xffffc0ff

10042c38 <LL_RCC_HSE_SetCurrentControl>:
  *         Example GMC[6:0]=0b1111001=25*40uA
  * @rmtoll RFSWHSECR        GMC       LL_RCC_HSE_SetCurrentControl
  * @param  CurrentMax HSE current calculated with the previous formula
  */
__STATIC_INLINE void LL_RCC_HSE_SetCurrentControl(uint32_t CurrentMax)
{
10042c38:	b580      	push	{r7, lr}
10042c3a:	b082      	sub	sp, #8
10042c3c:	af00      	add	r7, sp, #0
10042c3e:	6078      	str	r0, [r7, #4]
  MODIFY_REG_FIELD(RCC->RFSWHSECR, RCC_RFSWHSECR_GMC, CurrentMax);
10042c40:	4a08      	ldr	r2, [pc, #32]	@ (10042c64 <LL_RCC_HSE_SetCurrentControl+0x2c>)
10042c42:	2398      	movs	r3, #152	@ 0x98
10042c44:	58d3      	ldr	r3, [r2, r3]
10042c46:	227f      	movs	r2, #127	@ 0x7f
10042c48:	4393      	bics	r3, r2
10042c4a:	001a      	movs	r2, r3
10042c4c:	687b      	ldr	r3, [r7, #4]
10042c4e:	217f      	movs	r1, #127	@ 0x7f
10042c50:	400b      	ands	r3, r1
10042c52:	4904      	ldr	r1, [pc, #16]	@ (10042c64 <LL_RCC_HSE_SetCurrentControl+0x2c>)
10042c54:	4313      	orrs	r3, r2
10042c56:	2298      	movs	r2, #152	@ 0x98
10042c58:	508b      	str	r3, [r1, r2]
}
10042c5a:	46c0      	nop			@ (mov r8, r8)
10042c5c:	46bd      	mov	sp, r7
10042c5e:	b002      	add	sp, #8
10042c60:	bd80      	pop	{r7, pc}
10042c62:	46c0      	nop			@ (mov r8, r8)
10042c64:	48400000 	.word	0x48400000

10042c68 <LL_RCC_HSE_SetStartupCurrent>:
  * @brief  Set HSE startup current
  * @rmtoll RFSWHSECR        ISTARTUP      LL_RCC_HSE_SetStartupCurrent
  * @param  StartupCurrent HSE startup current
  */
__STATIC_INLINE void LL_RCC_HSE_SetStartupCurrent(uint32_t StartupCurrent)
{
10042c68:	b580      	push	{r7, lr}
10042c6a:	b082      	sub	sp, #8
10042c6c:	af00      	add	r7, sp, #0
10042c6e:	6078      	str	r0, [r7, #4]
  MODIFY_REG_FIELD(RCC->RFSWHSECR, RCC_RFSWHSECR_ISTARTUP, StartupCurrent);
10042c70:	4a08      	ldr	r2, [pc, #32]	@ (10042c94 <LL_RCC_HSE_SetStartupCurrent+0x2c>)
10042c72:	2398      	movs	r3, #152	@ 0x98
10042c74:	58d3      	ldr	r3, [r2, r3]
10042c76:	4a08      	ldr	r2, [pc, #32]	@ (10042c98 <LL_RCC_HSE_SetStartupCurrent+0x30>)
10042c78:	401a      	ands	r2, r3
10042c7a:	687b      	ldr	r3, [r7, #4]
10042c7c:	039b      	lsls	r3, r3, #14
10042c7e:	041b      	lsls	r3, r3, #16
10042c80:	0c1b      	lsrs	r3, r3, #16
10042c82:	4904      	ldr	r1, [pc, #16]	@ (10042c94 <LL_RCC_HSE_SetStartupCurrent+0x2c>)
10042c84:	4313      	orrs	r3, r2
10042c86:	2298      	movs	r2, #152	@ 0x98
10042c88:	508b      	str	r3, [r1, r2]
}
10042c8a:	46c0      	nop			@ (mov r8, r8)
10042c8c:	46bd      	mov	sp, r7
10042c8e:	b002      	add	sp, #8
10042c90:	bd80      	pop	{r7, pc}
10042c92:	46c0      	nop			@ (mov r8, r8)
10042c94:	48400000 	.word	0x48400000
10042c98:	ffff3fff 	.word	0xffff3fff

10042c9c <LL_RCC_HSE_SetAmplitudeThreshold>:
  * @brief  Set HSE Amplitude Control threshold
  * @rmtoll RFSWHSECR        AMPLTHRESH      LL_RCC_HSE_SetAmplitudeThreshold
  * @param  AmplThr HSE Amplitude Control threshold
  */
__STATIC_INLINE void LL_RCC_HSE_SetAmplitudeThreshold(uint32_t AmplThr)
{
10042c9c:	b580      	push	{r7, lr}
10042c9e:	b082      	sub	sp, #8
10042ca0:	af00      	add	r7, sp, #0
10042ca2:	6078      	str	r0, [r7, #4]
  MODIFY_REG_FIELD(RCC->RFSWHSECR, RCC_RFSWHSECR_AMPLTHRESH, AmplThr);
10042ca4:	4a08      	ldr	r2, [pc, #32]	@ (10042cc8 <LL_RCC_HSE_SetAmplitudeThreshold+0x2c>)
10042ca6:	2398      	movs	r3, #152	@ 0x98
10042ca8:	58d3      	ldr	r3, [r2, r3]
10042caa:	4a08      	ldr	r2, [pc, #32]	@ (10042ccc <LL_RCC_HSE_SetAmplitudeThreshold+0x30>)
10042cac:	401a      	ands	r2, r3
10042cae:	687b      	ldr	r3, [r7, #4]
10042cb0:	0419      	lsls	r1, r3, #16
10042cb2:	23e0      	movs	r3, #224	@ 0xe0
10042cb4:	02db      	lsls	r3, r3, #11
10042cb6:	400b      	ands	r3, r1
10042cb8:	4903      	ldr	r1, [pc, #12]	@ (10042cc8 <LL_RCC_HSE_SetAmplitudeThreshold+0x2c>)
10042cba:	4313      	orrs	r3, r2
10042cbc:	2298      	movs	r2, #152	@ 0x98
10042cbe:	508b      	str	r3, [r1, r2]
}
10042cc0:	46c0      	nop			@ (mov r8, r8)
10042cc2:	46bd      	mov	sp, r7
10042cc4:	b002      	add	sp, #8
10042cc6:	bd80      	pop	{r7, pc}
10042cc8:	48400000 	.word	0x48400000
10042ccc:	fff8ffff 	.word	0xfff8ffff

10042cd0 <LL_RCC_HSI_Enable>:
  * @brief  Enable HSI
  * @rmtoll CFGR           STOPHSI        LL_RCC_HSI_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_HSI_Enable(void)
{
10042cd0:	b580      	push	{r7, lr}
10042cd2:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CFGR, RCC_CFGR_STOPHSI);
10042cd4:	4b07      	ldr	r3, [pc, #28]	@ (10042cf4 <LL_RCC_HSI_Enable+0x24>)
10042cd6:	689a      	ldr	r2, [r3, #8]
10042cd8:	4b06      	ldr	r3, [pc, #24]	@ (10042cf4 <LL_RCC_HSI_Enable+0x24>)
10042cda:	2104      	movs	r1, #4
10042cdc:	438a      	bics	r2, r1
10042cde:	609a      	str	r2, [r3, #8]
  CLEAR_BIT(RCC->CFGR, RCC_CFGR_HSESEL);
10042ce0:	4b04      	ldr	r3, [pc, #16]	@ (10042cf4 <LL_RCC_HSI_Enable+0x24>)
10042ce2:	689a      	ldr	r2, [r3, #8]
10042ce4:	4b03      	ldr	r3, [pc, #12]	@ (10042cf4 <LL_RCC_HSI_Enable+0x24>)
10042ce6:	2102      	movs	r1, #2
10042ce8:	438a      	bics	r2, r1
10042cea:	609a      	str	r2, [r3, #8]
}
10042cec:	46c0      	nop			@ (mov r8, r8)
10042cee:	46bd      	mov	sp, r7
10042cf0:	bd80      	pop	{r7, pc}
10042cf2:	46c0      	nop			@ (mov r8, r8)
10042cf4:	48400000 	.word	0x48400000

10042cf8 <LL_RCC_HSI_Disable>:
  * @brief  Disable HSI
  * @rmtoll CFGR           STOPHSI        LL_RCC_HSI_Disable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_HSI_Disable(void)
{
10042cf8:	b580      	push	{r7, lr}
10042cfa:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CFGR, RCC_CFGR_HSESEL);
10042cfc:	4b07      	ldr	r3, [pc, #28]	@ (10042d1c <LL_RCC_HSI_Disable+0x24>)
10042cfe:	689a      	ldr	r2, [r3, #8]
10042d00:	4b06      	ldr	r3, [pc, #24]	@ (10042d1c <LL_RCC_HSI_Disable+0x24>)
10042d02:	2102      	movs	r1, #2
10042d04:	430a      	orrs	r2, r1
10042d06:	609a      	str	r2, [r3, #8]
  SET_BIT(RCC->CFGR, RCC_CFGR_STOPHSI);
10042d08:	4b04      	ldr	r3, [pc, #16]	@ (10042d1c <LL_RCC_HSI_Disable+0x24>)
10042d0a:	689a      	ldr	r2, [r3, #8]
10042d0c:	4b03      	ldr	r3, [pc, #12]	@ (10042d1c <LL_RCC_HSI_Disable+0x24>)
10042d0e:	2104      	movs	r1, #4
10042d10:	430a      	orrs	r2, r1
10042d12:	609a      	str	r2, [r3, #8]
}
10042d14:	46c0      	nop			@ (mov r8, r8)
10042d16:	46bd      	mov	sp, r7
10042d18:	bd80      	pop	{r7, pc}
10042d1a:	46c0      	nop			@ (mov r8, r8)
10042d1c:	48400000 	.word	0x48400000

10042d20 <LL_RCC_HSI_IsReady>:
  * @brief  Check if HSI clock is ready
  * @rmtoll CR           HSIRDY        LL_RCC_HSI_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_HSI_IsReady(void)
{
10042d20:	b580      	push	{r7, lr}
10042d22:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_HSIRDY) == (RCC_CR_HSIRDY)) ? 1UL : 0UL);
10042d24:	4b07      	ldr	r3, [pc, #28]	@ (10042d44 <LL_RCC_HSI_IsReady+0x24>)
10042d26:	681a      	ldr	r2, [r3, #0]
10042d28:	2380      	movs	r3, #128	@ 0x80
10042d2a:	00db      	lsls	r3, r3, #3
10042d2c:	401a      	ands	r2, r3
10042d2e:	2380      	movs	r3, #128	@ 0x80
10042d30:	00db      	lsls	r3, r3, #3
10042d32:	429a      	cmp	r2, r3
10042d34:	d101      	bne.n	10042d3a <LL_RCC_HSI_IsReady+0x1a>
10042d36:	2301      	movs	r3, #1
10042d38:	e000      	b.n	10042d3c <LL_RCC_HSI_IsReady+0x1c>
10042d3a:	2300      	movs	r3, #0
}
10042d3c:	0018      	movs	r0, r3
10042d3e:	46bd      	mov	sp, r7
10042d40:	bd80      	pop	{r7, pc}
10042d42:	46c0      	nop			@ (mov r8, r8)
10042d44:	48400000 	.word	0x48400000

10042d48 <LL_RCC_DIRECT_HSE_Enable>:
  * @brief  Enable DIRECT_HSE mode
  * @rmtoll CFGR       HSESEL/STOPHSI         LL_RCC_HSE_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_DIRECT_HSE_Enable(void)
{
10042d48:	b580      	push	{r7, lr}
10042d4a:	b082      	sub	sp, #8
10042d4c:	af00      	add	r7, sp, #0
  while (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0);
10042d4e:	46c0      	nop			@ (mov r8, r8)
10042d50:	4b0f      	ldr	r3, [pc, #60]	@ (10042d90 <LL_RCC_DIRECT_HSE_Enable+0x48>)
10042d52:	681a      	ldr	r2, [r3, #0]
10042d54:	2380      	movs	r3, #128	@ 0x80
10042d56:	029b      	lsls	r3, r3, #10
10042d58:	4013      	ands	r3, r2
10042d5a:	d0f9      	beq.n	10042d50 <LL_RCC_DIRECT_HSE_Enable+0x8>
  SET_BIT(RCC->CFGR, RCC_CFGR_HSESEL);
10042d5c:	4b0c      	ldr	r3, [pc, #48]	@ (10042d90 <LL_RCC_DIRECT_HSE_Enable+0x48>)
10042d5e:	689a      	ldr	r2, [r3, #8]
10042d60:	4b0b      	ldr	r3, [pc, #44]	@ (10042d90 <LL_RCC_DIRECT_HSE_Enable+0x48>)
10042d62:	2102      	movs	r1, #2
10042d64:	430a      	orrs	r2, r1
10042d66:	609a      	str	r2, [r3, #8]
  for (volatile int i = 0; i < 6; i++)
10042d68:	2300      	movs	r3, #0
10042d6a:	607b      	str	r3, [r7, #4]
10042d6c:	e003      	b.n	10042d76 <LL_RCC_DIRECT_HSE_Enable+0x2e>
  {
    __asm("NOP");
10042d6e:	46c0      	nop			@ (mov r8, r8)
  for (volatile int i = 0; i < 6; i++)
10042d70:	687b      	ldr	r3, [r7, #4]
10042d72:	3301      	adds	r3, #1
10042d74:	607b      	str	r3, [r7, #4]
10042d76:	687b      	ldr	r3, [r7, #4]
10042d78:	2b05      	cmp	r3, #5
10042d7a:	ddf8      	ble.n	10042d6e <LL_RCC_DIRECT_HSE_Enable+0x26>
  }
  SET_BIT(RCC->CFGR, RCC_CFGR_STOPHSI);
10042d7c:	4b04      	ldr	r3, [pc, #16]	@ (10042d90 <LL_RCC_DIRECT_HSE_Enable+0x48>)
10042d7e:	689a      	ldr	r2, [r3, #8]
10042d80:	4b03      	ldr	r3, [pc, #12]	@ (10042d90 <LL_RCC_DIRECT_HSE_Enable+0x48>)
10042d82:	2104      	movs	r1, #4
10042d84:	430a      	orrs	r2, r1
10042d86:	609a      	str	r2, [r3, #8]
}
10042d88:	46c0      	nop			@ (mov r8, r8)
10042d8a:	46bd      	mov	sp, r7
10042d8c:	b002      	add	sp, #8
10042d8e:	bd80      	pop	{r7, pc}
10042d90:	48400000 	.word	0x48400000

10042d94 <LL_RCC_LSCO_SetSource>:
  *         @arg @ref LL_RCC_LSCO_CLKSOURCE_LSI
  *         @arg @ref LL_RCC_LSCO_CLKSOURCE_HSI64M_DIV2048
  * @retval None
  */
__STATIC_INLINE void LL_RCC_LSCO_SetSource(uint32_t Source)
{
10042d94:	b580      	push	{r7, lr}
10042d96:	b082      	sub	sp, #8
10042d98:	af00      	add	r7, sp, #0
10042d9a:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_CLKSLOWSEL, Source);
10042d9c:	4b06      	ldr	r3, [pc, #24]	@ (10042db8 <LL_RCC_LSCO_SetSource+0x24>)
10042d9e:	689b      	ldr	r3, [r3, #8]
10042da0:	4a06      	ldr	r2, [pc, #24]	@ (10042dbc <LL_RCC_LSCO_SetSource+0x28>)
10042da2:	4013      	ands	r3, r2
10042da4:	0019      	movs	r1, r3
10042da6:	4b04      	ldr	r3, [pc, #16]	@ (10042db8 <LL_RCC_LSCO_SetSource+0x24>)
10042da8:	687a      	ldr	r2, [r7, #4]
10042daa:	430a      	orrs	r2, r1
10042dac:	609a      	str	r2, [r3, #8]
}
10042dae:	46c0      	nop			@ (mov r8, r8)
10042db0:	46bd      	mov	sp, r7
10042db2:	b002      	add	sp, #8
10042db4:	bd80      	pop	{r7, pc}
10042db6:	46c0      	nop			@ (mov r8, r8)
10042db8:	48400000 	.word	0x48400000
10042dbc:	fffe7fff 	.word	0xfffe7fff

10042dc0 <LL_RCC_LSE_Enable>:
  * @brief  Enable  Low Speed External (LSE) crystal.
  * @rmtoll CR         LSEON         LL_RCC_LSE_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_LSE_Enable(void)
{
10042dc0:	b580      	push	{r7, lr}
10042dc2:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CR, RCC_CR_LSEON);
10042dc4:	4b04      	ldr	r3, [pc, #16]	@ (10042dd8 <LL_RCC_LSE_Enable+0x18>)
10042dc6:	681a      	ldr	r2, [r3, #0]
10042dc8:	4b03      	ldr	r3, [pc, #12]	@ (10042dd8 <LL_RCC_LSE_Enable+0x18>)
10042dca:	2110      	movs	r1, #16
10042dcc:	430a      	orrs	r2, r1
10042dce:	601a      	str	r2, [r3, #0]
}
10042dd0:	46c0      	nop			@ (mov r8, r8)
10042dd2:	46bd      	mov	sp, r7
10042dd4:	bd80      	pop	{r7, pc}
10042dd6:	46c0      	nop			@ (mov r8, r8)
10042dd8:	48400000 	.word	0x48400000

10042ddc <LL_RCC_LSE_Disable>:
  * @brief  Disable  Low Speed External (LSE) crystal.
  * @rmtoll CR         LSEON         LL_RCC_LSE_Disable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_LSE_Disable(void)
{
10042ddc:	b580      	push	{r7, lr}
10042dde:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CR, RCC_CR_LSEON);
10042de0:	4b04      	ldr	r3, [pc, #16]	@ (10042df4 <LL_RCC_LSE_Disable+0x18>)
10042de2:	681a      	ldr	r2, [r3, #0]
10042de4:	4b03      	ldr	r3, [pc, #12]	@ (10042df4 <LL_RCC_LSE_Disable+0x18>)
10042de6:	2110      	movs	r1, #16
10042de8:	438a      	bics	r2, r1
10042dea:	601a      	str	r2, [r3, #0]
}
10042dec:	46c0      	nop			@ (mov r8, r8)
10042dee:	46bd      	mov	sp, r7
10042df0:	bd80      	pop	{r7, pc}
10042df2:	46c0      	nop			@ (mov r8, r8)
10042df4:	48400000 	.word	0x48400000

10042df8 <LL_RCC_LSE_IsReady>:
  * @brief  Check if LSE oscillator Ready
  * @rmtoll CR         LSERDY        LL_RCC_LSE_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_LSE_IsReady(void)
{
10042df8:	b580      	push	{r7, lr}
10042dfa:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_LSERDY) == (RCC_CR_LSERDY)) ? 1UL : 0UL);
10042dfc:	4b05      	ldr	r3, [pc, #20]	@ (10042e14 <LL_RCC_LSE_IsReady+0x1c>)
10042dfe:	681b      	ldr	r3, [r3, #0]
10042e00:	2220      	movs	r2, #32
10042e02:	4013      	ands	r3, r2
10042e04:	2b20      	cmp	r3, #32
10042e06:	d101      	bne.n	10042e0c <LL_RCC_LSE_IsReady+0x14>
10042e08:	2301      	movs	r3, #1
10042e0a:	e000      	b.n	10042e0e <LL_RCC_LSE_IsReady+0x16>
10042e0c:	2300      	movs	r3, #0
}
10042e0e:	0018      	movs	r0, r3
10042e10:	46bd      	mov	sp, r7
10042e12:	bd80      	pop	{r7, pc}
10042e14:	48400000 	.word	0x48400000

10042e18 <LL_RCC_LSE_EnableBypass>:
  * @brief  Enable external clock source (LSE bypass).
  * @rmtoll CR         LSEBYP        LL_RCC_LSE_EnableBypass
  * @retval None
  */
__STATIC_INLINE void LL_RCC_LSE_EnableBypass(void)
{
10042e18:	b580      	push	{r7, lr}
10042e1a:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CR, RCC_CR_LSEBYP);
10042e1c:	4b04      	ldr	r3, [pc, #16]	@ (10042e30 <LL_RCC_LSE_EnableBypass+0x18>)
10042e1e:	681a      	ldr	r2, [r3, #0]
10042e20:	4b03      	ldr	r3, [pc, #12]	@ (10042e30 <LL_RCC_LSE_EnableBypass+0x18>)
10042e22:	2140      	movs	r1, #64	@ 0x40
10042e24:	430a      	orrs	r2, r1
10042e26:	601a      	str	r2, [r3, #0]
}
10042e28:	46c0      	nop			@ (mov r8, r8)
10042e2a:	46bd      	mov	sp, r7
10042e2c:	bd80      	pop	{r7, pc}
10042e2e:	46c0      	nop			@ (mov r8, r8)
10042e30:	48400000 	.word	0x48400000

10042e34 <LL_RCC_LSE_DisableBypass>:
  * @brief  Disable external clock source (LSE bypass).
  * @rmtoll CR         LSEBYP        LL_RCC_LSE_DisableBypass
  * @retval None
  */
__STATIC_INLINE void LL_RCC_LSE_DisableBypass(void)
{
10042e34:	b580      	push	{r7, lr}
10042e36:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CR, RCC_CR_LSEBYP);
10042e38:	4b04      	ldr	r3, [pc, #16]	@ (10042e4c <LL_RCC_LSE_DisableBypass+0x18>)
10042e3a:	681a      	ldr	r2, [r3, #0]
10042e3c:	4b03      	ldr	r3, [pc, #12]	@ (10042e4c <LL_RCC_LSE_DisableBypass+0x18>)
10042e3e:	2140      	movs	r1, #64	@ 0x40
10042e40:	438a      	bics	r2, r1
10042e42:	601a      	str	r2, [r3, #0]
}
10042e44:	46c0      	nop			@ (mov r8, r8)
10042e46:	46bd      	mov	sp, r7
10042e48:	bd80      	pop	{r7, pc}
10042e4a:	46c0      	nop			@ (mov r8, r8)
10042e4c:	48400000 	.word	0x48400000

10042e50 <LL_RCC_LSE_IsBypassEnabled>:
  * @brief  Check if LSE bypass configuration is enabled.
  * @rmtoll CR         LSEBYP        LL_RCC_LSE_IsBypassEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_LSE_IsBypassEnabled(void)
{
10042e50:	b580      	push	{r7, lr}
10042e52:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_LSEBYP) == (RCC_CR_LSEBYP)) ? 1UL : 0UL);
10042e54:	4b05      	ldr	r3, [pc, #20]	@ (10042e6c <LL_RCC_LSE_IsBypassEnabled+0x1c>)
10042e56:	681b      	ldr	r3, [r3, #0]
10042e58:	2240      	movs	r2, #64	@ 0x40
10042e5a:	4013      	ands	r3, r2
10042e5c:	2b40      	cmp	r3, #64	@ 0x40
10042e5e:	d101      	bne.n	10042e64 <LL_RCC_LSE_IsBypassEnabled+0x14>
10042e60:	2301      	movs	r3, #1
10042e62:	e000      	b.n	10042e66 <LL_RCC_LSE_IsBypassEnabled+0x16>
10042e64:	2300      	movs	r3, #0
}
10042e66:	0018      	movs	r0, r3
10042e68:	46bd      	mov	sp, r7
10042e6a:	bd80      	pop	{r7, pc}
10042e6c:	48400000 	.word	0x48400000

10042e70 <LL_RCC_LSE_SetDriveCapability>:
  *         @arg @ref LL_RCC_LSEDRIVE_MEDIUMHIGH
  *         @arg @ref LL_RCC_LSEDRIVE_HIGH
  * @retval None
  */
__STATIC_INLINE void LL_RCC_LSE_SetDriveCapability(uint32_t LSEDrive)
{
10042e70:	b580      	push	{r7, lr}
10042e72:	b082      	sub	sp, #8
10042e74:	af00      	add	r7, sp, #0
10042e76:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CSSWCR, RCC_CSSWCR_LSEDRV, LSEDrive);
10042e78:	4b06      	ldr	r3, [pc, #24]	@ (10042e94 <LL_RCC_LSE_SetDriveCapability+0x24>)
10042e7a:	68db      	ldr	r3, [r3, #12]
10042e7c:	2260      	movs	r2, #96	@ 0x60
10042e7e:	4393      	bics	r3, r2
10042e80:	0019      	movs	r1, r3
10042e82:	4b04      	ldr	r3, [pc, #16]	@ (10042e94 <LL_RCC_LSE_SetDriveCapability+0x24>)
10042e84:	687a      	ldr	r2, [r7, #4]
10042e86:	430a      	orrs	r2, r1
10042e88:	60da      	str	r2, [r3, #12]
}
10042e8a:	46c0      	nop			@ (mov r8, r8)
10042e8c:	46bd      	mov	sp, r7
10042e8e:	b002      	add	sp, #8
10042e90:	bd80      	pop	{r7, pc}
10042e92:	46c0      	nop			@ (mov r8, r8)
10042e94:	48400000 	.word	0x48400000

10042e98 <LL_RCC_LSI_Enable>:
  * @brief  Enable LSI Oscillator
  * @rmtoll CR          LSION         LL_RCC_LSI_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_LSI_Enable(void)
{
10042e98:	b580      	push	{r7, lr}
10042e9a:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CR, RCC_CR_LSION);
10042e9c:	4b04      	ldr	r3, [pc, #16]	@ (10042eb0 <LL_RCC_LSI_Enable+0x18>)
10042e9e:	681a      	ldr	r2, [r3, #0]
10042ea0:	4b03      	ldr	r3, [pc, #12]	@ (10042eb0 <LL_RCC_LSI_Enable+0x18>)
10042ea2:	2104      	movs	r1, #4
10042ea4:	430a      	orrs	r2, r1
10042ea6:	601a      	str	r2, [r3, #0]
}
10042ea8:	46c0      	nop			@ (mov r8, r8)
10042eaa:	46bd      	mov	sp, r7
10042eac:	bd80      	pop	{r7, pc}
10042eae:	46c0      	nop			@ (mov r8, r8)
10042eb0:	48400000 	.word	0x48400000

10042eb4 <LL_RCC_LSI_Disable>:
  * @brief  Disable LSI Oscillator
  * @rmtoll CR          LSION         LL_RCC_LSI_Disable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_LSI_Disable(void)
{
10042eb4:	b580      	push	{r7, lr}
10042eb6:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CR, RCC_CR_LSION);
10042eb8:	4b04      	ldr	r3, [pc, #16]	@ (10042ecc <LL_RCC_LSI_Disable+0x18>)
10042eba:	681a      	ldr	r2, [r3, #0]
10042ebc:	4b03      	ldr	r3, [pc, #12]	@ (10042ecc <LL_RCC_LSI_Disable+0x18>)
10042ebe:	2104      	movs	r1, #4
10042ec0:	438a      	bics	r2, r1
10042ec2:	601a      	str	r2, [r3, #0]
}
10042ec4:	46c0      	nop			@ (mov r8, r8)
10042ec6:	46bd      	mov	sp, r7
10042ec8:	bd80      	pop	{r7, pc}
10042eca:	46c0      	nop			@ (mov r8, r8)
10042ecc:	48400000 	.word	0x48400000

10042ed0 <LL_RCC_LSI_IsReady>:
  * @brief  Check if LSI is Ready
  * @rmtoll CR          LSIRDY        LL_RCC_LSI_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_LSI_IsReady(void)
{
10042ed0:	b580      	push	{r7, lr}
10042ed2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_LSIRDY) == (RCC_CR_LSIRDY)) ? 1UL : 0UL);
10042ed4:	4b05      	ldr	r3, [pc, #20]	@ (10042eec <LL_RCC_LSI_IsReady+0x1c>)
10042ed6:	681b      	ldr	r3, [r3, #0]
10042ed8:	2208      	movs	r2, #8
10042eda:	4013      	ands	r3, r2
10042edc:	2b08      	cmp	r3, #8
10042ede:	d101      	bne.n	10042ee4 <LL_RCC_LSI_IsReady+0x14>
10042ee0:	2301      	movs	r3, #1
10042ee2:	e000      	b.n	10042ee6 <LL_RCC_LSI_IsReady+0x16>
10042ee4:	2300      	movs	r3, #0
}
10042ee6:	0018      	movs	r0, r3
10042ee8:	46bd      	mov	sp, r7
10042eea:	bd80      	pop	{r7, pc}
10042eec:	48400000 	.word	0x48400000

10042ef0 <LL_RCC_RC64MPLL_Enable>:
  * @brief  Enable RC64MPLL
  * @rmtoll CR           HSIPLLON         LL_RCC_RC64MPLL_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_RC64MPLL_Enable(void)
{
10042ef0:	b580      	push	{r7, lr}
10042ef2:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CR, RCC_CR_HSIPLLON);
10042ef4:	4b04      	ldr	r3, [pc, #16]	@ (10042f08 <LL_RCC_RC64MPLL_Enable+0x18>)
10042ef6:	681a      	ldr	r2, [r3, #0]
10042ef8:	4b03      	ldr	r3, [pc, #12]	@ (10042f08 <LL_RCC_RC64MPLL_Enable+0x18>)
10042efa:	2180      	movs	r1, #128	@ 0x80
10042efc:	0189      	lsls	r1, r1, #6
10042efe:	430a      	orrs	r2, r1
10042f00:	601a      	str	r2, [r3, #0]
}
10042f02:	46c0      	nop			@ (mov r8, r8)
10042f04:	46bd      	mov	sp, r7
10042f06:	bd80      	pop	{r7, pc}
10042f08:	48400000 	.word	0x48400000

10042f0c <LL_RCC_RC64MPLL_Disable>:
  * @note Cannot be disabled if the RC64MPLL clock is used as the system clock
  * @rmtoll CR           HSIPLLON         LL_RCC_RC64MPLL_Disable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_RC64MPLL_Disable(void)
{
10042f0c:	b580      	push	{r7, lr}
10042f0e:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CR, RCC_CR_HSIPLLON);
10042f10:	4b04      	ldr	r3, [pc, #16]	@ (10042f24 <LL_RCC_RC64MPLL_Disable+0x18>)
10042f12:	681a      	ldr	r2, [r3, #0]
10042f14:	4b03      	ldr	r3, [pc, #12]	@ (10042f24 <LL_RCC_RC64MPLL_Disable+0x18>)
10042f16:	4904      	ldr	r1, [pc, #16]	@ (10042f28 <LL_RCC_RC64MPLL_Disable+0x1c>)
10042f18:	400a      	ands	r2, r1
10042f1a:	601a      	str	r2, [r3, #0]
}
10042f1c:	46c0      	nop			@ (mov r8, r8)
10042f1e:	46bd      	mov	sp, r7
10042f20:	bd80      	pop	{r7, pc}
10042f22:	46c0      	nop			@ (mov r8, r8)
10042f24:	48400000 	.word	0x48400000
10042f28:	ffffdfff 	.word	0xffffdfff

10042f2c <LL_RCC_RC64MPLL_IsReady>:
  * @brief  Check if RC64MPLL is Ready
  * @rmtoll CR           HSIPLLRDY        LL_RCC_RC64MPLL_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_RC64MPLL_IsReady(void)
{
10042f2c:	b580      	push	{r7, lr}
10042f2e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_HSIPLLRDY) == (RCC_CR_HSIPLLRDY)) ? 1UL : 0UL);
10042f30:	4b07      	ldr	r3, [pc, #28]	@ (10042f50 <LL_RCC_RC64MPLL_IsReady+0x24>)
10042f32:	681a      	ldr	r2, [r3, #0]
10042f34:	2380      	movs	r3, #128	@ 0x80
10042f36:	01db      	lsls	r3, r3, #7
10042f38:	401a      	ands	r2, r3
10042f3a:	2380      	movs	r3, #128	@ 0x80
10042f3c:	01db      	lsls	r3, r3, #7
10042f3e:	429a      	cmp	r2, r3
10042f40:	d101      	bne.n	10042f46 <LL_RCC_RC64MPLL_IsReady+0x1a>
10042f42:	2301      	movs	r3, #1
10042f44:	e000      	b.n	10042f48 <LL_RCC_RC64MPLL_IsReady+0x1c>
10042f46:	2300      	movs	r3, #0
}
10042f48:	0018      	movs	r0, r3
10042f4a:	46bd      	mov	sp, r7
10042f4c:	bd80      	pop	{r7, pc}
10042f4e:	46c0      	nop			@ (mov r8, r8)
10042f50:	48400000 	.word	0x48400000

10042f54 <LL_RCC_SetRC64MPLLPrescaler>:
  *         @arg @ref LL_RCC_RC64MPLL_DIV_32
  *         @arg @ref LL_RCC_RC64MPLL_DIV_64
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetRC64MPLLPrescaler(uint32_t Prescaler)
{
10042f54:	b580      	push	{r7, lr}
10042f56:	b082      	sub	sp, #8
10042f58:	af00      	add	r7, sp, #0
10042f5a:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_CLKSYSDIV, Prescaler);
10042f5c:	4b06      	ldr	r3, [pc, #24]	@ (10042f78 <LL_RCC_SetRC64MPLLPrescaler+0x24>)
10042f5e:	689b      	ldr	r3, [r3, #8]
10042f60:	22e0      	movs	r2, #224	@ 0xe0
10042f62:	4393      	bics	r3, r2
10042f64:	0019      	movs	r1, r3
10042f66:	4b04      	ldr	r3, [pc, #16]	@ (10042f78 <LL_RCC_SetRC64MPLLPrescaler+0x24>)
10042f68:	687a      	ldr	r2, [r7, #4]
10042f6a:	430a      	orrs	r2, r1
10042f6c:	609a      	str	r2, [r3, #8]
}
10042f6e:	46c0      	nop			@ (mov r8, r8)
10042f70:	46bd      	mov	sp, r7
10042f72:	b002      	add	sp, #8
10042f74:	bd80      	pop	{r7, pc}
10042f76:	46c0      	nop			@ (mov r8, r8)
10042f78:	48400000 	.word	0x48400000

10042f7c <HAL_RCC_OscConfig>:
  * @param  RCC_OscInitStruct  pointer to a @ref RCC_OscInitTypeDef structure that
  *         contains the configuration information for the RCC Oscillators.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
10042f7c:	b580      	push	{r7, lr}
10042f7e:	b084      	sub	sp, #16
10042f80:	af00      	add	r7, sp, #0
10042f82:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Check Null pointer */
  if (RCC_OscInitStruct == NULL)
10042f84:	687b      	ldr	r3, [r7, #4]
10042f86:	2b00      	cmp	r3, #0
10042f88:	d101      	bne.n	10042f8e <HAL_RCC_OscConfig+0x12>
  {
    return HAL_ERROR;
10042f8a:	2301      	movs	r3, #1
10042f8c:	e146      	b.n	1004321c <HAL_RCC_OscConfig+0x2a0>

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*------------------------------- HSI Configuration ------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
10042f8e:	687b      	ldr	r3, [r7, #4]
10042f90:	681b      	ldr	r3, [r3, #0]
10042f92:	2210      	movs	r2, #16
10042f94:	4013      	ands	r3, r2
10042f96:	d033      	beq.n	10043000 <HAL_RCC_OscConfig+0x84>
  {
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);
10042f98:	687b      	ldr	r3, [r7, #4]
10042f9a:	689b      	ldr	r3, [r3, #8]
10042f9c:	2b00      	cmp	r3, #0
10042f9e:	d102      	bne.n	10042fa6 <HAL_RCC_OscConfig+0x2a>
10042fa0:	f7ff fe96 	bl	10042cd0 <LL_RCC_HSI_Enable>
10042fa4:	e001      	b.n	10042faa <HAL_RCC_OscConfig+0x2e>
10042fa6:	f7ff fea7 	bl	10042cf8 <LL_RCC_HSI_Disable>

    if(RCC_OscInitStruct->HSIState == RCC_HSI_OFF)
10042faa:	687b      	ldr	r3, [r7, #4]
10042fac:	689b      	ldr	r3, [r3, #8]
10042fae:	2b04      	cmp	r3, #4
10042fb0:	d113      	bne.n	10042fda <HAL_RCC_OscConfig+0x5e>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
10042fb2:	f7fe fd53 	bl	10041a5c <HAL_GetTick>
10042fb6:	0003      	movs	r3, r0
10042fb8:	60fb      	str	r3, [r7, #12]

      /* Wait till HSI is disabled */
      while (LL_RCC_HSI_IsReady() == 1U)
10042fba:	e008      	b.n	10042fce <HAL_RCC_OscConfig+0x52>
      {
        if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
10042fbc:	f7fe fd4e 	bl	10041a5c <HAL_GetTick>
10042fc0:	0002      	movs	r2, r0
10042fc2:	68fb      	ldr	r3, [r7, #12]
10042fc4:	1ad3      	subs	r3, r2, r3
10042fc6:	2b64      	cmp	r3, #100	@ 0x64
10042fc8:	d901      	bls.n	10042fce <HAL_RCC_OscConfig+0x52>
        {
          return HAL_TIMEOUT;
10042fca:	2303      	movs	r3, #3
10042fcc:	e126      	b.n	1004321c <HAL_RCC_OscConfig+0x2a0>
      while (LL_RCC_HSI_IsReady() == 1U)
10042fce:	f7ff fea7 	bl	10042d20 <LL_RCC_HSI_IsReady>
10042fd2:	0003      	movs	r3, r0
10042fd4:	2b01      	cmp	r3, #1
10042fd6:	d0f1      	beq.n	10042fbc <HAL_RCC_OscConfig+0x40>
10042fd8:	e012      	b.n	10043000 <HAL_RCC_OscConfig+0x84>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
10042fda:	f7fe fd3f 	bl	10041a5c <HAL_GetTick>
10042fde:	0003      	movs	r3, r0
10042fe0:	60fb      	str	r3, [r7, #12]

      /* Wait till HSI is enabled */
      while (LL_RCC_HSI_IsReady() != 1U)
10042fe2:	e008      	b.n	10042ff6 <HAL_RCC_OscConfig+0x7a>
      {
        if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
10042fe4:	f7fe fd3a 	bl	10041a5c <HAL_GetTick>
10042fe8:	0002      	movs	r2, r0
10042fea:	68fb      	ldr	r3, [r7, #12]
10042fec:	1ad3      	subs	r3, r2, r3
10042fee:	2b64      	cmp	r3, #100	@ 0x64
10042ff0:	d901      	bls.n	10042ff6 <HAL_RCC_OscConfig+0x7a>
        {
          return HAL_TIMEOUT;
10042ff2:	2303      	movs	r3, #3
10042ff4:	e112      	b.n	1004321c <HAL_RCC_OscConfig+0x2a0>
      while (LL_RCC_HSI_IsReady() != 1U)
10042ff6:	f7ff fe93 	bl	10042d20 <LL_RCC_HSI_IsReady>
10042ffa:	0003      	movs	r3, r0
10042ffc:	2b01      	cmp	r3, #1
10042ffe:	d1f1      	bne.n	10042fe4 <HAL_RCC_OscConfig+0x68>
      }
    }
  }

  /*------------------------------- HSE Configuration ------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
10043000:	687b      	ldr	r3, [r7, #4]
10043002:	681b      	ldr	r3, [r3, #0]
10043004:	2201      	movs	r2, #1
10043006:	4013      	ands	r3, r2
10043008:	d03f      	beq.n	1004308a <HAL_RCC_OscConfig+0x10e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    /* Set HSE Capacitor Tuning */
    LL_RCC_HSE_SetCapacitorTuning(CFG_HW_RCC_HSE_CAPACITOR_TUNE);
1004300a:	2020      	movs	r0, #32
1004300c:	f7ff fdf4 	bl	10042bf8 <LL_RCC_HSE_SetCapacitorTuning>

    /* Set HSE startup Current */
    LL_RCC_HSE_SetStartupCurrent(0);
10043010:	2000      	movs	r0, #0
10043012:	f7ff fe29 	bl	10042c68 <LL_RCC_HSE_SetStartupCurrent>

    /*  Set HSE Amplitude Threshold */
    LL_RCC_HSE_SetAmplitudeThreshold(0);
10043016:	2000      	movs	r0, #0
10043018:	f7ff fe40 	bl	10042c9c <LL_RCC_HSE_SetAmplitudeThreshold>

    /* Set HSE Current Control */
    LL_RCC_HSE_SetCurrentControl(40);
1004301c:	2028      	movs	r0, #40	@ 0x28
1004301e:	f7ff fe0b 	bl	10042c38 <LL_RCC_HSE_SetCurrentControl>

    /* Set the new HSE configuration ---------------------------------------*/
    __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
10043022:	687b      	ldr	r3, [r7, #4]
10043024:	685a      	ldr	r2, [r3, #4]
10043026:	2380      	movs	r3, #128	@ 0x80
10043028:	025b      	lsls	r3, r3, #9
1004302a:	429a      	cmp	r2, r3
1004302c:	d102      	bne.n	10043034 <HAL_RCC_OscConfig+0xb8>
1004302e:	f7ff fdb1 	bl	10042b94 <LL_RCC_HSE_Enable>
10043032:	e001      	b.n	10043038 <HAL_RCC_OscConfig+0xbc>
10043034:	f7ff fdbc 	bl	10042bb0 <LL_RCC_HSE_Disable>

    /* Check the HSE State */
    if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
10043038:	687b      	ldr	r3, [r7, #4]
1004303a:	685b      	ldr	r3, [r3, #4]
1004303c:	2b00      	cmp	r3, #0
1004303e:	d012      	beq.n	10043066 <HAL_RCC_OscConfig+0xea>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
10043040:	f7fe fd0c 	bl	10041a5c <HAL_GetTick>
10043044:	0003      	movs	r3, r0
10043046:	60fb      	str	r3, [r7, #12]

      /* Wait till HSE is ready */
      while (LL_RCC_HSE_IsReady() == 0U)
10043048:	e008      	b.n	1004305c <HAL_RCC_OscConfig+0xe0>
      {
        if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
1004304a:	f7fe fd07 	bl	10041a5c <HAL_GetTick>
1004304e:	0002      	movs	r2, r0
10043050:	68fb      	ldr	r3, [r7, #12]
10043052:	1ad3      	subs	r3, r2, r3
10043054:	2b64      	cmp	r3, #100	@ 0x64
10043056:	d901      	bls.n	1004305c <HAL_RCC_OscConfig+0xe0>
        {
          return HAL_TIMEOUT;
10043058:	2303      	movs	r3, #3
1004305a:	e0df      	b.n	1004321c <HAL_RCC_OscConfig+0x2a0>
      while (LL_RCC_HSE_IsReady() == 0U)
1004305c:	f7ff fdb8 	bl	10042bd0 <LL_RCC_HSE_IsReady>
10043060:	1e03      	subs	r3, r0, #0
10043062:	d0f2      	beq.n	1004304a <HAL_RCC_OscConfig+0xce>
10043064:	e011      	b.n	1004308a <HAL_RCC_OscConfig+0x10e>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
10043066:	f7fe fcf9 	bl	10041a5c <HAL_GetTick>
1004306a:	0003      	movs	r3, r0
1004306c:	60fb      	str	r3, [r7, #12]

      /* Wait till HSE is disabled */
      while (LL_RCC_HSE_IsReady() != 0U)
1004306e:	e008      	b.n	10043082 <HAL_RCC_OscConfig+0x106>
      {
        if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
10043070:	f7fe fcf4 	bl	10041a5c <HAL_GetTick>
10043074:	0002      	movs	r2, r0
10043076:	68fb      	ldr	r3, [r7, #12]
10043078:	1ad3      	subs	r3, r2, r3
1004307a:	2b64      	cmp	r3, #100	@ 0x64
1004307c:	d901      	bls.n	10043082 <HAL_RCC_OscConfig+0x106>
        {
          return HAL_TIMEOUT;
1004307e:	2303      	movs	r3, #3
10043080:	e0cc      	b.n	1004321c <HAL_RCC_OscConfig+0x2a0>
      while (LL_RCC_HSE_IsReady() != 0U)
10043082:	f7ff fda5 	bl	10042bd0 <LL_RCC_HSE_IsReady>
10043086:	1e03      	subs	r3, r0, #0
10043088:	d1f2      	bne.n	10043070 <HAL_RCC_OscConfig+0xf4>
      }
    }
  }

  /*--------------------------------- LSI Configuration -----------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
1004308a:	687b      	ldr	r3, [r7, #4]
1004308c:	681b      	ldr	r3, [r3, #0]
1004308e:	2204      	movs	r2, #4
10043090:	4013      	ands	r3, r2
10043092:	d03a      	beq.n	1004310a <HAL_RCC_OscConfig+0x18e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if (RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
10043094:	687b      	ldr	r3, [r7, #4]
10043096:	691b      	ldr	r3, [r3, #16]
10043098:	2b00      	cmp	r3, #0
1004309a:	d022      	beq.n	100430e2 <HAL_RCC_OscConfig+0x166>
    {
      /* Disable the LSI */
      __HAL_RCC_LSI_DISABLE();
1004309c:	f7ff ff0a 	bl	10042eb4 <LL_RCC_LSI_Disable>
      while (__HAL_RCC_GET_LSI_READYFLAG() != 0U);
100430a0:	46c0      	nop			@ (mov r8, r8)
100430a2:	f7ff ff15 	bl	10042ed0 <LL_RCC_LSI_IsReady>
100430a6:	1e03      	subs	r3, r0, #0
100430a8:	d1fb      	bne.n	100430a2 <HAL_RCC_OscConfig+0x126>

      /* Disable the LSE */
      __HAL_RCC_LSE_CONFIG(RCC_LSE_OFF);
100430aa:	f7ff fe97 	bl	10042ddc <LL_RCC_LSE_Disable>

      /* Configure the Low Speed Clock to LSI */
      LL_RCC_LSCO_SetSource(LL_RCC_LSCO_CLKSOURCE_LSI);
100430ae:	2380      	movs	r3, #128	@ 0x80
100430b0:	025b      	lsls	r3, r3, #9
100430b2:	0018      	movs	r0, r3
100430b4:	f7ff fe6e 	bl	10042d94 <LL_RCC_LSCO_SetSource>

      /*  Enable the Internal Low Speed oscillator (LSI)  */
      __HAL_RCC_LSI_ENABLE();
100430b8:	f7ff feee 	bl	10042e98 <LL_RCC_LSI_Enable>

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
100430bc:	f7fe fcce 	bl	10041a5c <HAL_GetTick>
100430c0:	0003      	movs	r3, r0
100430c2:	60fb      	str	r3, [r7, #12]

      /* Wait till LSI is ready */
      while (__HAL_RCC_GET_LSI_READYFLAG() == 0U)
100430c4:	e008      	b.n	100430d8 <HAL_RCC_OscConfig+0x15c>
      {
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
100430c6:	f7fe fcc9 	bl	10041a5c <HAL_GetTick>
100430ca:	0002      	movs	r2, r0
100430cc:	68fb      	ldr	r3, [r7, #12]
100430ce:	1ad3      	subs	r3, r2, r3
100430d0:	2b02      	cmp	r3, #2
100430d2:	d901      	bls.n	100430d8 <HAL_RCC_OscConfig+0x15c>
        {
          return HAL_TIMEOUT;
100430d4:	2303      	movs	r3, #3
100430d6:	e0a1      	b.n	1004321c <HAL_RCC_OscConfig+0x2a0>
      while (__HAL_RCC_GET_LSI_READYFLAG() == 0U)
100430d8:	f7ff fefa 	bl	10042ed0 <LL_RCC_LSI_IsReady>
100430dc:	1e03      	subs	r3, r0, #0
100430de:	d0f2      	beq.n	100430c6 <HAL_RCC_OscConfig+0x14a>
100430e0:	e013      	b.n	1004310a <HAL_RCC_OscConfig+0x18e>
    }
    else
    {

      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
100430e2:	f7ff fee7 	bl	10042eb4 <LL_RCC_LSI_Disable>

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
100430e6:	f7fe fcb9 	bl	10041a5c <HAL_GetTick>
100430ea:	0003      	movs	r3, r0
100430ec:	60fb      	str	r3, [r7, #12]

      /* Wait till LSI is disabled */
      while (__HAL_RCC_GET_LSI_READYFLAG() != 0U)
100430ee:	e008      	b.n	10043102 <HAL_RCC_OscConfig+0x186>
      {
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
100430f0:	f7fe fcb4 	bl	10041a5c <HAL_GetTick>
100430f4:	0002      	movs	r2, r0
100430f6:	68fb      	ldr	r3, [r7, #12]
100430f8:	1ad3      	subs	r3, r2, r3
100430fa:	2b02      	cmp	r3, #2
100430fc:	d901      	bls.n	10043102 <HAL_RCC_OscConfig+0x186>
        {
          return HAL_TIMEOUT;
100430fe:	2303      	movs	r3, #3
10043100:	e08c      	b.n	1004321c <HAL_RCC_OscConfig+0x2a0>
      while (__HAL_RCC_GET_LSI_READYFLAG() != 0U)
10043102:	f7ff fee5 	bl	10042ed0 <LL_RCC_LSI_IsReady>
10043106:	1e03      	subs	r3, r0, #0
10043108:	d1f2      	bne.n	100430f0 <HAL_RCC_OscConfig+0x174>
      }
    }
  }

  /*------------------------------ LSE Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
1004310a:	687b      	ldr	r3, [r7, #4]
1004310c:	681b      	ldr	r3, [r3, #0]
1004310e:	2202      	movs	r2, #2
10043110:	4013      	ands	r3, r2
10043112:	d049      	beq.n	100431a8 <HAL_RCC_OscConfig+0x22c>

    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Disable LSI */
    __HAL_RCC_LSI_DISABLE();
10043114:	f7ff fece 	bl	10042eb4 <LL_RCC_LSI_Disable>

    /* Disable LSE */
    __HAL_RCC_LSE_CONFIG(RCC_LSE_OFF);
10043118:	f7ff fe60 	bl	10042ddc <LL_RCC_LSE_Disable>
    while (__HAL_RCC_GET_LSE_READYFLAG() != 0);
1004311c:	46c0      	nop			@ (mov r8, r8)
1004311e:	f7ff fe6b 	bl	10042df8 <LL_RCC_LSE_IsReady>
10043122:	1e03      	subs	r3, r0, #0
10043124:	d1fb      	bne.n	1004311e <HAL_RCC_OscConfig+0x1a2>

    /* Configure the PB12 and PB13 in NO PULL mode */
    LL_PWR_SetNoPullB(LL_PWR_GPIO_BIT_12 |
10043126:	23c0      	movs	r3, #192	@ 0xc0
10043128:	019b      	lsls	r3, r3, #6
1004312a:	0018      	movs	r0, r3
1004312c:	f7ff fd1a 	bl	10042b64 <LL_PWR_SetNoPullB>
                      LL_PWR_GPIO_BIT_13);

    /* Configure the Low Speed Clock to LSE */
    LL_RCC_LSCO_SetSource(LL_RCC_LSCO_CLKSOURCE_LSE);
10043130:	2380      	movs	r3, #128	@ 0x80
10043132:	021b      	lsls	r3, r3, #8
10043134:	0018      	movs	r0, r3
10043136:	f7ff fe2d 	bl	10042d94 <LL_RCC_LSCO_SetSource>

    /* Set LSE oscillator drive capability */
    __HAL_RCC_LSEDRIVE_CONFIG(RCC_LSEDRIVE_MEDIUMLOW);
1004313a:	2020      	movs	r0, #32
1004313c:	f7ff fe98 	bl	10042e70 <LL_RCC_LSE_SetDriveCapability>

    /* Set the new LSE state */
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
10043140:	687b      	ldr	r3, [r7, #4]
10043142:	68db      	ldr	r3, [r3, #12]
10043144:	2b10      	cmp	r3, #16
10043146:	d102      	bne.n	1004314e <HAL_RCC_OscConfig+0x1d2>
10043148:	f7ff fe3a 	bl	10042dc0 <LL_RCC_LSE_Enable>
1004314c:	e001      	b.n	10043152 <HAL_RCC_OscConfig+0x1d6>
1004314e:	f7ff fe45 	bl	10042ddc <LL_RCC_LSE_Disable>

    /* Check the LSE State */
    if (RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
10043152:	687b      	ldr	r3, [r7, #4]
10043154:	68db      	ldr	r3, [r3, #12]
10043156:	2b00      	cmp	r3, #0
10043158:	d013      	beq.n	10043182 <HAL_RCC_OscConfig+0x206>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
1004315a:	f7fe fc7f 	bl	10041a5c <HAL_GetTick>
1004315e:	0003      	movs	r3, r0
10043160:	60fb      	str	r3, [r7, #12]

      /* Wait till LSE is ready */
      while (__HAL_RCC_GET_LSE_READYFLAG() == 0U)
10043162:	e009      	b.n	10043178 <HAL_RCC_OscConfig+0x1fc>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
10043164:	f7fe fc7a 	bl	10041a5c <HAL_GetTick>
10043168:	0002      	movs	r2, r0
1004316a:	68fb      	ldr	r3, [r7, #12]
1004316c:	1ad3      	subs	r3, r2, r3
1004316e:	4a2d      	ldr	r2, [pc, #180]	@ (10043224 <HAL_RCC_OscConfig+0x2a8>)
10043170:	4293      	cmp	r3, r2
10043172:	d901      	bls.n	10043178 <HAL_RCC_OscConfig+0x1fc>
        {
          return HAL_TIMEOUT;
10043174:	2303      	movs	r3, #3
10043176:	e051      	b.n	1004321c <HAL_RCC_OscConfig+0x2a0>
      while (__HAL_RCC_GET_LSE_READYFLAG() == 0U)
10043178:	f7ff fe3e 	bl	10042df8 <LL_RCC_LSE_IsReady>
1004317c:	1e03      	subs	r3, r0, #0
1004317e:	d0f1      	beq.n	10043164 <HAL_RCC_OscConfig+0x1e8>
10043180:	e012      	b.n	100431a8 <HAL_RCC_OscConfig+0x22c>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
10043182:	f7fe fc6b 	bl	10041a5c <HAL_GetTick>
10043186:	0003      	movs	r3, r0
10043188:	60fb      	str	r3, [r7, #12]

      /* Wait till LSE is disabled */
      while (__HAL_RCC_GET_LSE_READYFLAG() != 0U)
1004318a:	e009      	b.n	100431a0 <HAL_RCC_OscConfig+0x224>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
1004318c:	f7fe fc66 	bl	10041a5c <HAL_GetTick>
10043190:	0002      	movs	r2, r0
10043192:	68fb      	ldr	r3, [r7, #12]
10043194:	1ad3      	subs	r3, r2, r3
10043196:	4a23      	ldr	r2, [pc, #140]	@ (10043224 <HAL_RCC_OscConfig+0x2a8>)
10043198:	4293      	cmp	r3, r2
1004319a:	d901      	bls.n	100431a0 <HAL_RCC_OscConfig+0x224>
        {
          return HAL_TIMEOUT;
1004319c:	2303      	movs	r3, #3
1004319e:	e03d      	b.n	1004321c <HAL_RCC_OscConfig+0x2a0>
      while (__HAL_RCC_GET_LSE_READYFLAG() != 0U)
100431a0:	f7ff fe2a 	bl	10042df8 <LL_RCC_LSE_IsReady>
100431a4:	1e03      	subs	r3, r0, #0
100431a6:	d1f1      	bne.n	1004318c <HAL_RCC_OscConfig+0x210>
      }
    }
  }

  /*------------------------------ LSE Bypass Configuration ------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE_BYPASS) == RCC_OSCILLATORTYPE_LSE_BYPASS)
100431a8:	687b      	ldr	r3, [r7, #4]
100431aa:	681b      	ldr	r3, [r3, #0]
100431ac:	2208      	movs	r2, #8
100431ae:	4013      	ands	r3, r2
100431b0:	d033      	beq.n	1004321a <HAL_RCC_OscConfig+0x29e>

    /* Check the parameters */
    assert_param(IS_RCC_LSE_BYPASS(RCC_OscInitStruct->LSEBYPASSState));

    /* Set the new LSE Bypass configuration -----------------------------------------*/
    __HAL_RCC_LSE_BYPASS_CONFIG(RCC_OscInitStruct->LSEBYPASSState);
100431b2:	687b      	ldr	r3, [r7, #4]
100431b4:	695b      	ldr	r3, [r3, #20]
100431b6:	2b40      	cmp	r3, #64	@ 0x40
100431b8:	d102      	bne.n	100431c0 <HAL_RCC_OscConfig+0x244>
100431ba:	f7ff fe2d 	bl	10042e18 <LL_RCC_LSE_EnableBypass>
100431be:	e001      	b.n	100431c4 <HAL_RCC_OscConfig+0x248>
100431c0:	f7ff fe38 	bl	10042e34 <LL_RCC_LSE_DisableBypass>

    /* Check the LSE Bypass State */
    if (RCC_OscInitStruct->LSEBYPASSState != RCC_LSE_OFF)
100431c4:	687b      	ldr	r3, [r7, #4]
100431c6:	695b      	ldr	r3, [r3, #20]
100431c8:	2b00      	cmp	r3, #0
100431ca:	d013      	beq.n	100431f4 <HAL_RCC_OscConfig+0x278>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
100431cc:	f7fe fc46 	bl	10041a5c <HAL_GetTick>
100431d0:	0003      	movs	r3, r0
100431d2:	60fb      	str	r3, [r7, #12]

      /* Wait till LSE is ready */
      while (LL_RCC_LSE_IsBypassEnabled() == 0U)
100431d4:	e009      	b.n	100431ea <HAL_RCC_OscConfig+0x26e>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
100431d6:	f7fe fc41 	bl	10041a5c <HAL_GetTick>
100431da:	0002      	movs	r2, r0
100431dc:	68fb      	ldr	r3, [r7, #12]
100431de:	1ad3      	subs	r3, r2, r3
100431e0:	4a10      	ldr	r2, [pc, #64]	@ (10043224 <HAL_RCC_OscConfig+0x2a8>)
100431e2:	4293      	cmp	r3, r2
100431e4:	d901      	bls.n	100431ea <HAL_RCC_OscConfig+0x26e>
        {
          return HAL_TIMEOUT;
100431e6:	2303      	movs	r3, #3
100431e8:	e018      	b.n	1004321c <HAL_RCC_OscConfig+0x2a0>
      while (LL_RCC_LSE_IsBypassEnabled() == 0U)
100431ea:	f7ff fe31 	bl	10042e50 <LL_RCC_LSE_IsBypassEnabled>
100431ee:	1e03      	subs	r3, r0, #0
100431f0:	d0f1      	beq.n	100431d6 <HAL_RCC_OscConfig+0x25a>
100431f2:	e012      	b.n	1004321a <HAL_RCC_OscConfig+0x29e>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
100431f4:	f7fe fc32 	bl	10041a5c <HAL_GetTick>
100431f8:	0003      	movs	r3, r0
100431fa:	60fb      	str	r3, [r7, #12]

      /* Wait till LSE is disabled */
      while (LL_RCC_LSE_IsBypassEnabled() != 0U)
100431fc:	e009      	b.n	10043212 <HAL_RCC_OscConfig+0x296>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
100431fe:	f7fe fc2d 	bl	10041a5c <HAL_GetTick>
10043202:	0002      	movs	r2, r0
10043204:	68fb      	ldr	r3, [r7, #12]
10043206:	1ad3      	subs	r3, r2, r3
10043208:	4a06      	ldr	r2, [pc, #24]	@ (10043224 <HAL_RCC_OscConfig+0x2a8>)
1004320a:	4293      	cmp	r3, r2
1004320c:	d901      	bls.n	10043212 <HAL_RCC_OscConfig+0x296>
        {
          return HAL_TIMEOUT;
1004320e:	2303      	movs	r3, #3
10043210:	e004      	b.n	1004321c <HAL_RCC_OscConfig+0x2a0>
      while (LL_RCC_LSE_IsBypassEnabled() != 0U)
10043212:	f7ff fe1d 	bl	10042e50 <LL_RCC_LSE_IsBypassEnabled>
10043216:	1e03      	subs	r3, r0, #0
10043218:	d1f1      	bne.n	100431fe <HAL_RCC_OscConfig+0x282>
        }
      }
    }
  }

  return HAL_OK;
1004321a:	2300      	movs	r3, #0
}
1004321c:	0018      	movs	r0, r3
1004321e:	46bd      	mov	sp, r7
10043220:	b004      	add	sp, #16
10043222:	bd80      	pop	{r7, pc}
10043224:	00001388 	.word	0x00001388

10043228 <HAL_RCC_ClockConfig>:
  *         currently used as system clock source.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
10043228:	b580      	push	{r7, lr}
1004322a:	b084      	sub	sp, #16
1004322c:	af00      	add	r7, sp, #0
1004322e:	6078      	str	r0, [r7, #4]
10043230:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;

  /* Check Null pointer */
  if (RCC_ClkInitStruct == NULL)
10043232:	687b      	ldr	r3, [r7, #4]
10043234:	2b00      	cmp	r3, #0
10043236:	d101      	bne.n	1004323c <HAL_RCC_ClockConfig+0x14>
  {
    return HAL_ERROR;
10043238:	2301      	movs	r3, #1
1004323a:	e08e      	b.n	1004335a <HAL_RCC_ClockConfig+0x132>

  /* Check the parameters */
  assert_param(IS_FLASH_WAIT_STATES(FLatency));

  /* Set FALSH_WAIT_STATES_1 */
  __HAL_FLASH_SET_WAIT_STATES(FLatency);
1004323c:	4b49      	ldr	r3, [pc, #292]	@ (10043364 <HAL_RCC_ClockConfig+0x13c>)
1004323e:	685b      	ldr	r3, [r3, #4]
10043240:	2230      	movs	r2, #48	@ 0x30
10043242:	4393      	bics	r3, r2
10043244:	0019      	movs	r1, r3
10043246:	4b47      	ldr	r3, [pc, #284]	@ (10043364 <HAL_RCC_ClockConfig+0x13c>)
10043248:	683a      	ldr	r2, [r7, #0]
1004324a:	430a      	orrs	r2, r1
1004324c:	605a      	str	r2, [r3, #4]
  /*------------------------- SYSCLK Configuration ---------------------------*/
  assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
  assert_param(IS_RCC_SYSCLK_DIVIDER(RCC_ClkInitStruct->SYSCLKDivider));

  /* HSI is selected as System Clock Source */
  if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI)
1004324e:	687b      	ldr	r3, [r7, #4]
10043250:	681b      	ldr	r3, [r3, #0]
10043252:	2b02      	cmp	r3, #2
10043254:	d10e      	bne.n	10043274 <HAL_RCC_ClockConfig+0x4c>
  {
    LL_RCC_HSI_Enable();
10043256:	f7ff fd3b 	bl	10042cd0 <LL_RCC_HSI_Enable>
    
    /* Check the HSI ready flag */
    if (LL_RCC_HSI_IsReady() == 0U)
1004325a:	f7ff fd61 	bl	10042d20 <LL_RCC_HSI_IsReady>
1004325e:	1e03      	subs	r3, r0, #0
10043260:	d101      	bne.n	10043266 <HAL_RCC_ClockConfig+0x3e>
    {
      return HAL_ERROR;
10043262:	2301      	movs	r3, #1
10043264:	e079      	b.n	1004335a <HAL_RCC_ClockConfig+0x132>
    }

    /* Disable the RC64MPLL*/
    __HAL_RCC_RC64MPLL_DISABLE();
10043266:	f7ff fe51 	bl	10042f0c <LL_RCC_RC64MPLL_Disable>
    
    /* Configure the RC64MPLL multiplication factor */
    __HAL_RCC_RC64MPLL_PRESC_CONFIG(RCC_ClkInitStruct->SYSCLKDivider);
1004326a:	687b      	ldr	r3, [r7, #4]
1004326c:	685b      	ldr	r3, [r3, #4]
1004326e:	0018      	movs	r0, r3
10043270:	f7ff fe70 	bl	10042f54 <LL_RCC_SetRC64MPLLPrescaler>
  }

  /* RC64MPLL is selected as System Clock Source */
  if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_RC64MPLL)
10043274:	687b      	ldr	r3, [r7, #4]
10043276:	681b      	ldr	r3, [r3, #0]
10043278:	2b00      	cmp	r3, #0
1004327a:	d124      	bne.n	100432c6 <HAL_RCC_ClockConfig+0x9e>
  {
    /* Check the HSI ready flag */
    if (LL_RCC_HSI_IsReady() == 0U)
1004327c:	f7ff fd50 	bl	10042d20 <LL_RCC_HSI_IsReady>
10043280:	1e03      	subs	r3, r0, #0
10043282:	d101      	bne.n	10043288 <HAL_RCC_ClockConfig+0x60>
    {
      return HAL_ERROR;
10043284:	2301      	movs	r3, #1
10043286:	e068      	b.n	1004335a <HAL_RCC_ClockConfig+0x132>
    }

    /* Check the HSE ready flag */
    if (LL_RCC_HSE_IsReady() == 0U)
10043288:	f7ff fca2 	bl	10042bd0 <LL_RCC_HSE_IsReady>
1004328c:	1e03      	subs	r3, r0, #0
1004328e:	d101      	bne.n	10043294 <HAL_RCC_ClockConfig+0x6c>
    {
      return HAL_ERROR;
10043290:	2301      	movs	r3, #1
10043292:	e062      	b.n	1004335a <HAL_RCC_ClockConfig+0x132>
    }

    /* Enable the RC64MPLL*/
    __HAL_RCC_RC64MPLL_ENABLE();
10043294:	f7ff fe2c 	bl	10042ef0 <LL_RCC_RC64MPLL_Enable>

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
10043298:	f7fe fbe0 	bl	10041a5c <HAL_GetTick>
1004329c:	0003      	movs	r3, r0
1004329e:	60fb      	str	r3, [r7, #12]

    /* Wait till RC64MPLL is ready */
    while (LL_RCC_RC64MPLL_IsReady() == 0)
100432a0:	e008      	b.n	100432b4 <HAL_RCC_ClockConfig+0x8c>
    {
      if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
100432a2:	f7fe fbdb 	bl	10041a5c <HAL_GetTick>
100432a6:	0002      	movs	r2, r0
100432a8:	68fb      	ldr	r3, [r7, #12]
100432aa:	1ad3      	subs	r3, r2, r3
100432ac:	2b02      	cmp	r3, #2
100432ae:	d901      	bls.n	100432b4 <HAL_RCC_ClockConfig+0x8c>
      {
        return HAL_TIMEOUT;
100432b0:	2303      	movs	r3, #3
100432b2:	e052      	b.n	1004335a <HAL_RCC_ClockConfig+0x132>
    while (LL_RCC_RC64MPLL_IsReady() == 0)
100432b4:	f7ff fe3a 	bl	10042f2c <LL_RCC_RC64MPLL_IsReady>
100432b8:	1e03      	subs	r3, r0, #0
100432ba:	d0f2      	beq.n	100432a2 <HAL_RCC_ClockConfig+0x7a>
      }
    }

    /* Configure the RC64MPLL multiplication factor */
    __HAL_RCC_RC64MPLL_PRESC_CONFIG(RCC_ClkInitStruct->SYSCLKDivider);
100432bc:	687b      	ldr	r3, [r7, #4]
100432be:	685b      	ldr	r3, [r3, #4]
100432c0:	0018      	movs	r0, r3
100432c2:	f7ff fe47 	bl	10042f54 <LL_RCC_SetRC64MPLLPrescaler>
  }

  /* DIRECT_HSE is selected as System Clock Source */
  if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_DIRECT_HSE)
100432c6:	687b      	ldr	r3, [r7, #4]
100432c8:	681b      	ldr	r3, [r3, #0]
100432ca:	2b01      	cmp	r3, #1
100432cc:	d117      	bne.n	100432fe <HAL_RCC_ClockConfig+0xd6>
  {
    /* Enable the DIRECT_HSE configuration */
    LL_RCC_DIRECT_HSE_Enable();
100432ce:	f7ff fd3b 	bl	10042d48 <LL_RCC_DIRECT_HSE_Enable>

    /* Check the HSI ready flag */
    if (LL_RCC_HSI_IsReady() != 0U)
100432d2:	f7ff fd25 	bl	10042d20 <LL_RCC_HSI_IsReady>
100432d6:	1e03      	subs	r3, r0, #0
100432d8:	d001      	beq.n	100432de <HAL_RCC_ClockConfig+0xb6>
    {
      return HAL_ERROR;
100432da:	2301      	movs	r3, #1
100432dc:	e03d      	b.n	1004335a <HAL_RCC_ClockConfig+0x132>
    }

    /* Check the HSE ready flag */
    if (LL_RCC_HSE_IsReady() == 0U)
100432de:	f7ff fc77 	bl	10042bd0 <LL_RCC_HSE_IsReady>
100432e2:	1e03      	subs	r3, r0, #0
100432e4:	d101      	bne.n	100432ea <HAL_RCC_ClockConfig+0xc2>
    {
      return HAL_ERROR;
100432e6:	2301      	movs	r3, #1
100432e8:	e037      	b.n	1004335a <HAL_RCC_ClockConfig+0x132>
    }

    /* Configure the DIRECT_HSE multiplication factor */
    __HAL_RCC_DIRECT_HSE_PRESC_CONFIG(RCC_ClkInitStruct->SYSCLKDivider);
100432ea:	4b1f      	ldr	r3, [pc, #124]	@ (10043368 <HAL_RCC_ClockConfig+0x140>)
100432ec:	689b      	ldr	r3, [r3, #8]
100432ee:	22e0      	movs	r2, #224	@ 0xe0
100432f0:	4393      	bics	r3, r2
100432f2:	0019      	movs	r1, r3
100432f4:	687b      	ldr	r3, [r7, #4]
100432f6:	685a      	ldr	r2, [r3, #4]
100432f8:	4b1b      	ldr	r3, [pc, #108]	@ (10043368 <HAL_RCC_ClockConfig+0x140>)
100432fa:	430a      	orrs	r2, r1
100432fc:	609a      	str	r2, [r3, #8]
  /*----------------------- FLASH Latency Configuration ------------------------*/
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
     must be correctly programmed according to the frequency of the FLASH clock */

  /* Setup flash wait states because according the system clock frequency */
  if (FLatency != __HAL_FLASH_GET_WAIT_STATES())
100432fe:	4b19      	ldr	r3, [pc, #100]	@ (10043364 <HAL_RCC_ClockConfig+0x13c>)
10043300:	685b      	ldr	r3, [r3, #4]
10043302:	2230      	movs	r2, #48	@ 0x30
10043304:	4013      	ands	r3, r2
10043306:	683a      	ldr	r2, [r7, #0]
10043308:	429a      	cmp	r2, r3
1004330a:	d01d      	beq.n	10043348 <HAL_RCC_ClockConfig+0x120>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_CONFIG register */
    __HAL_FLASH_SET_WAIT_STATES(FLatency);
1004330c:	4b15      	ldr	r3, [pc, #84]	@ (10043364 <HAL_RCC_ClockConfig+0x13c>)
1004330e:	685b      	ldr	r3, [r3, #4]
10043310:	2230      	movs	r2, #48	@ 0x30
10043312:	4393      	bics	r3, r2
10043314:	0019      	movs	r1, r3
10043316:	4b13      	ldr	r3, [pc, #76]	@ (10043364 <HAL_RCC_ClockConfig+0x13c>)
10043318:	683a      	ldr	r2, [r7, #0]
1004331a:	430a      	orrs	r2, r1
1004331c:	605a      	str	r2, [r3, #4]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
1004331e:	f7fe fb9d 	bl	10041a5c <HAL_GetTick>
10043322:	0003      	movs	r3, r0
10043324:	60fb      	str	r3, [r7, #12]

    /* Check that the new number of wait states is taken into account to access the Flash
       memory by reading the FLASH_CONFIG register */
    while (__HAL_FLASH_GET_WAIT_STATES() != FLatency)
10043326:	e008      	b.n	1004333a <HAL_RCC_ClockConfig+0x112>
    {
      if ((HAL_GetTick() - tickstart) > LATENCY_TIMEOUT_VALUE)
10043328:	f7fe fb98 	bl	10041a5c <HAL_GetTick>
1004332c:	0002      	movs	r2, r0
1004332e:	68fb      	ldr	r3, [r7, #12]
10043330:	1ad3      	subs	r3, r2, r3
10043332:	2b02      	cmp	r3, #2
10043334:	d901      	bls.n	1004333a <HAL_RCC_ClockConfig+0x112>
      {
        return HAL_TIMEOUT;
10043336:	2303      	movs	r3, #3
10043338:	e00f      	b.n	1004335a <HAL_RCC_ClockConfig+0x132>
    while (__HAL_FLASH_GET_WAIT_STATES() != FLatency)
1004333a:	4b0a      	ldr	r3, [pc, #40]	@ (10043364 <HAL_RCC_ClockConfig+0x13c>)
1004333c:	685b      	ldr	r3, [r3, #4]
1004333e:	2230      	movs	r2, #48	@ 0x30
10043340:	4013      	ands	r3, r2
10043342:	683a      	ldr	r2, [r7, #0]
10043344:	429a      	cmp	r2, r3
10043346:	d1ef      	bne.n	10043328 <HAL_RCC_ClockConfig+0x100>
  }

  /*---------------------------------------------------------------------------*/

  /* Update the SystemCoreClock global variable */
  SystemCoreClockUpdate();
10043348:	f7fd fd64 	bl	10040e14 <SystemCoreClockUpdate>

  /* Configure the source of time base considering new system clocks settings*/
  return HAL_InitTick(HAL_GetTickPrio());
1004334c:	f7fe fb90 	bl	10041a70 <HAL_GetTickPrio>
10043350:	0003      	movs	r3, r0
10043352:	0018      	movs	r0, r3
10043354:	f7fe fb28 	bl	100419a8 <HAL_InitTick>
10043358:	0003      	movs	r3, r0
}
1004335a:	0018      	movs	r0, r3
1004335c:	46bd      	mov	sp, r7
1004335e:	b004      	add	sp, #16
10043360:	bd80      	pop	{r7, pc}
10043362:	46c0      	nop			@ (mov r8, r8)
10043364:	40001000 	.word	0x40001000
10043368:	48400000 	.word	0x48400000

1004336c <HAL_RCC_GetSysClockFreq>:
  *         content of the SystemCoreClock CMSIS variable
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
1004336c:	b580      	push	{r7, lr}
1004336e:	af00      	add	r7, sp, #0
  return SystemCoreClock;
10043370:	4b02      	ldr	r3, [pc, #8]	@ (1004337c <HAL_RCC_GetSysClockFreq+0x10>)
10043372:	681b      	ldr	r3, [r3, #0]
}
10043374:	0018      	movs	r0, r3
10043376:	46bd      	mov	sp, r7
10043378:	bd80      	pop	{r7, pc}
1004337a:	46c0      	nop			@ (mov r8, r8)
1004337c:	20000338 	.word	0x20000338

10043380 <LL_RCC_DIRECT_HSE_IsEnabled>:
{
10043380:	b580      	push	{r7, lr}
10043382:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CFGR, RCC_CFGR_HSESEL_STATUS) == (RCC_CFGR_HSESEL_STATUS)) ? 1UL : 0UL);
10043384:	4b05      	ldr	r3, [pc, #20]	@ (1004339c <LL_RCC_DIRECT_HSE_IsEnabled+0x1c>)
10043386:	689b      	ldr	r3, [r3, #8]
10043388:	2208      	movs	r2, #8
1004338a:	4013      	ands	r3, r2
1004338c:	2b08      	cmp	r3, #8
1004338e:	d101      	bne.n	10043394 <LL_RCC_DIRECT_HSE_IsEnabled+0x14>
10043390:	2301      	movs	r3, #1
10043392:	e000      	b.n	10043396 <LL_RCC_DIRECT_HSE_IsEnabled+0x16>
10043394:	2300      	movs	r3, #0
}
10043396:	0018      	movs	r0, r3
10043398:	46bd      	mov	sp, r7
1004339a:	bd80      	pop	{r7, pc}
1004339c:	48400000 	.word	0x48400000

100433a0 <LL_RCC_LSCO_SetSource>:
{
100433a0:	b580      	push	{r7, lr}
100433a2:	b082      	sub	sp, #8
100433a4:	af00      	add	r7, sp, #0
100433a6:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_CLKSLOWSEL, Source);
100433a8:	4b06      	ldr	r3, [pc, #24]	@ (100433c4 <LL_RCC_LSCO_SetSource+0x24>)
100433aa:	689b      	ldr	r3, [r3, #8]
100433ac:	4a06      	ldr	r2, [pc, #24]	@ (100433c8 <LL_RCC_LSCO_SetSource+0x28>)
100433ae:	4013      	ands	r3, r2
100433b0:	0019      	movs	r1, r3
100433b2:	4b04      	ldr	r3, [pc, #16]	@ (100433c4 <LL_RCC_LSCO_SetSource+0x24>)
100433b4:	687a      	ldr	r2, [r7, #4]
100433b6:	430a      	orrs	r2, r1
100433b8:	609a      	str	r2, [r3, #8]
}
100433ba:	46c0      	nop			@ (mov r8, r8)
100433bc:	46bd      	mov	sp, r7
100433be:	b002      	add	sp, #8
100433c0:	bd80      	pop	{r7, pc}
100433c2:	46c0      	nop			@ (mov r8, r8)
100433c4:	48400000 	.word	0x48400000
100433c8:	fffe7fff 	.word	0xfffe7fff

100433cc <LL_RCC_SetSMPSPrescaler>:
{
100433cc:	b580      	push	{r7, lr}
100433ce:	b082      	sub	sp, #8
100433d0:	af00      	add	r7, sp, #0
100433d2:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_SMPSDIV, Prescaler);
100433d4:	4b06      	ldr	r3, [pc, #24]	@ (100433f0 <LL_RCC_SetSMPSPrescaler+0x24>)
100433d6:	689b      	ldr	r3, [r3, #8]
100433d8:	4a06      	ldr	r2, [pc, #24]	@ (100433f4 <LL_RCC_SetSMPSPrescaler+0x28>)
100433da:	4013      	ands	r3, r2
100433dc:	0019      	movs	r1, r3
100433de:	4b04      	ldr	r3, [pc, #16]	@ (100433f0 <LL_RCC_SetSMPSPrescaler+0x24>)
100433e0:	687a      	ldr	r2, [r7, #4]
100433e2:	430a      	orrs	r2, r1
100433e4:	609a      	str	r2, [r3, #8]
}
100433e6:	46c0      	nop			@ (mov r8, r8)
100433e8:	46bd      	mov	sp, r7
100433ea:	b002      	add	sp, #8
100433ec:	bd80      	pop	{r7, pc}
100433ee:	46c0      	nop			@ (mov r8, r8)
100433f0:	48400000 	.word	0x48400000
100433f4:	ffffefff 	.word	0xffffefff

100433f8 <LL_RCC_GetSMPSPrescaler>:
{
100433f8:	b580      	push	{r7, lr}
100433fa:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SMPSDIV));
100433fc:	4b03      	ldr	r3, [pc, #12]	@ (1004340c <LL_RCC_GetSMPSPrescaler+0x14>)
100433fe:	689a      	ldr	r2, [r3, #8]
10043400:	2380      	movs	r3, #128	@ 0x80
10043402:	015b      	lsls	r3, r3, #5
10043404:	4013      	ands	r3, r2
}
10043406:	0018      	movs	r0, r3
10043408:	46bd      	mov	sp, r7
1004340a:	bd80      	pop	{r7, pc}
1004340c:	48400000 	.word	0x48400000

10043410 <LL_RCC_KRM_IsEnabled>:
{
10043410:	b580      	push	{r7, lr}
10043412:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->KRMR, RCC_KRMR_KRM_EN) == (RCC_KRMR_KRM_EN)) ? 1UL : 0UL);
10043414:	4b05      	ldr	r3, [pc, #20]	@ (1004342c <LL_RCC_KRM_IsEnabled+0x1c>)
10043416:	691b      	ldr	r3, [r3, #16]
10043418:	2201      	movs	r2, #1
1004341a:	4013      	ands	r3, r2
1004341c:	2b01      	cmp	r3, #1
1004341e:	d101      	bne.n	10043424 <LL_RCC_KRM_IsEnabled+0x14>
10043420:	2301      	movs	r3, #1
10043422:	e000      	b.n	10043426 <LL_RCC_KRM_IsEnabled+0x16>
10043424:	2300      	movs	r3, #0
}
10043426:	0018      	movs	r0, r3
10043428:	46bd      	mov	sp, r7
1004342a:	bd80      	pop	{r7, pc}
1004342c:	48400000 	.word	0x48400000

10043430 <LL_RCC_KRM_SetRateMultiplier>:
{
10043430:	b580      	push	{r7, lr}
10043432:	b082      	sub	sp, #8
10043434:	af00      	add	r7, sp, #0
10043436:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->KRMR, RCC_KRMR_KRM, Value << RCC_KRMR_KRM_Pos);
10043438:	4b06      	ldr	r3, [pc, #24]	@ (10043454 <LL_RCC_KRM_SetRateMultiplier+0x24>)
1004343a:	691b      	ldr	r3, [r3, #16]
1004343c:	4a06      	ldr	r2, [pc, #24]	@ (10043458 <LL_RCC_KRM_SetRateMultiplier+0x28>)
1004343e:	4013      	ands	r3, r2
10043440:	0019      	movs	r1, r3
10043442:	687b      	ldr	r3, [r7, #4]
10043444:	005a      	lsls	r2, r3, #1
10043446:	4b03      	ldr	r3, [pc, #12]	@ (10043454 <LL_RCC_KRM_SetRateMultiplier+0x24>)
10043448:	430a      	orrs	r2, r1
1004344a:	611a      	str	r2, [r3, #16]
}
1004344c:	46c0      	nop			@ (mov r8, r8)
1004344e:	46bd      	mov	sp, r7
10043450:	b002      	add	sp, #8
10043452:	bd80      	pop	{r7, pc}
10043454:	48400000 	.word	0x48400000
10043458:	ffff0001 	.word	0xffff0001

1004345c <LL_RCC_KRM_GetRateMultiplier>:
{
1004345c:	b580      	push	{r7, lr}
1004345e:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->KRMR, RCC_KRMR_KRM) >> RCC_KRMR_KRM_Pos);
10043460:	4b03      	ldr	r3, [pc, #12]	@ (10043470 <LL_RCC_KRM_GetRateMultiplier+0x14>)
10043462:	691b      	ldr	r3, [r3, #16]
10043464:	085b      	lsrs	r3, r3, #1
10043466:	045b      	lsls	r3, r3, #17
10043468:	0c5b      	lsrs	r3, r3, #17
}
1004346a:	0018      	movs	r0, r3
1004346c:	46bd      	mov	sp, r7
1004346e:	bd80      	pop	{r7, pc}
10043470:	48400000 	.word	0x48400000

10043474 <LL_RCC_SetLPUARTClockSource>:
{
10043474:	b580      	push	{r7, lr}
10043476:	b082      	sub	sp, #8
10043478:	af00      	add	r7, sp, #0
1004347a:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_LPUCLKSEL, Source);
1004347c:	4b06      	ldr	r3, [pc, #24]	@ (10043498 <LL_RCC_SetLPUARTClockSource+0x24>)
1004347e:	689b      	ldr	r3, [r3, #8]
10043480:	4a06      	ldr	r2, [pc, #24]	@ (1004349c <LL_RCC_SetLPUARTClockSource+0x28>)
10043482:	4013      	ands	r3, r2
10043484:	0019      	movs	r1, r3
10043486:	4b04      	ldr	r3, [pc, #16]	@ (10043498 <LL_RCC_SetLPUARTClockSource+0x24>)
10043488:	687a      	ldr	r2, [r7, #4]
1004348a:	430a      	orrs	r2, r1
1004348c:	609a      	str	r2, [r3, #8]
}
1004348e:	46c0      	nop			@ (mov r8, r8)
10043490:	46bd      	mov	sp, r7
10043492:	b002      	add	sp, #8
10043494:	bd80      	pop	{r7, pc}
10043496:	46c0      	nop			@ (mov r8, r8)
10043498:	48400000 	.word	0x48400000
1004349c:	ffffdfff 	.word	0xffffdfff

100434a0 <LL_RCC_GetLPUARTClockSource>:
{
100434a0:	b580      	push	{r7, lr}
100434a2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_LPUCLKSEL));
100434a4:	4b03      	ldr	r3, [pc, #12]	@ (100434b4 <LL_RCC_GetLPUARTClockSource+0x14>)
100434a6:	689a      	ldr	r2, [r3, #8]
100434a8:	2380      	movs	r3, #128	@ 0x80
100434aa:	019b      	lsls	r3, r3, #6
100434ac:	4013      	ands	r3, r2
}
100434ae:	0018      	movs	r0, r3
100434b0:	46bd      	mov	sp, r7
100434b2:	bd80      	pop	{r7, pc}
100434b4:	48400000 	.word	0x48400000

100434b8 <LL_RCC_SetSPI3I2SClockSource>:
{
100434b8:	b580      	push	{r7, lr}
100434ba:	b082      	sub	sp, #8
100434bc:	af00      	add	r7, sp, #0
100434be:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_SPI3I2SCLKSEL, Source);
100434c0:	4b06      	ldr	r3, [pc, #24]	@ (100434dc <LL_RCC_SetSPI3I2SClockSource+0x24>)
100434c2:	689b      	ldr	r3, [r3, #8]
100434c4:	4a06      	ldr	r2, [pc, #24]	@ (100434e0 <LL_RCC_SetSPI3I2SClockSource+0x28>)
100434c6:	4013      	ands	r3, r2
100434c8:	0019      	movs	r1, r3
100434ca:	4b04      	ldr	r3, [pc, #16]	@ (100434dc <LL_RCC_SetSPI3I2SClockSource+0x24>)
100434cc:	687a      	ldr	r2, [r7, #4]
100434ce:	430a      	orrs	r2, r1
100434d0:	609a      	str	r2, [r3, #8]
}
100434d2:	46c0      	nop			@ (mov r8, r8)
100434d4:	46bd      	mov	sp, r7
100434d6:	b002      	add	sp, #8
100434d8:	bd80      	pop	{r7, pc}
100434da:	46c0      	nop			@ (mov r8, r8)
100434dc:	48400000 	.word	0x48400000
100434e0:	ff3fffff 	.word	0xff3fffff

100434e4 <LL_RCC_GetSPI3I2SClockSource>:
{
100434e4:	b580      	push	{r7, lr}
100434e6:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SPI3I2SCLKSEL));
100434e8:	4b03      	ldr	r3, [pc, #12]	@ (100434f8 <LL_RCC_GetSPI3I2SClockSource+0x14>)
100434ea:	689a      	ldr	r2, [r3, #8]
100434ec:	23c0      	movs	r3, #192	@ 0xc0
100434ee:	041b      	lsls	r3, r3, #16
100434f0:	4013      	ands	r3, r2
}
100434f2:	0018      	movs	r0, r3
100434f4:	46bd      	mov	sp, r7
100434f6:	bd80      	pop	{r7, pc}
100434f8:	48400000 	.word	0x48400000

100434fc <HAL_RCCEx_PeriphCLKConfig>:
  *            @arg @ref RCC_PERIPHCLK_LPUART1           LPUART1 peripheral clock
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
100434fc:	b580      	push	{r7, lr}
100434fe:	b082      	sub	sp, #8
10043500:	af00      	add	r7, sp, #0
10043502:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));


  /*-------------------------- SMPS clock configuration -------------------------------*/
  if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SMPS) == RCC_PERIPHCLK_SMPS))
10043504:	687b      	ldr	r3, [r7, #4]
10043506:	681b      	ldr	r3, [r3, #0]
10043508:	2202      	movs	r2, #2
1004350a:	4013      	ands	r3, r2
1004350c:	d009      	beq.n	10043522 <HAL_RCCEx_PeriphCLKConfig+0x26>
  {
    assert_param(IS_RCC_SMPS_CLOCK_PRESC(PeriphClkInit->SmpsDivSelection));
    __HAL_RCC_SMPS_DIV_CONFIG(PeriphClkInit->SmpsDivSelection);
1004350e:	687b      	ldr	r3, [r7, #4]
10043510:	691b      	ldr	r3, [r3, #16]
10043512:	0018      	movs	r0, r3
10043514:	f7ff ff5a 	bl	100433cc <LL_RCC_SetSMPSPrescaler>
    __HAL_RCC_KRM_RATE_MULTIPLIER_CONFIG(PeriphClkInit->KRMRateMultiplier);
10043518:	687b      	ldr	r3, [r7, #4]
1004351a:	695b      	ldr	r3, [r3, #20]
1004351c:	0018      	movs	r0, r3
1004351e:	f7ff ff87 	bl	10043430 <LL_RCC_KRM_SetRateMultiplier>
  }

  /*-------------------------- SPI3_I2S clock source configuration ---------------------*/
  if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI3_I2S) == RCC_PERIPHCLK_SPI3_I2S))
10043522:	687b      	ldr	r3, [r7, #4]
10043524:	681b      	ldr	r3, [r3, #0]
10043526:	2208      	movs	r2, #8
10043528:	4013      	ands	r3, r2
1004352a:	d004      	beq.n	10043536 <HAL_RCCEx_PeriphCLKConfig+0x3a>
  {
    assert_param(IS_RCC_SPI3I2S_CLOCK_SOURCE(PeriphClkInit->SPI3I2SClockSelection));
    __HAL_RCC_SPI3I2S_CLK_CONFIG(PeriphClkInit->SPI3I2SClockSelection);
1004352c:	687b      	ldr	r3, [r7, #4]
1004352e:	685b      	ldr	r3, [r3, #4]
10043530:	0018      	movs	r0, r3
10043532:	f7ff ffc1 	bl	100434b8 <LL_RCC_SetSPI3I2SClockSource>
  }
#if defined(RCC_CFGR_LPUCLKSEL)
  /*-------------------------- LPUART1 clock source configuration ---------------------*/
  if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1))
10043536:	687b      	ldr	r3, [r7, #4]
10043538:	681b      	ldr	r3, [r3, #0]
1004353a:	2210      	movs	r2, #16
1004353c:	4013      	ands	r3, r2
1004353e:	d004      	beq.n	1004354a <HAL_RCCEx_PeriphCLKConfig+0x4e>
  {
    assert_param(IS_RCC_LPUART1_CLOCK_SOURCE(PeriphClkInit->LPUART1ClockSelection));
    __HAL_RCC_LPUART1_CLK_CONFIG(PeriphClkInit->LPUART1ClockSelection);
10043540:	687b      	ldr	r3, [r7, #4]
10043542:	68db      	ldr	r3, [r3, #12]
10043544:	0018      	movs	r0, r3
10043546:	f7ff ff95 	bl	10043474 <LL_RCC_SetLPUARTClockSource>
  }
#endif /* RCC_CFGR_LPUCLKSEL */

  if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC_WDG_SUBG_LPAWUR_LCD_LCSC) ==
1004354a:	687b      	ldr	r3, [r7, #4]
1004354c:	681b      	ldr	r3, [r3, #0]
1004354e:	2220      	movs	r2, #32
10043550:	4013      	ands	r3, r2
10043552:	d004      	beq.n	1004355e <HAL_RCCEx_PeriphCLKConfig+0x62>
       RCC_PERIPHCLK_RTC_WDG_SUBG_LPAWUR_LCD_LCSC))
  {
    assert_param(IS_RCC_RTC_WDG_SUBG_PAWUR_LCD_LCSC_CLOCK_SOURCE(PeriphClkInit->RTCWDGSUBGLPAWURLCDLCSCClockSelection));
    __HAL_RCC_RTC_SUBG_LPAWUR_LCD_LCSC_CLK_CONFIG(PeriphClkInit->RTCWDGSUBGLPAWURLCDLCSCClockSelection);
10043554:	687b      	ldr	r3, [r7, #4]
10043556:	689b      	ldr	r3, [r3, #8]
10043558:	0018      	movs	r0, r3
1004355a:	f7ff ff21 	bl	100433a0 <LL_RCC_LSCO_SetSource>
  }

  return HAL_OK;
1004355e:	2300      	movs	r3, #0
}
10043560:	0018      	movs	r0, r3
10043562:	46bd      	mov	sp, r7
10043564:	b002      	add	sp, #8
10043566:	bd80      	pop	{r7, pc}

10043568 <HAL_RCCEx_GetPeriphCLKFreq>:
  *            @arg @ref RCC_PERIPHCLK_LPUART1           LPUART1 peripheral clock
  * @retval Frequency in Hz
  * @note   (*) Peripherals are not available on all devices
  */
uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)
{
10043568:	b580      	push	{r7, lr}
1004356a:	b086      	sub	sp, #24
1004356c:	af00      	add	r7, sp, #0
1004356e:	6078      	str	r0, [r7, #4]

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClk));

  /* No if clausule is covered */
  frequency = 0;
10043570:	2300      	movs	r3, #0
10043572:	617b      	str	r3, [r7, #20]

  switch (PeriphClk)
10043574:	687b      	ldr	r3, [r7, #4]
10043576:	2b10      	cmp	r3, #16
10043578:	d100      	bne.n	1004357c <HAL_RCCEx_GetPeriphCLKFreq+0x14>
1004357a:	e06b      	b.n	10043654 <HAL_RCCEx_GetPeriphCLKFreq+0xec>
1004357c:	687b      	ldr	r3, [r7, #4]
1004357e:	2b10      	cmp	r3, #16
10043580:	d900      	bls.n	10043584 <HAL_RCCEx_GetPeriphCLKFreq+0x1c>
10043582:	e076      	b.n	10043672 <HAL_RCCEx_GetPeriphCLKFreq+0x10a>
10043584:	687b      	ldr	r3, [r7, #4]
10043586:	2b08      	cmp	r3, #8
10043588:	d03a      	beq.n	10043600 <HAL_RCCEx_GetPeriphCLKFreq+0x98>
1004358a:	687b      	ldr	r3, [r7, #4]
1004358c:	2b08      	cmp	r3, #8
1004358e:	d900      	bls.n	10043592 <HAL_RCCEx_GetPeriphCLKFreq+0x2a>
10043590:	e06f      	b.n	10043672 <HAL_RCCEx_GetPeriphCLKFreq+0x10a>
10043592:	687b      	ldr	r3, [r7, #4]
10043594:	2b01      	cmp	r3, #1
10043596:	d003      	beq.n	100435a0 <HAL_RCCEx_GetPeriphCLKFreq+0x38>
10043598:	687b      	ldr	r3, [r7, #4]
1004359a:	2b02      	cmp	r3, #2
1004359c:	d003      	beq.n	100435a6 <HAL_RCCEx_GetPeriphCLKFreq+0x3e>
          break;
      }
      break;
#endif /* RCC_CFGR_LPUCLKSEL */
    default :
      break;
1004359e:	e068      	b.n	10043672 <HAL_RCCEx_GetPeriphCLKFreq+0x10a>
      frequency = HSE_VALUE / 3;
100435a0:	4b38      	ldr	r3, [pc, #224]	@ (10043684 <HAL_RCCEx_GetPeriphCLKFreq+0x11c>)
100435a2:	617b      	str	r3, [r7, #20]
      break;
100435a4:	e068      	b.n	10043678 <HAL_RCCEx_GetPeriphCLKFreq+0x110>
      if (__HAL_RCC_IS_KRM_ENABLED())
100435a6:	f7ff ff33 	bl	10043410 <LL_RCC_KRM_IsEnabled>
100435aa:	1e03      	subs	r3, r0, #0
100435ac:	d018      	beq.n	100435e0 <HAL_RCCEx_GetPeriphCLKFreq+0x78>
        if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_DIRECT_HSE)
100435ae:	f7ff fee7 	bl	10043380 <LL_RCC_DIRECT_HSE_IsEnabled>
100435b2:	1e03      	subs	r3, r0, #0
100435b4:	d002      	beq.n	100435bc <HAL_RCCEx_GetPeriphCLKFreq+0x54>
          frequency = HSE_VALUE;
100435b6:	4b34      	ldr	r3, [pc, #208]	@ (10043688 <HAL_RCCEx_GetPeriphCLKFreq+0x120>)
100435b8:	617b      	str	r3, [r7, #20]
100435ba:	e001      	b.n	100435c0 <HAL_RCCEx_GetPeriphCLKFreq+0x58>
          frequency = RC64MPLL_VALUE;
100435bc:	4b33      	ldr	r3, [pc, #204]	@ (1004368c <HAL_RCCEx_GetPeriphCLKFreq+0x124>)
100435be:	617b      	str	r3, [r7, #20]
        krmValue = __HAL_RCC_GET_KRM_RATE_MULTIPLIER();
100435c0:	f7ff ff4c 	bl	1004345c <LL_RCC_KRM_GetRateMultiplier>
100435c4:	0003      	movs	r3, r0
100435c6:	613b      	str	r3, [r7, #16]
        if (krmValue < 8)
100435c8:	693b      	ldr	r3, [r7, #16]
100435ca:	2b07      	cmp	r3, #7
100435cc:	d801      	bhi.n	100435d2 <HAL_RCCEx_GetPeriphCLKFreq+0x6a>
          krmValue = 8;
100435ce:	2308      	movs	r3, #8
100435d0:	613b      	str	r3, [r7, #16]
        frequency = frequency / krmValue;
100435d2:	6939      	ldr	r1, [r7, #16]
100435d4:	6978      	ldr	r0, [r7, #20]
100435d6:	f7fc fd73 	bl	100400c0 <__udivsi3>
100435da:	0003      	movs	r3, r0
100435dc:	617b      	str	r3, [r7, #20]
      break;
100435de:	e04b      	b.n	10043678 <HAL_RCCEx_GetPeriphCLKFreq+0x110>
        switch (__HAL_RCC_GET_SMPS_DIV())
100435e0:	f7ff ff0a 	bl	100433f8 <LL_RCC_GetSMPSPrescaler>
100435e4:	1e03      	subs	r3, r0, #0
100435e6:	d004      	beq.n	100435f2 <HAL_RCCEx_GetPeriphCLKFreq+0x8a>
100435e8:	2280      	movs	r2, #128	@ 0x80
100435ea:	0152      	lsls	r2, r2, #5
100435ec:	4293      	cmp	r3, r2
100435ee:	d003      	beq.n	100435f8 <HAL_RCCEx_GetPeriphCLKFreq+0x90>
      break;
100435f0:	e042      	b.n	10043678 <HAL_RCCEx_GetPeriphCLKFreq+0x110>
            frequency = RC64MPLL_VALUE / 8;
100435f2:	4b27      	ldr	r3, [pc, #156]	@ (10043690 <HAL_RCCEx_GetPeriphCLKFreq+0x128>)
100435f4:	617b      	str	r3, [r7, #20]
            break;
100435f6:	e002      	b.n	100435fe <HAL_RCCEx_GetPeriphCLKFreq+0x96>
            frequency = RC64MPLL_VALUE / 16;
100435f8:	4b26      	ldr	r3, [pc, #152]	@ (10043694 <HAL_RCCEx_GetPeriphCLKFreq+0x12c>)
100435fa:	617b      	str	r3, [r7, #20]
            break;
100435fc:	46c0      	nop			@ (mov r8, r8)
      break;
100435fe:	e03b      	b.n	10043678 <HAL_RCCEx_GetPeriphCLKFreq+0x110>
      spiFreqValue = __HAL_RCC_GET_SPI3I2S_CLK_CONFIG();
10043600:	f7ff ff70 	bl	100434e4 <LL_RCC_GetSPI3I2SClockSource>
10043604:	0003      	movs	r3, r0
10043606:	60fb      	str	r3, [r7, #12]
      switch (spiFreqValue)
10043608:	68fa      	ldr	r2, [r7, #12]
1004360a:	2380      	movs	r3, #128	@ 0x80
1004360c:	041b      	lsls	r3, r3, #16
1004360e:	429a      	cmp	r2, r3
10043610:	d01a      	beq.n	10043648 <HAL_RCCEx_GetPeriphCLKFreq+0xe0>
10043612:	68fa      	ldr	r2, [r7, #12]
10043614:	2380      	movs	r3, #128	@ 0x80
10043616:	041b      	lsls	r3, r3, #16
10043618:	429a      	cmp	r2, r3
1004361a:	d82c      	bhi.n	10043676 <HAL_RCCEx_GetPeriphCLKFreq+0x10e>
1004361c:	68fb      	ldr	r3, [r7, #12]
1004361e:	2b00      	cmp	r3, #0
10043620:	d005      	beq.n	1004362e <HAL_RCCEx_GetPeriphCLKFreq+0xc6>
10043622:	68fa      	ldr	r2, [r7, #12]
10043624:	2380      	movs	r3, #128	@ 0x80
10043626:	03db      	lsls	r3, r3, #15
10043628:	429a      	cmp	r2, r3
1004362a:	d003      	beq.n	10043634 <HAL_RCCEx_GetPeriphCLKFreq+0xcc>
      break;
1004362c:	e023      	b.n	10043676 <HAL_RCCEx_GetPeriphCLKFreq+0x10e>
          frequency = RC64MPLL_VALUE / 4;
1004362e:	4b15      	ldr	r3, [pc, #84]	@ (10043684 <HAL_RCCEx_GetPeriphCLKFreq+0x11c>)
10043630:	617b      	str	r3, [r7, #20]
          break;
10043632:	e00e      	b.n	10043652 <HAL_RCCEx_GetPeriphCLKFreq+0xea>
          if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_DIRECT_HSE)
10043634:	f7ff fea4 	bl	10043380 <LL_RCC_DIRECT_HSE_IsEnabled>
10043638:	1e03      	subs	r3, r0, #0
1004363a:	d002      	beq.n	10043642 <HAL_RCCEx_GetPeriphCLKFreq+0xda>
            frequency = HSE_VALUE / 2;
1004363c:	4b16      	ldr	r3, [pc, #88]	@ (10043698 <HAL_RCCEx_GetPeriphCLKFreq+0x130>)
1004363e:	617b      	str	r3, [r7, #20]
          break;
10043640:	e007      	b.n	10043652 <HAL_RCCEx_GetPeriphCLKFreq+0xea>
            frequency = RC64MPLL_VALUE / 2;
10043642:	4b16      	ldr	r3, [pc, #88]	@ (1004369c <HAL_RCCEx_GetPeriphCLKFreq+0x134>)
10043644:	617b      	str	r3, [r7, #20]
          break;
10043646:	e004      	b.n	10043652 <HAL_RCCEx_GetPeriphCLKFreq+0xea>
          frequency = HAL_RCC_GetSysClockFreq() ;
10043648:	f7ff fe90 	bl	1004336c <HAL_RCC_GetSysClockFreq>
1004364c:	0003      	movs	r3, r0
1004364e:	617b      	str	r3, [r7, #20]
          break;
10043650:	46c0      	nop			@ (mov r8, r8)
      break;
10043652:	e010      	b.n	10043676 <HAL_RCCEx_GetPeriphCLKFreq+0x10e>
      switch (__HAL_RCC_GET_LPUART1_CLK_CONFIG())
10043654:	f7ff ff24 	bl	100434a0 <LL_RCC_GetLPUARTClockSource>
10043658:	0002      	movs	r2, r0
1004365a:	2380      	movs	r3, #128	@ 0x80
1004365c:	019b      	lsls	r3, r3, #6
1004365e:	429a      	cmp	r2, r3
10043660:	d103      	bne.n	1004366a <HAL_RCCEx_GetPeriphCLKFreq+0x102>
          frequency = LSE_VALUE;
10043662:	2380      	movs	r3, #128	@ 0x80
10043664:	021b      	lsls	r3, r3, #8
10043666:	617b      	str	r3, [r7, #20]
          break;
10043668:	e002      	b.n	10043670 <HAL_RCCEx_GetPeriphCLKFreq+0x108>
          frequency = HSE_VALUE / 2;
1004366a:	4b0b      	ldr	r3, [pc, #44]	@ (10043698 <HAL_RCCEx_GetPeriphCLKFreq+0x130>)
1004366c:	617b      	str	r3, [r7, #20]
          break;
1004366e:	46c0      	nop			@ (mov r8, r8)
      break;
10043670:	e002      	b.n	10043678 <HAL_RCCEx_GetPeriphCLKFreq+0x110>
      break;
10043672:	46c0      	nop			@ (mov r8, r8)
10043674:	e000      	b.n	10043678 <HAL_RCCEx_GetPeriphCLKFreq+0x110>
      break;
10043676:	46c0      	nop			@ (mov r8, r8)
  }
  return (frequency);
10043678:	697b      	ldr	r3, [r7, #20]
}
1004367a:	0018      	movs	r0, r3
1004367c:	46bd      	mov	sp, r7
1004367e:	b006      	add	sp, #24
10043680:	bd80      	pop	{r7, pc}
10043682:	46c0      	nop			@ (mov r8, r8)
10043684:	00f42400 	.word	0x00f42400
10043688:	02dc6c00 	.word	0x02dc6c00
1004368c:	03d09000 	.word	0x03d09000
10043690:	007a1200 	.word	0x007a1200
10043694:	003d0900 	.word	0x003d0900
10043698:	016e3600 	.word	0x016e3600
1004369c:	01e84800 	.word	0x01e84800

100436a0 <HAL_UART_Init>:
  *        parameters in the UART_InitTypeDef and initialize the associated handle.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
100436a0:	b580      	push	{r7, lr}
100436a2:	b082      	sub	sp, #8
100436a4:	af00      	add	r7, sp, #0
100436a6:	6078      	str	r0, [r7, #4]
  /* Check the UART handle allocation */
  if (huart == NULL)
100436a8:	687b      	ldr	r3, [r7, #4]
100436aa:	2b00      	cmp	r3, #0
100436ac:	d101      	bne.n	100436b2 <HAL_UART_Init+0x12>
  {
    return HAL_ERROR;
100436ae:	2301      	movs	r3, #1
100436b0:	e046      	b.n	10043740 <HAL_UART_Init+0xa0>
  {
    /* Check the parameters */
    assert_param((IS_UART_INSTANCE(huart->Instance)) || (IS_LPUART_INSTANCE(huart->Instance)));
  }

  if (huart->gState == HAL_UART_STATE_RESET)
100436b2:	687b      	ldr	r3, [r7, #4]
100436b4:	2288      	movs	r2, #136	@ 0x88
100436b6:	589b      	ldr	r3, [r3, r2]
100436b8:	2b00      	cmp	r3, #0
100436ba:	d107      	bne.n	100436cc <HAL_UART_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
100436bc:	687b      	ldr	r3, [r7, #4]
100436be:	2284      	movs	r2, #132	@ 0x84
100436c0:	2100      	movs	r1, #0
100436c2:	5499      	strb	r1, [r3, r2]

    /* Init the low level hardware */
    huart->MspInitCallback(huart);
#else
    /* Init the low level hardware : GPIO, CLOCK */
    HAL_UART_MspInit(huart);
100436c4:	687b      	ldr	r3, [r7, #4]
100436c6:	0018      	movs	r0, r3
100436c8:	f000 f840 	bl	1004374c <HAL_UART_MspInit>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
  }

  huart->gState = HAL_UART_STATE_BUSY;
100436cc:	687b      	ldr	r3, [r7, #4]
100436ce:	2288      	movs	r2, #136	@ 0x88
100436d0:	2124      	movs	r1, #36	@ 0x24
100436d2:	5099      	str	r1, [r3, r2]

  __HAL_UART_DISABLE(huart);
100436d4:	687b      	ldr	r3, [r7, #4]
100436d6:	681b      	ldr	r3, [r3, #0]
100436d8:	681a      	ldr	r2, [r3, #0]
100436da:	687b      	ldr	r3, [r7, #4]
100436dc:	681b      	ldr	r3, [r3, #0]
100436de:	2101      	movs	r1, #1
100436e0:	438a      	bics	r2, r1
100436e2:	601a      	str	r2, [r3, #0]

  /* Perform advanced settings configuration */
  /* For some items, configuration requires to be done prior TE and RE bits are set */
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
100436e4:	687b      	ldr	r3, [r7, #4]
100436e6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
100436e8:	2b00      	cmp	r3, #0
100436ea:	d003      	beq.n	100436f4 <HAL_UART_Init+0x54>
  {
    UART_AdvFeatureConfig(huart);
100436ec:	687b      	ldr	r3, [r7, #4]
100436ee:	0018      	movs	r0, r3
100436f0:	f000 f99c 	bl	10043a2c <UART_AdvFeatureConfig>
  }

  /* Set the UART Communication parameters */
  if (UART_SetConfig(huart) == HAL_ERROR)
100436f4:	687b      	ldr	r3, [r7, #4]
100436f6:	0018      	movs	r0, r3
100436f8:	f000 f830 	bl	1004375c <UART_SetConfig>
100436fc:	0003      	movs	r3, r0
100436fe:	2b01      	cmp	r3, #1
10043700:	d101      	bne.n	10043706 <HAL_UART_Init+0x66>
  {
    return HAL_ERROR;
10043702:	2301      	movs	r3, #1
10043704:	e01c      	b.n	10043740 <HAL_UART_Init+0xa0>
  }

  /* In asynchronous mode, the following bits must be kept cleared:
  - LINEN and CLKEN bits in the USART_CR2 register,
  - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
10043706:	687b      	ldr	r3, [r7, #4]
10043708:	681b      	ldr	r3, [r3, #0]
1004370a:	685a      	ldr	r2, [r3, #4]
1004370c:	687b      	ldr	r3, [r7, #4]
1004370e:	681b      	ldr	r3, [r3, #0]
10043710:	490d      	ldr	r1, [pc, #52]	@ (10043748 <HAL_UART_Init+0xa8>)
10043712:	400a      	ands	r2, r1
10043714:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
10043716:	687b      	ldr	r3, [r7, #4]
10043718:	681b      	ldr	r3, [r3, #0]
1004371a:	689a      	ldr	r2, [r3, #8]
1004371c:	687b      	ldr	r3, [r7, #4]
1004371e:	681b      	ldr	r3, [r3, #0]
10043720:	212a      	movs	r1, #42	@ 0x2a
10043722:	438a      	bics	r2, r1
10043724:	609a      	str	r2, [r3, #8]

  __HAL_UART_ENABLE(huart);
10043726:	687b      	ldr	r3, [r7, #4]
10043728:	681b      	ldr	r3, [r3, #0]
1004372a:	681a      	ldr	r2, [r3, #0]
1004372c:	687b      	ldr	r3, [r7, #4]
1004372e:	681b      	ldr	r3, [r3, #0]
10043730:	2101      	movs	r1, #1
10043732:	430a      	orrs	r2, r1
10043734:	601a      	str	r2, [r3, #0]

  /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
  return (UART_CheckIdleState(huart));
10043736:	687b      	ldr	r3, [r7, #4]
10043738:	0018      	movs	r0, r3
1004373a:	f000 fa2b 	bl	10043b94 <UART_CheckIdleState>
1004373e:	0003      	movs	r3, r0
}
10043740:	0018      	movs	r0, r3
10043742:	46bd      	mov	sp, r7
10043744:	b002      	add	sp, #8
10043746:	bd80      	pop	{r7, pc}
10043748:	ffffb7ff 	.word	0xffffb7ff

1004374c <HAL_UART_MspInit>:
  * @brief Initialize the UART MSP.
  * @param huart UART handle.
  * @retval None
  */
__weak void HAL_UART_MspInit(UART_HandleTypeDef *huart)
{
1004374c:	b580      	push	{r7, lr}
1004374e:	b082      	sub	sp, #8
10043750:	af00      	add	r7, sp, #0
10043752:	6078      	str	r0, [r7, #4]
  UNUSED(huart);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UART_MspInit can be implemented in the user file
   */
}
10043754:	46c0      	nop			@ (mov r8, r8)
10043756:	46bd      	mov	sp, r7
10043758:	b002      	add	sp, #8
1004375a:	bd80      	pop	{r7, pc}

1004375c <UART_SetConfig>:
  * @brief Configure the UART peripheral.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
1004375c:	b5b0      	push	{r4, r5, r7, lr}
1004375e:	b090      	sub	sp, #64	@ 0x40
10043760:	af00      	add	r7, sp, #0
10043762:	6278      	str	r0, [r7, #36]	@ 0x24
  uint32_t tmpreg;
  uint16_t brrtemp;
  uint32_t usartdiv;
  HAL_StatusTypeDef ret               = HAL_OK;
10043764:	231b      	movs	r3, #27
10043766:	2220      	movs	r2, #32
10043768:	189b      	adds	r3, r3, r2
1004376a:	19db      	adds	r3, r3, r7
1004376c:	2200      	movs	r2, #0
1004376e:	701a      	strb	r2, [r3, #0]
  *  the UART Word Length, Parity, Mode and oversampling:
  *  set the M bits according to huart->Init.WordLength value
  *  set PCE and PS bits according to huart->Init.Parity value
  *  set TE and RE bits according to huart->Init.Mode value
  *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
10043770:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10043772:	689a      	ldr	r2, [r3, #8]
10043774:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10043776:	691b      	ldr	r3, [r3, #16]
10043778:	431a      	orrs	r2, r3
1004377a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
1004377c:	695b      	ldr	r3, [r3, #20]
1004377e:	431a      	orrs	r2, r3
10043780:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10043782:	69db      	ldr	r3, [r3, #28]
10043784:	4313      	orrs	r3, r2
10043786:	63fb      	str	r3, [r7, #60]	@ 0x3c
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
10043788:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
1004378a:	681b      	ldr	r3, [r3, #0]
1004378c:	681b      	ldr	r3, [r3, #0]
1004378e:	4aa1      	ldr	r2, [pc, #644]	@ (10043a14 <UART_SetConfig+0x2b8>)
10043790:	4013      	ands	r3, r2
10043792:	0019      	movs	r1, r3
10043794:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10043796:	681a      	ldr	r2, [r3, #0]
10043798:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
1004379a:	430b      	orrs	r3, r1
1004379c:	6013      	str	r3, [r2, #0]

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according
  * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
1004379e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
100437a0:	681b      	ldr	r3, [r3, #0]
100437a2:	685b      	ldr	r3, [r3, #4]
100437a4:	4a9c      	ldr	r2, [pc, #624]	@ (10043a18 <UART_SetConfig+0x2bc>)
100437a6:	4013      	ands	r3, r2
100437a8:	0018      	movs	r0, r3
100437aa:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
100437ac:	68d9      	ldr	r1, [r3, #12]
100437ae:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
100437b0:	681a      	ldr	r2, [r3, #0]
100437b2:	0003      	movs	r3, r0
100437b4:	430b      	orrs	r3, r1
100437b6:	6053      	str	r3, [r2, #4]
  /* Configure
  * - UART HardWare Flow Control: set CTSE and RTSE bits according
  *   to huart->Init.HwFlowCtl value
  * - one-bit sampling method versus three samples' majority rule according
  *   to huart->Init.OneBitSampling (not applicable to LPUART) */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
100437b8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
100437ba:	699b      	ldr	r3, [r3, #24]
100437bc:	63fb      	str	r3, [r7, #60]	@ 0x3c

  if (!(UART_INSTANCE_LOWPOWER(huart)))
100437be:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
100437c0:	681b      	ldr	r3, [r3, #0]
100437c2:	4a96      	ldr	r2, [pc, #600]	@ (10043a1c <UART_SetConfig+0x2c0>)
100437c4:	4293      	cmp	r3, r2
100437c6:	d004      	beq.n	100437d2 <UART_SetConfig+0x76>
  {
    tmpreg |= huart->Init.OneBitSampling;
100437c8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
100437ca:	6a1b      	ldr	r3, [r3, #32]
100437cc:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
100437ce:	4313      	orrs	r3, r2
100437d0:	63fb      	str	r3, [r7, #60]	@ 0x3c
  }
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
100437d2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
100437d4:	681b      	ldr	r3, [r3, #0]
100437d6:	689b      	ldr	r3, [r3, #8]
100437d8:	4a91      	ldr	r2, [pc, #580]	@ (10043a20 <UART_SetConfig+0x2c4>)
100437da:	4013      	ands	r3, r2
100437dc:	0019      	movs	r1, r3
100437de:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
100437e0:	681a      	ldr	r2, [r3, #0]
100437e2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
100437e4:	430b      	orrs	r3, r1
100437e6:	6093      	str	r3, [r2, #8]

  /*-------------------------- USART PRESC Configuration -----------------------*/
  /* Configure
  * - UART Clock Prescaler : set PRESCALER according to huart->Init.ClockPrescaler value */
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
100437e8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
100437ea:	681b      	ldr	r3, [r3, #0]
100437ec:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
100437ee:	220f      	movs	r2, #15
100437f0:	4393      	bics	r3, r2
100437f2:	0018      	movs	r0, r3
100437f4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
100437f6:	6a59      	ldr	r1, [r3, #36]	@ 0x24
100437f8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
100437fa:	681a      	ldr	r2, [r3, #0]
100437fc:	0003      	movs	r3, r0
100437fe:	430b      	orrs	r3, r1
10043800:	62d3      	str	r3, [r2, #44]	@ 0x2c

  /*-------------------------- USART BRR Configuration -----------------------*/
  /* Check LPUART instance */
  if (UART_INSTANCE_LOWPOWER(huart))
10043802:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10043804:	681b      	ldr	r3, [r3, #0]
10043806:	4a85      	ldr	r2, [pc, #532]	@ (10043a1c <UART_SetConfig+0x2c0>)
10043808:	4293      	cmp	r3, r2
1004380a:	d16d      	bne.n	100438e8 <UART_SetConfig+0x18c>
  {
    /* Retrieve frequency clock */
    pclk = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_LPUART1);
1004380c:	2010      	movs	r0, #16
1004380e:	f7ff feab 	bl	10043568 <HAL_RCCEx_GetPeriphCLKFreq>
10043812:	0003      	movs	r3, r0
10043814:	637b      	str	r3, [r7, #52]	@ 0x34

    /* If proper clock source reported */
    if (pclk != 0U)
10043816:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
10043818:	2b00      	cmp	r3, #0
1004381a:	d100      	bne.n	1004381e <UART_SetConfig+0xc2>
1004381c:	e0e3      	b.n	100439e6 <UART_SetConfig+0x28a>
    {
      /* Compute clock after Prescaler */
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
1004381e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10043820:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
10043822:	4b80      	ldr	r3, [pc, #512]	@ (10043a24 <UART_SetConfig+0x2c8>)
10043824:	0052      	lsls	r2, r2, #1
10043826:	5ad3      	ldrh	r3, [r2, r3]
10043828:	0019      	movs	r1, r3
1004382a:	6b78      	ldr	r0, [r7, #52]	@ 0x34
1004382c:	f7fc fc48 	bl	100400c0 <__udivsi3>
10043830:	0003      	movs	r3, r0
10043832:	62bb      	str	r3, [r7, #40]	@ 0x28

      /* Ensure that Frequency clock is in the range [3 * baudrate, 4096 * baudrate] */
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
10043834:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10043836:	685a      	ldr	r2, [r3, #4]
10043838:	0013      	movs	r3, r2
1004383a:	005b      	lsls	r3, r3, #1
1004383c:	189b      	adds	r3, r3, r2
1004383e:	6aba      	ldr	r2, [r7, #40]	@ 0x28
10043840:	429a      	cmp	r2, r3
10043842:	d305      	bcc.n	10043850 <UART_SetConfig+0xf4>
          (lpuart_ker_ck_pres > (4096U * huart->Init.BaudRate)))
10043844:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10043846:	685b      	ldr	r3, [r3, #4]
10043848:	031b      	lsls	r3, r3, #12
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
1004384a:	6aba      	ldr	r2, [r7, #40]	@ 0x28
1004384c:	429a      	cmp	r2, r3
1004384e:	d906      	bls.n	1004385e <UART_SetConfig+0x102>
      {
        ret = HAL_ERROR;
10043850:	231b      	movs	r3, #27
10043852:	2220      	movs	r2, #32
10043854:	189b      	adds	r3, r3, r2
10043856:	19db      	adds	r3, r3, r7
10043858:	2201      	movs	r2, #1
1004385a:	701a      	strb	r2, [r3, #0]
1004385c:	e0c3      	b.n	100439e6 <UART_SetConfig+0x28a>
      }
      else
      {
        /* Check computed UsartDiv value is in allocated range
           (it is forbidden to write values lower than 0x300 in the LPUART_BRR register) */
        usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
1004385e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
10043860:	61bb      	str	r3, [r7, #24]
10043862:	2300      	movs	r3, #0
10043864:	61fb      	str	r3, [r7, #28]
10043866:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10043868:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
1004386a:	4b6e      	ldr	r3, [pc, #440]	@ (10043a24 <UART_SetConfig+0x2c8>)
1004386c:	0052      	lsls	r2, r2, #1
1004386e:	5ad3      	ldrh	r3, [r2, r3]
10043870:	613b      	str	r3, [r7, #16]
10043872:	2300      	movs	r3, #0
10043874:	617b      	str	r3, [r7, #20]
10043876:	693a      	ldr	r2, [r7, #16]
10043878:	697b      	ldr	r3, [r7, #20]
1004387a:	69b8      	ldr	r0, [r7, #24]
1004387c:	69f9      	ldr	r1, [r7, #28]
1004387e:	f7fc fd95 	bl	100403ac <__aeabi_uldivmod>
10043882:	0002      	movs	r2, r0
10043884:	000b      	movs	r3, r1
10043886:	0e11      	lsrs	r1, r2, #24
10043888:	021d      	lsls	r5, r3, #8
1004388a:	430d      	orrs	r5, r1
1004388c:	0214      	lsls	r4, r2, #8
1004388e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10043890:	685b      	ldr	r3, [r3, #4]
10043892:	085b      	lsrs	r3, r3, #1
10043894:	60bb      	str	r3, [r7, #8]
10043896:	2300      	movs	r3, #0
10043898:	60fb      	str	r3, [r7, #12]
1004389a:	68b8      	ldr	r0, [r7, #8]
1004389c:	68f9      	ldr	r1, [r7, #12]
1004389e:	1900      	adds	r0, r0, r4
100438a0:	4169      	adcs	r1, r5
100438a2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
100438a4:	685b      	ldr	r3, [r3, #4]
100438a6:	603b      	str	r3, [r7, #0]
100438a8:	2300      	movs	r3, #0
100438aa:	607b      	str	r3, [r7, #4]
100438ac:	683a      	ldr	r2, [r7, #0]
100438ae:	687b      	ldr	r3, [r7, #4]
100438b0:	f7fc fd7c 	bl	100403ac <__aeabi_uldivmod>
100438b4:	0002      	movs	r2, r0
100438b6:	000b      	movs	r3, r1
100438b8:	0013      	movs	r3, r2
100438ba:	633b      	str	r3, [r7, #48]	@ 0x30
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
100438bc:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
100438be:	23c0      	movs	r3, #192	@ 0xc0
100438c0:	009b      	lsls	r3, r3, #2
100438c2:	429a      	cmp	r2, r3
100438c4:	d309      	bcc.n	100438da <UART_SetConfig+0x17e>
100438c6:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
100438c8:	2380      	movs	r3, #128	@ 0x80
100438ca:	035b      	lsls	r3, r3, #13
100438cc:	429a      	cmp	r2, r3
100438ce:	d204      	bcs.n	100438da <UART_SetConfig+0x17e>
        {
          huart->Instance->BRR = usartdiv;
100438d0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
100438d2:	681b      	ldr	r3, [r3, #0]
100438d4:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
100438d6:	60da      	str	r2, [r3, #12]
100438d8:	e085      	b.n	100439e6 <UART_SetConfig+0x28a>
        }
        else
        {
          ret = HAL_ERROR;
100438da:	231b      	movs	r3, #27
100438dc:	2220      	movs	r2, #32
100438de:	189b      	adds	r3, r3, r2
100438e0:	19db      	adds	r3, r3, r7
100438e2:	2201      	movs	r2, #1
100438e4:	701a      	strb	r2, [r3, #0]
100438e6:	e07e      	b.n	100439e6 <UART_SetConfig+0x28a>
      } /* if ( (lpuart_ker_ck_pres < (3 * huart->Init.BaudRate) ) ||
                (lpuart_ker_ck_pres > (4096 * huart->Init.BaudRate) )) */
    } /* if (pclk != 0) */
  }
  /* Check UART Over Sampling to set Baud Rate Register */
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
100438e8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
100438ea:	69da      	ldr	r2, [r3, #28]
100438ec:	2380      	movs	r3, #128	@ 0x80
100438ee:	021b      	lsls	r3, r3, #8
100438f0:	429a      	cmp	r2, r3
100438f2:	d148      	bne.n	10043986 <UART_SetConfig+0x22a>
  {
    pclk = UART_PERIPHCLK;
100438f4:	4b4c      	ldr	r3, [pc, #304]	@ (10043a28 <UART_SetConfig+0x2cc>)
100438f6:	637b      	str	r3, [r7, #52]	@ 0x34

    /* USARTDIV must be greater than or equal to 0d16 */
    if (pclk != 0U)
100438f8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
100438fa:	2b00      	cmp	r3, #0
100438fc:	d100      	bne.n	10043900 <UART_SetConfig+0x1a4>
100438fe:	e072      	b.n	100439e6 <UART_SetConfig+0x28a>
    {
      usartdiv = (uint32_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
10043900:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10043902:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
10043904:	4b47      	ldr	r3, [pc, #284]	@ (10043a24 <UART_SetConfig+0x2c8>)
10043906:	0052      	lsls	r2, r2, #1
10043908:	5ad3      	ldrh	r3, [r2, r3]
1004390a:	0019      	movs	r1, r3
1004390c:	6b78      	ldr	r0, [r7, #52]	@ 0x34
1004390e:	f7fc fbd7 	bl	100400c0 <__udivsi3>
10043912:	0003      	movs	r3, r0
10043914:	005a      	lsls	r2, r3, #1
10043916:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10043918:	685b      	ldr	r3, [r3, #4]
1004391a:	085b      	lsrs	r3, r3, #1
1004391c:	18d2      	adds	r2, r2, r3
1004391e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10043920:	685b      	ldr	r3, [r3, #4]
10043922:	0019      	movs	r1, r3
10043924:	0010      	movs	r0, r2
10043926:	f7fc fbcb 	bl	100400c0 <__udivsi3>
1004392a:	0003      	movs	r3, r0
1004392c:	633b      	str	r3, [r7, #48]	@ 0x30
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
1004392e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
10043930:	2b0f      	cmp	r3, #15
10043932:	d921      	bls.n	10043978 <UART_SetConfig+0x21c>
10043934:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
10043936:	2380      	movs	r3, #128	@ 0x80
10043938:	025b      	lsls	r3, r3, #9
1004393a:	429a      	cmp	r2, r3
1004393c:	d21c      	bcs.n	10043978 <UART_SetConfig+0x21c>
      {
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
1004393e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
10043940:	b29a      	uxth	r2, r3
10043942:	200e      	movs	r0, #14
10043944:	2420      	movs	r4, #32
10043946:	1903      	adds	r3, r0, r4
10043948:	19db      	adds	r3, r3, r7
1004394a:	210f      	movs	r1, #15
1004394c:	438a      	bics	r2, r1
1004394e:	801a      	strh	r2, [r3, #0]
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
10043950:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
10043952:	085b      	lsrs	r3, r3, #1
10043954:	b29b      	uxth	r3, r3
10043956:	2207      	movs	r2, #7
10043958:	4013      	ands	r3, r2
1004395a:	b299      	uxth	r1, r3
1004395c:	1903      	adds	r3, r0, r4
1004395e:	19db      	adds	r3, r3, r7
10043960:	1902      	adds	r2, r0, r4
10043962:	19d2      	adds	r2, r2, r7
10043964:	8812      	ldrh	r2, [r2, #0]
10043966:	430a      	orrs	r2, r1
10043968:	801a      	strh	r2, [r3, #0]
        huart->Instance->BRR = brrtemp;
1004396a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
1004396c:	681b      	ldr	r3, [r3, #0]
1004396e:	1902      	adds	r2, r0, r4
10043970:	19d2      	adds	r2, r2, r7
10043972:	8812      	ldrh	r2, [r2, #0]
10043974:	60da      	str	r2, [r3, #12]
10043976:	e036      	b.n	100439e6 <UART_SetConfig+0x28a>
      }
      else
      {
        ret = HAL_ERROR;
10043978:	231b      	movs	r3, #27
1004397a:	2220      	movs	r2, #32
1004397c:	189b      	adds	r3, r3, r2
1004397e:	19db      	adds	r3, r3, r7
10043980:	2201      	movs	r2, #1
10043982:	701a      	strb	r2, [r3, #0]
10043984:	e02f      	b.n	100439e6 <UART_SetConfig+0x28a>
      }
    }
  }
  else
  {
    pclk = UART_PERIPHCLK;
10043986:	4b28      	ldr	r3, [pc, #160]	@ (10043a28 <UART_SetConfig+0x2cc>)
10043988:	637b      	str	r3, [r7, #52]	@ 0x34

    if (pclk != 0U)
1004398a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
1004398c:	2b00      	cmp	r3, #0
1004398e:	d02a      	beq.n	100439e6 <UART_SetConfig+0x28a>
    {
      /* USARTDIV must be greater than or equal to 0d16 */
      usartdiv = (uint32_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
10043990:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10043992:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
10043994:	4b23      	ldr	r3, [pc, #140]	@ (10043a24 <UART_SetConfig+0x2c8>)
10043996:	0052      	lsls	r2, r2, #1
10043998:	5ad3      	ldrh	r3, [r2, r3]
1004399a:	0019      	movs	r1, r3
1004399c:	6b78      	ldr	r0, [r7, #52]	@ 0x34
1004399e:	f7fc fb8f 	bl	100400c0 <__udivsi3>
100439a2:	0003      	movs	r3, r0
100439a4:	001a      	movs	r2, r3
100439a6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
100439a8:	685b      	ldr	r3, [r3, #4]
100439aa:	085b      	lsrs	r3, r3, #1
100439ac:	18d2      	adds	r2, r2, r3
100439ae:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
100439b0:	685b      	ldr	r3, [r3, #4]
100439b2:	0019      	movs	r1, r3
100439b4:	0010      	movs	r0, r2
100439b6:	f7fc fb83 	bl	100400c0 <__udivsi3>
100439ba:	0003      	movs	r3, r0
100439bc:	633b      	str	r3, [r7, #48]	@ 0x30
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
100439be:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
100439c0:	2b0f      	cmp	r3, #15
100439c2:	d90a      	bls.n	100439da <UART_SetConfig+0x27e>
100439c4:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
100439c6:	2380      	movs	r3, #128	@ 0x80
100439c8:	025b      	lsls	r3, r3, #9
100439ca:	429a      	cmp	r2, r3
100439cc:	d205      	bcs.n	100439da <UART_SetConfig+0x27e>
      {
        huart->Instance->BRR = (uint16_t)usartdiv;
100439ce:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
100439d0:	b29a      	uxth	r2, r3
100439d2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
100439d4:	681b      	ldr	r3, [r3, #0]
100439d6:	60da      	str	r2, [r3, #12]
100439d8:	e005      	b.n	100439e6 <UART_SetConfig+0x28a>
      }
      else
      {
        ret = HAL_ERROR;
100439da:	231b      	movs	r3, #27
100439dc:	2220      	movs	r2, #32
100439de:	189b      	adds	r3, r3, r2
100439e0:	19db      	adds	r3, r3, r7
100439e2:	2201      	movs	r2, #1
100439e4:	701a      	strb	r2, [r3, #0]
      }
    }
  }

  /* Initialize the number of data to process during RX/TX ISR execution */
  huart->NbTxDataToProcess = 1;
100439e6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
100439e8:	226a      	movs	r2, #106	@ 0x6a
100439ea:	2101      	movs	r1, #1
100439ec:	5299      	strh	r1, [r3, r2]
  huart->NbRxDataToProcess = 1;
100439ee:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
100439f0:	2268      	movs	r2, #104	@ 0x68
100439f2:	2101      	movs	r1, #1
100439f4:	5299      	strh	r1, [r3, r2]

  /* Clear ISR function pointers */
  huart->RxISR = NULL;
100439f6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
100439f8:	2200      	movs	r2, #0
100439fa:	675a      	str	r2, [r3, #116]	@ 0x74
  huart->TxISR = NULL;
100439fc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
100439fe:	2200      	movs	r2, #0
10043a00:	679a      	str	r2, [r3, #120]	@ 0x78

  return ret;
10043a02:	231b      	movs	r3, #27
10043a04:	2220      	movs	r2, #32
10043a06:	189b      	adds	r3, r3, r2
10043a08:	19db      	adds	r3, r3, r7
10043a0a:	781b      	ldrb	r3, [r3, #0]
}
10043a0c:	0018      	movs	r0, r3
10043a0e:	46bd      	mov	sp, r7
10043a10:	b010      	add	sp, #64	@ 0x40
10043a12:	bdb0      	pop	{r4, r5, r7, pc}
10043a14:	cfff69f3 	.word	0xcfff69f3
10043a18:	ffffcfff 	.word	0xffffcfff
10043a1c:	41005000 	.word	0x41005000
10043a20:	11fff4ff 	.word	0x11fff4ff
10043a24:	10044650 	.word	0x10044650
10043a28:	00f42400 	.word	0x00f42400

10043a2c <UART_AdvFeatureConfig>:
  * @brief Configure the UART peripheral advanced features.
  * @param huart UART handle.
  * @retval None
  */
void UART_AdvFeatureConfig(UART_HandleTypeDef *huart)
{
10043a2c:	b580      	push	{r7, lr}
10043a2e:	b082      	sub	sp, #8
10043a30:	af00      	add	r7, sp, #0
10043a32:	6078      	str	r0, [r7, #4]
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure RX/TX pins swap */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
10043a34:	687b      	ldr	r3, [r7, #4]
10043a36:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
10043a38:	2208      	movs	r2, #8
10043a3a:	4013      	ands	r3, r2
10043a3c:	d00b      	beq.n	10043a56 <UART_AdvFeatureConfig+0x2a>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
10043a3e:	687b      	ldr	r3, [r7, #4]
10043a40:	681b      	ldr	r3, [r3, #0]
10043a42:	685b      	ldr	r3, [r3, #4]
10043a44:	4a4a      	ldr	r2, [pc, #296]	@ (10043b70 <UART_AdvFeatureConfig+0x144>)
10043a46:	4013      	ands	r3, r2
10043a48:	0019      	movs	r1, r3
10043a4a:	687b      	ldr	r3, [r7, #4]
10043a4c:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
10043a4e:	687b      	ldr	r3, [r7, #4]
10043a50:	681b      	ldr	r3, [r3, #0]
10043a52:	430a      	orrs	r2, r1
10043a54:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure TX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
10043a56:	687b      	ldr	r3, [r7, #4]
10043a58:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
10043a5a:	2201      	movs	r2, #1
10043a5c:	4013      	ands	r3, r2
10043a5e:	d00b      	beq.n	10043a78 <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
10043a60:	687b      	ldr	r3, [r7, #4]
10043a62:	681b      	ldr	r3, [r3, #0]
10043a64:	685b      	ldr	r3, [r3, #4]
10043a66:	4a43      	ldr	r2, [pc, #268]	@ (10043b74 <UART_AdvFeatureConfig+0x148>)
10043a68:	4013      	ands	r3, r2
10043a6a:	0019      	movs	r1, r3
10043a6c:	687b      	ldr	r3, [r7, #4]
10043a6e:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
10043a70:	687b      	ldr	r3, [r7, #4]
10043a72:	681b      	ldr	r3, [r3, #0]
10043a74:	430a      	orrs	r2, r1
10043a76:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
10043a78:	687b      	ldr	r3, [r7, #4]
10043a7a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
10043a7c:	2202      	movs	r2, #2
10043a7e:	4013      	ands	r3, r2
10043a80:	d00b      	beq.n	10043a9a <UART_AdvFeatureConfig+0x6e>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
10043a82:	687b      	ldr	r3, [r7, #4]
10043a84:	681b      	ldr	r3, [r3, #0]
10043a86:	685b      	ldr	r3, [r3, #4]
10043a88:	4a3b      	ldr	r2, [pc, #236]	@ (10043b78 <UART_AdvFeatureConfig+0x14c>)
10043a8a:	4013      	ands	r3, r2
10043a8c:	0019      	movs	r1, r3
10043a8e:	687b      	ldr	r3, [r7, #4]
10043a90:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
10043a92:	687b      	ldr	r3, [r7, #4]
10043a94:	681b      	ldr	r3, [r3, #0]
10043a96:	430a      	orrs	r2, r1
10043a98:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure data inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
10043a9a:	687b      	ldr	r3, [r7, #4]
10043a9c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
10043a9e:	2204      	movs	r2, #4
10043aa0:	4013      	ands	r3, r2
10043aa2:	d00b      	beq.n	10043abc <UART_AdvFeatureConfig+0x90>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
10043aa4:	687b      	ldr	r3, [r7, #4]
10043aa6:	681b      	ldr	r3, [r3, #0]
10043aa8:	685b      	ldr	r3, [r3, #4]
10043aaa:	4a34      	ldr	r2, [pc, #208]	@ (10043b7c <UART_AdvFeatureConfig+0x150>)
10043aac:	4013      	ands	r3, r2
10043aae:	0019      	movs	r1, r3
10043ab0:	687b      	ldr	r3, [r7, #4]
10043ab2:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
10043ab4:	687b      	ldr	r3, [r7, #4]
10043ab6:	681b      	ldr	r3, [r3, #0]
10043ab8:	430a      	orrs	r2, r1
10043aba:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
10043abc:	687b      	ldr	r3, [r7, #4]
10043abe:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
10043ac0:	2210      	movs	r2, #16
10043ac2:	4013      	ands	r3, r2
10043ac4:	d00b      	beq.n	10043ade <UART_AdvFeatureConfig+0xb2>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
10043ac6:	687b      	ldr	r3, [r7, #4]
10043ac8:	681b      	ldr	r3, [r3, #0]
10043aca:	689b      	ldr	r3, [r3, #8]
10043acc:	4a2c      	ldr	r2, [pc, #176]	@ (10043b80 <UART_AdvFeatureConfig+0x154>)
10043ace:	4013      	ands	r3, r2
10043ad0:	0019      	movs	r1, r3
10043ad2:	687b      	ldr	r3, [r7, #4]
10043ad4:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
10043ad6:	687b      	ldr	r3, [r7, #4]
10043ad8:	681b      	ldr	r3, [r3, #0]
10043ada:	430a      	orrs	r2, r1
10043adc:	609a      	str	r2, [r3, #8]
  }

#if defined(HAL_DMA_MODULE_ENABLED)
  /* if required, configure DMA disabling on reception error */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
10043ade:	687b      	ldr	r3, [r7, #4]
10043ae0:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
10043ae2:	2220      	movs	r2, #32
10043ae4:	4013      	ands	r3, r2
10043ae6:	d00b      	beq.n	10043b00 <UART_AdvFeatureConfig+0xd4>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
10043ae8:	687b      	ldr	r3, [r7, #4]
10043aea:	681b      	ldr	r3, [r3, #0]
10043aec:	689b      	ldr	r3, [r3, #8]
10043aee:	4a25      	ldr	r2, [pc, #148]	@ (10043b84 <UART_AdvFeatureConfig+0x158>)
10043af0:	4013      	ands	r3, r2
10043af2:	0019      	movs	r1, r3
10043af4:	687b      	ldr	r3, [r7, #4]
10043af6:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
10043af8:	687b      	ldr	r3, [r7, #4]
10043afa:	681b      	ldr	r3, [r3, #0]
10043afc:	430a      	orrs	r2, r1
10043afe:	609a      	str	r2, [r3, #8]
  }
#endif /* HAL_DMA_MODULE_ENABLED */

  /* if required, configure auto Baud rate detection scheme */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
10043b00:	687b      	ldr	r3, [r7, #4]
10043b02:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
10043b04:	2240      	movs	r2, #64	@ 0x40
10043b06:	4013      	ands	r3, r2
10043b08:	d01d      	beq.n	10043b46 <UART_AdvFeatureConfig+0x11a>
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
10043b0a:	687b      	ldr	r3, [r7, #4]
10043b0c:	681b      	ldr	r3, [r3, #0]
10043b0e:	685b      	ldr	r3, [r3, #4]
10043b10:	4a1d      	ldr	r2, [pc, #116]	@ (10043b88 <UART_AdvFeatureConfig+0x15c>)
10043b12:	4013      	ands	r3, r2
10043b14:	0019      	movs	r1, r3
10043b16:	687b      	ldr	r3, [r7, #4]
10043b18:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
10043b1a:	687b      	ldr	r3, [r7, #4]
10043b1c:	681b      	ldr	r3, [r3, #0]
10043b1e:	430a      	orrs	r2, r1
10043b20:	605a      	str	r2, [r3, #4]
    /* set auto Baudrate detection parameters if detection is enabled */
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
10043b22:	687b      	ldr	r3, [r7, #4]
10043b24:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
10043b26:	2380      	movs	r3, #128	@ 0x80
10043b28:	035b      	lsls	r3, r3, #13
10043b2a:	429a      	cmp	r2, r3
10043b2c:	d10b      	bne.n	10043b46 <UART_AdvFeatureConfig+0x11a>
    {
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
10043b2e:	687b      	ldr	r3, [r7, #4]
10043b30:	681b      	ldr	r3, [r3, #0]
10043b32:	685b      	ldr	r3, [r3, #4]
10043b34:	4a15      	ldr	r2, [pc, #84]	@ (10043b8c <UART_AdvFeatureConfig+0x160>)
10043b36:	4013      	ands	r3, r2
10043b38:	0019      	movs	r1, r3
10043b3a:	687b      	ldr	r3, [r7, #4]
10043b3c:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
10043b3e:	687b      	ldr	r3, [r7, #4]
10043b40:	681b      	ldr	r3, [r3, #0]
10043b42:	430a      	orrs	r2, r1
10043b44:	605a      	str	r2, [r3, #4]
    }
  }

  /* if required, configure MSB first on communication line */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
10043b46:	687b      	ldr	r3, [r7, #4]
10043b48:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
10043b4a:	2280      	movs	r2, #128	@ 0x80
10043b4c:	4013      	ands	r3, r2
10043b4e:	d00b      	beq.n	10043b68 <UART_AdvFeatureConfig+0x13c>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
10043b50:	687b      	ldr	r3, [r7, #4]
10043b52:	681b      	ldr	r3, [r3, #0]
10043b54:	685b      	ldr	r3, [r3, #4]
10043b56:	4a0e      	ldr	r2, [pc, #56]	@ (10043b90 <UART_AdvFeatureConfig+0x164>)
10043b58:	4013      	ands	r3, r2
10043b5a:	0019      	movs	r1, r3
10043b5c:	687b      	ldr	r3, [r7, #4]
10043b5e:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
10043b60:	687b      	ldr	r3, [r7, #4]
10043b62:	681b      	ldr	r3, [r3, #0]
10043b64:	430a      	orrs	r2, r1
10043b66:	605a      	str	r2, [r3, #4]
  }
}
10043b68:	46c0      	nop			@ (mov r8, r8)
10043b6a:	46bd      	mov	sp, r7
10043b6c:	b002      	add	sp, #8
10043b6e:	bd80      	pop	{r7, pc}
10043b70:	ffff7fff 	.word	0xffff7fff
10043b74:	fffdffff 	.word	0xfffdffff
10043b78:	fffeffff 	.word	0xfffeffff
10043b7c:	fffbffff 	.word	0xfffbffff
10043b80:	ffffefff 	.word	0xffffefff
10043b84:	ffffdfff 	.word	0xffffdfff
10043b88:	ffefffff 	.word	0xffefffff
10043b8c:	ff9fffff 	.word	0xff9fffff
10043b90:	fff7ffff 	.word	0xfff7ffff

10043b94 <UART_CheckIdleState>:
  * @brief Check the UART Idle State.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
{
10043b94:	b580      	push	{r7, lr}
10043b96:	b092      	sub	sp, #72	@ 0x48
10043b98:	af02      	add	r7, sp, #8
10043b9a:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Initialize the UART ErrorCode */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
10043b9c:	687b      	ldr	r3, [r7, #4]
10043b9e:	2290      	movs	r2, #144	@ 0x90
10043ba0:	2100      	movs	r1, #0
10043ba2:	5099      	str	r1, [r3, r2]

  /* Init tickstart for timeout management */
  tickstart = HAL_GetTick();
10043ba4:	f7fd ff5a 	bl	10041a5c <HAL_GetTick>
10043ba8:	0003      	movs	r3, r0
10043baa:	63fb      	str	r3, [r7, #60]	@ 0x3c

  /* Check if the Transmitter is enabled */
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
10043bac:	687b      	ldr	r3, [r7, #4]
10043bae:	681b      	ldr	r3, [r3, #0]
10043bb0:	681b      	ldr	r3, [r3, #0]
10043bb2:	2208      	movs	r2, #8
10043bb4:	4013      	ands	r3, r2
10043bb6:	2b08      	cmp	r3, #8
10043bb8:	d12d      	bne.n	10043c16 <UART_CheckIdleState+0x82>
  {
    /* Wait until TEACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
10043bba:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
10043bbc:	2280      	movs	r2, #128	@ 0x80
10043bbe:	0391      	lsls	r1, r2, #14
10043bc0:	6878      	ldr	r0, [r7, #4]
10043bc2:	4a47      	ldr	r2, [pc, #284]	@ (10043ce0 <UART_CheckIdleState+0x14c>)
10043bc4:	9200      	str	r2, [sp, #0]
10043bc6:	2200      	movs	r2, #0
10043bc8:	f000 f88e 	bl	10043ce8 <UART_WaitOnFlagUntilTimeout>
10043bcc:	1e03      	subs	r3, r0, #0
10043bce:	d022      	beq.n	10043c16 <UART_CheckIdleState+0x82>
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
10043bd0:	f3ef 8310 	mrs	r3, PRIMASK
10043bd4:	627b      	str	r3, [r7, #36]	@ 0x24
  return(result);
10043bd6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
    {
      /* Disable TXE interrupt for the interrupt process */
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE_TXFNFIE));
10043bd8:	63bb      	str	r3, [r7, #56]	@ 0x38
10043bda:	2301      	movs	r3, #1
10043bdc:	62bb      	str	r3, [r7, #40]	@ 0x28
  \details Assigns the given value to the Priority Mask Register.
  \param [in]    priMask  Priority Mask
 */
__STATIC_FORCEINLINE void __set_PRIMASK(uint32_t priMask)
{
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
10043bde:	6abb      	ldr	r3, [r7, #40]	@ 0x28
10043be0:	f383 8810 	msr	PRIMASK, r3
}
10043be4:	46c0      	nop			@ (mov r8, r8)
10043be6:	687b      	ldr	r3, [r7, #4]
10043be8:	681b      	ldr	r3, [r3, #0]
10043bea:	681a      	ldr	r2, [r3, #0]
10043bec:	687b      	ldr	r3, [r7, #4]
10043bee:	681b      	ldr	r3, [r3, #0]
10043bf0:	2180      	movs	r1, #128	@ 0x80
10043bf2:	438a      	bics	r2, r1
10043bf4:	601a      	str	r2, [r3, #0]
10043bf6:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
10043bf8:	62fb      	str	r3, [r7, #44]	@ 0x2c
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
10043bfa:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
10043bfc:	f383 8810 	msr	PRIMASK, r3
}
10043c00:	46c0      	nop			@ (mov r8, r8)

      huart->gState = HAL_UART_STATE_READY;
10043c02:	687b      	ldr	r3, [r7, #4]
10043c04:	2288      	movs	r2, #136	@ 0x88
10043c06:	2120      	movs	r1, #32
10043c08:	5099      	str	r1, [r3, r2]

      __HAL_UNLOCK(huart);
10043c0a:	687b      	ldr	r3, [r7, #4]
10043c0c:	2284      	movs	r2, #132	@ 0x84
10043c0e:	2100      	movs	r1, #0
10043c10:	5499      	strb	r1, [r3, r2]

      /* Timeout occurred */
      return HAL_TIMEOUT;
10043c12:	2303      	movs	r3, #3
10043c14:	e060      	b.n	10043cd8 <UART_CheckIdleState+0x144>
    }
  }

  /* Check if the Receiver is enabled */
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
10043c16:	687b      	ldr	r3, [r7, #4]
10043c18:	681b      	ldr	r3, [r3, #0]
10043c1a:	681b      	ldr	r3, [r3, #0]
10043c1c:	2204      	movs	r2, #4
10043c1e:	4013      	ands	r3, r2
10043c20:	2b04      	cmp	r3, #4
10043c22:	d146      	bne.n	10043cb2 <UART_CheckIdleState+0x11e>
  {
    /* Wait until REACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
10043c24:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
10043c26:	2280      	movs	r2, #128	@ 0x80
10043c28:	03d1      	lsls	r1, r2, #15
10043c2a:	6878      	ldr	r0, [r7, #4]
10043c2c:	4a2c      	ldr	r2, [pc, #176]	@ (10043ce0 <UART_CheckIdleState+0x14c>)
10043c2e:	9200      	str	r2, [sp, #0]
10043c30:	2200      	movs	r2, #0
10043c32:	f000 f859 	bl	10043ce8 <UART_WaitOnFlagUntilTimeout>
10043c36:	1e03      	subs	r3, r0, #0
10043c38:	d03b      	beq.n	10043cb2 <UART_CheckIdleState+0x11e>
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
10043c3a:	f3ef 8310 	mrs	r3, PRIMASK
10043c3e:	60fb      	str	r3, [r7, #12]
  return(result);
10043c40:	68fb      	ldr	r3, [r7, #12]
    {
      /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error)
      interrupts for the interrupt process */
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
10043c42:	637b      	str	r3, [r7, #52]	@ 0x34
10043c44:	2301      	movs	r3, #1
10043c46:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
10043c48:	693b      	ldr	r3, [r7, #16]
10043c4a:	f383 8810 	msr	PRIMASK, r3
}
10043c4e:	46c0      	nop			@ (mov r8, r8)
10043c50:	687b      	ldr	r3, [r7, #4]
10043c52:	681b      	ldr	r3, [r3, #0]
10043c54:	681a      	ldr	r2, [r3, #0]
10043c56:	687b      	ldr	r3, [r7, #4]
10043c58:	681b      	ldr	r3, [r3, #0]
10043c5a:	4922      	ldr	r1, [pc, #136]	@ (10043ce4 <UART_CheckIdleState+0x150>)
10043c5c:	400a      	ands	r2, r1
10043c5e:	601a      	str	r2, [r3, #0]
10043c60:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
10043c62:	617b      	str	r3, [r7, #20]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
10043c64:	697b      	ldr	r3, [r7, #20]
10043c66:	f383 8810 	msr	PRIMASK, r3
}
10043c6a:	46c0      	nop			@ (mov r8, r8)
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
10043c6c:	f3ef 8310 	mrs	r3, PRIMASK
10043c70:	61bb      	str	r3, [r7, #24]
  return(result);
10043c72:	69bb      	ldr	r3, [r7, #24]
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
10043c74:	633b      	str	r3, [r7, #48]	@ 0x30
10043c76:	2301      	movs	r3, #1
10043c78:	61fb      	str	r3, [r7, #28]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
10043c7a:	69fb      	ldr	r3, [r7, #28]
10043c7c:	f383 8810 	msr	PRIMASK, r3
}
10043c80:	46c0      	nop			@ (mov r8, r8)
10043c82:	687b      	ldr	r3, [r7, #4]
10043c84:	681b      	ldr	r3, [r3, #0]
10043c86:	689a      	ldr	r2, [r3, #8]
10043c88:	687b      	ldr	r3, [r7, #4]
10043c8a:	681b      	ldr	r3, [r3, #0]
10043c8c:	2101      	movs	r1, #1
10043c8e:	438a      	bics	r2, r1
10043c90:	609a      	str	r2, [r3, #8]
10043c92:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
10043c94:	623b      	str	r3, [r7, #32]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
10043c96:	6a3b      	ldr	r3, [r7, #32]
10043c98:	f383 8810 	msr	PRIMASK, r3
}
10043c9c:	46c0      	nop			@ (mov r8, r8)

      huart->RxState = HAL_UART_STATE_READY;
10043c9e:	687b      	ldr	r3, [r7, #4]
10043ca0:	228c      	movs	r2, #140	@ 0x8c
10043ca2:	2120      	movs	r1, #32
10043ca4:	5099      	str	r1, [r3, r2]

      __HAL_UNLOCK(huart);
10043ca6:	687b      	ldr	r3, [r7, #4]
10043ca8:	2284      	movs	r2, #132	@ 0x84
10043caa:	2100      	movs	r1, #0
10043cac:	5499      	strb	r1, [r3, r2]

      /* Timeout occurred */
      return HAL_TIMEOUT;
10043cae:	2303      	movs	r3, #3
10043cb0:	e012      	b.n	10043cd8 <UART_CheckIdleState+0x144>
    }
  }

  /* Initialize the UART State */
  huart->gState = HAL_UART_STATE_READY;
10043cb2:	687b      	ldr	r3, [r7, #4]
10043cb4:	2288      	movs	r2, #136	@ 0x88
10043cb6:	2120      	movs	r1, #32
10043cb8:	5099      	str	r1, [r3, r2]
  huart->RxState = HAL_UART_STATE_READY;
10043cba:	687b      	ldr	r3, [r7, #4]
10043cbc:	228c      	movs	r2, #140	@ 0x8c
10043cbe:	2120      	movs	r1, #32
10043cc0:	5099      	str	r1, [r3, r2]
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
10043cc2:	687b      	ldr	r3, [r7, #4]
10043cc4:	2200      	movs	r2, #0
10043cc6:	66da      	str	r2, [r3, #108]	@ 0x6c
  huart->RxEventType = HAL_UART_RXEVENT_TC;
10043cc8:	687b      	ldr	r3, [r7, #4]
10043cca:	2200      	movs	r2, #0
10043ccc:	671a      	str	r2, [r3, #112]	@ 0x70

  __HAL_UNLOCK(huart);
10043cce:	687b      	ldr	r3, [r7, #4]
10043cd0:	2284      	movs	r2, #132	@ 0x84
10043cd2:	2100      	movs	r1, #0
10043cd4:	5499      	strb	r1, [r3, r2]

  return HAL_OK;
10043cd6:	2300      	movs	r3, #0
}
10043cd8:	0018      	movs	r0, r3
10043cda:	46bd      	mov	sp, r7
10043cdc:	b010      	add	sp, #64	@ 0x40
10043cde:	bd80      	pop	{r7, pc}
10043ce0:	01ffffff 	.word	0x01ffffff
10043ce4:	fffffedf 	.word	0xfffffedf

10043ce8 <UART_WaitOnFlagUntilTimeout>:
  * @param Timeout   Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status,
                                              uint32_t Tickstart, uint32_t Timeout)
{
10043ce8:	b580      	push	{r7, lr}
10043cea:	b084      	sub	sp, #16
10043cec:	af00      	add	r7, sp, #0
10043cee:	60f8      	str	r0, [r7, #12]
10043cf0:	60b9      	str	r1, [r7, #8]
10043cf2:	603b      	str	r3, [r7, #0]
10043cf4:	1dfb      	adds	r3, r7, #7
10043cf6:	701a      	strb	r2, [r3, #0]
  /* Wait until flag is set */
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
10043cf8:	e051      	b.n	10043d9e <UART_WaitOnFlagUntilTimeout+0xb6>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
10043cfa:	69bb      	ldr	r3, [r7, #24]
10043cfc:	3301      	adds	r3, #1
10043cfe:	d04e      	beq.n	10043d9e <UART_WaitOnFlagUntilTimeout+0xb6>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
10043d00:	f7fd feac 	bl	10041a5c <HAL_GetTick>
10043d04:	0002      	movs	r2, r0
10043d06:	683b      	ldr	r3, [r7, #0]
10043d08:	1ad3      	subs	r3, r2, r3
10043d0a:	69ba      	ldr	r2, [r7, #24]
10043d0c:	429a      	cmp	r2, r3
10043d0e:	d302      	bcc.n	10043d16 <UART_WaitOnFlagUntilTimeout+0x2e>
10043d10:	69bb      	ldr	r3, [r7, #24]
10043d12:	2b00      	cmp	r3, #0
10043d14:	d101      	bne.n	10043d1a <UART_WaitOnFlagUntilTimeout+0x32>
      {

        return HAL_TIMEOUT;
10043d16:	2303      	movs	r3, #3
10043d18:	e051      	b.n	10043dbe <UART_WaitOnFlagUntilTimeout+0xd6>
      }

      if ((READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U) && (Flag != UART_FLAG_TXE) && (Flag != UART_FLAG_TC))
10043d1a:	68fb      	ldr	r3, [r7, #12]
10043d1c:	681b      	ldr	r3, [r3, #0]
10043d1e:	681b      	ldr	r3, [r3, #0]
10043d20:	2204      	movs	r2, #4
10043d22:	4013      	ands	r3, r2
10043d24:	d03b      	beq.n	10043d9e <UART_WaitOnFlagUntilTimeout+0xb6>
10043d26:	68bb      	ldr	r3, [r7, #8]
10043d28:	2b80      	cmp	r3, #128	@ 0x80
10043d2a:	d038      	beq.n	10043d9e <UART_WaitOnFlagUntilTimeout+0xb6>
10043d2c:	68bb      	ldr	r3, [r7, #8]
10043d2e:	2b40      	cmp	r3, #64	@ 0x40
10043d30:	d035      	beq.n	10043d9e <UART_WaitOnFlagUntilTimeout+0xb6>
      {
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_ORE) == SET)
10043d32:	68fb      	ldr	r3, [r7, #12]
10043d34:	681b      	ldr	r3, [r3, #0]
10043d36:	69db      	ldr	r3, [r3, #28]
10043d38:	2208      	movs	r2, #8
10043d3a:	4013      	ands	r3, r2
10043d3c:	2b08      	cmp	r3, #8
10043d3e:	d111      	bne.n	10043d64 <UART_WaitOnFlagUntilTimeout+0x7c>
        {
          /* Clear Overrun Error flag*/
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
10043d40:	68fb      	ldr	r3, [r7, #12]
10043d42:	681b      	ldr	r3, [r3, #0]
10043d44:	2208      	movs	r2, #8
10043d46:	621a      	str	r2, [r3, #32]

          /* Blocking error : transfer is aborted
          Set the UART state ready to be able to start again the process,
          Disable Rx Interrupts if ongoing */
          UART_EndRxTransfer(huart);
10043d48:	68fb      	ldr	r3, [r7, #12]
10043d4a:	0018      	movs	r0, r3
10043d4c:	f000 f83c 	bl	10043dc8 <UART_EndRxTransfer>

          huart->ErrorCode = HAL_UART_ERROR_ORE;
10043d50:	68fb      	ldr	r3, [r7, #12]
10043d52:	2290      	movs	r2, #144	@ 0x90
10043d54:	2108      	movs	r1, #8
10043d56:	5099      	str	r1, [r3, r2]

          /* Process Unlocked */
          __HAL_UNLOCK(huart);
10043d58:	68fb      	ldr	r3, [r7, #12]
10043d5a:	2284      	movs	r2, #132	@ 0x84
10043d5c:	2100      	movs	r1, #0
10043d5e:	5499      	strb	r1, [r3, r2]

          return HAL_ERROR;
10043d60:	2301      	movs	r3, #1
10043d62:	e02c      	b.n	10043dbe <UART_WaitOnFlagUntilTimeout+0xd6>
        }
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
10043d64:	68fb      	ldr	r3, [r7, #12]
10043d66:	681b      	ldr	r3, [r3, #0]
10043d68:	69da      	ldr	r2, [r3, #28]
10043d6a:	2380      	movs	r3, #128	@ 0x80
10043d6c:	011b      	lsls	r3, r3, #4
10043d6e:	401a      	ands	r2, r3
10043d70:	2380      	movs	r3, #128	@ 0x80
10043d72:	011b      	lsls	r3, r3, #4
10043d74:	429a      	cmp	r2, r3
10043d76:	d112      	bne.n	10043d9e <UART_WaitOnFlagUntilTimeout+0xb6>
        {
          /* Clear Receiver Timeout flag*/
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
10043d78:	68fb      	ldr	r3, [r7, #12]
10043d7a:	681b      	ldr	r3, [r3, #0]
10043d7c:	2280      	movs	r2, #128	@ 0x80
10043d7e:	0112      	lsls	r2, r2, #4
10043d80:	621a      	str	r2, [r3, #32]

          /* Blocking error : transfer is aborted
          Set the UART state ready to be able to start again the process,
          Disable Rx Interrupts if ongoing */
          UART_EndRxTransfer(huart);
10043d82:	68fb      	ldr	r3, [r7, #12]
10043d84:	0018      	movs	r0, r3
10043d86:	f000 f81f 	bl	10043dc8 <UART_EndRxTransfer>

          huart->ErrorCode = HAL_UART_ERROR_RTO;
10043d8a:	68fb      	ldr	r3, [r7, #12]
10043d8c:	2290      	movs	r2, #144	@ 0x90
10043d8e:	2120      	movs	r1, #32
10043d90:	5099      	str	r1, [r3, r2]

          /* Process Unlocked */
          __HAL_UNLOCK(huart);
10043d92:	68fb      	ldr	r3, [r7, #12]
10043d94:	2284      	movs	r2, #132	@ 0x84
10043d96:	2100      	movs	r1, #0
10043d98:	5499      	strb	r1, [r3, r2]

          return HAL_TIMEOUT;
10043d9a:	2303      	movs	r3, #3
10043d9c:	e00f      	b.n	10043dbe <UART_WaitOnFlagUntilTimeout+0xd6>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
10043d9e:	68fb      	ldr	r3, [r7, #12]
10043da0:	681b      	ldr	r3, [r3, #0]
10043da2:	69db      	ldr	r3, [r3, #28]
10043da4:	68ba      	ldr	r2, [r7, #8]
10043da6:	4013      	ands	r3, r2
10043da8:	68ba      	ldr	r2, [r7, #8]
10043daa:	1ad3      	subs	r3, r2, r3
10043dac:	425a      	negs	r2, r3
10043dae:	4153      	adcs	r3, r2
10043db0:	b2db      	uxtb	r3, r3
10043db2:	001a      	movs	r2, r3
10043db4:	1dfb      	adds	r3, r7, #7
10043db6:	781b      	ldrb	r3, [r3, #0]
10043db8:	429a      	cmp	r2, r3
10043dba:	d09e      	beq.n	10043cfa <UART_WaitOnFlagUntilTimeout+0x12>
        }
      }
    }
  }
  return HAL_OK;
10043dbc:	2300      	movs	r3, #0
}
10043dbe:	0018      	movs	r0, r3
10043dc0:	46bd      	mov	sp, r7
10043dc2:	b004      	add	sp, #16
10043dc4:	bd80      	pop	{r7, pc}
	...

10043dc8 <UART_EndRxTransfer>:
  * @brief  End ongoing Rx transfer on UART peripheral (following error detection or Reception completion).
  * @param  huart UART handle.
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
10043dc8:	b580      	push	{r7, lr}
10043dca:	b08e      	sub	sp, #56	@ 0x38
10043dcc:	af00      	add	r7, sp, #0
10043dce:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
10043dd0:	f3ef 8310 	mrs	r3, PRIMASK
10043dd4:	617b      	str	r3, [r7, #20]
  return(result);
10043dd6:	697b      	ldr	r3, [r7, #20]
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
10043dd8:	637b      	str	r3, [r7, #52]	@ 0x34
10043dda:	2301      	movs	r3, #1
10043ddc:	61bb      	str	r3, [r7, #24]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
10043dde:	69bb      	ldr	r3, [r7, #24]
10043de0:	f383 8810 	msr	PRIMASK, r3
}
10043de4:	46c0      	nop			@ (mov r8, r8)
10043de6:	687b      	ldr	r3, [r7, #4]
10043de8:	681b      	ldr	r3, [r3, #0]
10043dea:	681a      	ldr	r2, [r3, #0]
10043dec:	687b      	ldr	r3, [r7, #4]
10043dee:	681b      	ldr	r3, [r3, #0]
10043df0:	4926      	ldr	r1, [pc, #152]	@ (10043e8c <UART_EndRxTransfer+0xc4>)
10043df2:	400a      	ands	r2, r1
10043df4:	601a      	str	r2, [r3, #0]
10043df6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
10043df8:	61fb      	str	r3, [r7, #28]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
10043dfa:	69fb      	ldr	r3, [r7, #28]
10043dfc:	f383 8810 	msr	PRIMASK, r3
}
10043e00:	46c0      	nop			@ (mov r8, r8)
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
10043e02:	f3ef 8310 	mrs	r3, PRIMASK
10043e06:	623b      	str	r3, [r7, #32]
  return(result);
10043e08:	6a3b      	ldr	r3, [r7, #32]
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
10043e0a:	633b      	str	r3, [r7, #48]	@ 0x30
10043e0c:	2301      	movs	r3, #1
10043e0e:	627b      	str	r3, [r7, #36]	@ 0x24
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
10043e10:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10043e12:	f383 8810 	msr	PRIMASK, r3
}
10043e16:	46c0      	nop			@ (mov r8, r8)
10043e18:	687b      	ldr	r3, [r7, #4]
10043e1a:	681b      	ldr	r3, [r3, #0]
10043e1c:	689a      	ldr	r2, [r3, #8]
10043e1e:	687b      	ldr	r3, [r7, #4]
10043e20:	681b      	ldr	r3, [r3, #0]
10043e22:	491b      	ldr	r1, [pc, #108]	@ (10043e90 <UART_EndRxTransfer+0xc8>)
10043e24:	400a      	ands	r2, r1
10043e26:	609a      	str	r2, [r3, #8]
10043e28:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
10043e2a:	62bb      	str	r3, [r7, #40]	@ 0x28
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
10043e2c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
10043e2e:	f383 8810 	msr	PRIMASK, r3
}
10043e32:	46c0      	nop			@ (mov r8, r8)

  /* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
10043e34:	687b      	ldr	r3, [r7, #4]
10043e36:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
10043e38:	2b01      	cmp	r3, #1
10043e3a:	d118      	bne.n	10043e6e <UART_EndRxTransfer+0xa6>
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
10043e3c:	f3ef 8310 	mrs	r3, PRIMASK
10043e40:	60bb      	str	r3, [r7, #8]
  return(result);
10043e42:	68bb      	ldr	r3, [r7, #8]
  {
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
10043e44:	62fb      	str	r3, [r7, #44]	@ 0x2c
10043e46:	2301      	movs	r3, #1
10043e48:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
10043e4a:	68fb      	ldr	r3, [r7, #12]
10043e4c:	f383 8810 	msr	PRIMASK, r3
}
10043e50:	46c0      	nop			@ (mov r8, r8)
10043e52:	687b      	ldr	r3, [r7, #4]
10043e54:	681b      	ldr	r3, [r3, #0]
10043e56:	681a      	ldr	r2, [r3, #0]
10043e58:	687b      	ldr	r3, [r7, #4]
10043e5a:	681b      	ldr	r3, [r3, #0]
10043e5c:	2110      	movs	r1, #16
10043e5e:	438a      	bics	r2, r1
10043e60:	601a      	str	r2, [r3, #0]
10043e62:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
10043e64:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
10043e66:	693b      	ldr	r3, [r7, #16]
10043e68:	f383 8810 	msr	PRIMASK, r3
}
10043e6c:	46c0      	nop			@ (mov r8, r8)
  }

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
10043e6e:	687b      	ldr	r3, [r7, #4]
10043e70:	228c      	movs	r2, #140	@ 0x8c
10043e72:	2120      	movs	r1, #32
10043e74:	5099      	str	r1, [r3, r2]
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
10043e76:	687b      	ldr	r3, [r7, #4]
10043e78:	2200      	movs	r2, #0
10043e7a:	66da      	str	r2, [r3, #108]	@ 0x6c

  /* Reset RxIsr function pointer */
  huart->RxISR = NULL;
10043e7c:	687b      	ldr	r3, [r7, #4]
10043e7e:	2200      	movs	r2, #0
10043e80:	675a      	str	r2, [r3, #116]	@ 0x74
}
10043e82:	46c0      	nop			@ (mov r8, r8)
10043e84:	46bd      	mov	sp, r7
10043e86:	b00e      	add	sp, #56	@ 0x38
10043e88:	bd80      	pop	{r7, pc}
10043e8a:	46c0      	nop			@ (mov r8, r8)
10043e8c:	fffffedf 	.word	0xfffffedf
10043e90:	effffffe 	.word	0xeffffffe

10043e94 <memset>:
10043e94:	0003      	movs	r3, r0
10043e96:	1882      	adds	r2, r0, r2
10043e98:	4293      	cmp	r3, r2
10043e9a:	d100      	bne.n	10043e9e <memset+0xa>
10043e9c:	4770      	bx	lr
10043e9e:	7019      	strb	r1, [r3, #0]
10043ea0:	3301      	adds	r3, #1
10043ea2:	e7f9      	b.n	10043e98 <memset+0x4>
10043ea4:	2d190c05 	.word	0x2d190c05
10043ea8:	645a4b3c 	.word	0x645a4b3c
10043eac:	23324150 	.word	0x23324150
10043eb0:	08050a14 	.word	0x08050a14
10043eb4:	46321e0f 	.word	0x46321e0f
10043eb8:	28465f55 	.word	0x28465f55
10043ebc:	0f14191e 	.word	0x0f14191e
10043ec0:	0003050a 	.word	0x0003050a
10043ec4:	71657246 	.word	0x71657246
10043ec8:	636e6575 	.word	0x636e6575
10043ecc:	38203a79 	.word	0x38203a79
10043ed0:	484d3836 	.word	0x484d3836
10043ed4:	0000007a 	.word	0x0000007a

10043ed8 <Font7x10>:
	...
10043eec:	10001000 10001000 10001000 10000000     ................
10043efc:	00000000 28002800 00002800 00000000     .....(.(.(......
	...
10043f14:	24002400 24007c00 7c004800 48004800     .$.$.|.$.H.|.H.H
10043f24:	00000000 54003800 38005000 54001400     .....8.T.P.8...T
10043f34:	38005400 00001000 54002000 30005800     .T.8..... .T.X.0
10043f44:	54002800 08001400 00000000 28001000     .(.T...........(
10043f54:	10002800 48003400 34004800 00000000     .(...4.H.H.4....
10043f64:	10001000 00001000 00000000 00000000     ................
10043f74:	00000000 10000800 20002000 20002000     ......... . . . 
10043f84:	20002000 08001000 10002000 08000800     . . ..... ......
10043f94:	08000800 08000800 20001000 38001000     ........... ...8
10043fa4:	28001000 00000000 00000000 00000000     ...(............
10043fb4:	00000000 10001000 10007c00 00001000     .........|......
	...
10043fd4:	10000000 10001000 00000000 00000000     ................
10043fe4:	38000000 00000000 00000000 00000000     ...8............
	...
10043ffc:	10000000 00000000 08000800 10001000     ................
1004400c:	10001000 20002000 00000000 44003800     ..... . .....8.D
1004401c:	54004400 44004400 38004400 00000000     .D.T.D.D.D.8....
1004402c:	30001000 10005000 10001000 10001000     ...0.P..........
1004403c:	00000000 44003800 04004400 10000800     .....8.D.D......
1004404c:	7c002000 00000000 44003800 18000400     . .|.....8.D....
1004405c:	04000400 38004400 00000000 18000800     .....D.8........
1004406c:	28002800 7c004800 08000800 00000000     .(.(.H.|........
1004407c:	40007c00 78004000 04000400 38004400     .|.@.@.x.....D.8
1004408c:	00000000 44003800 78004000 44004400     .....8.D.@.x.D.D
1004409c:	38004400 00000000 04007c00 10000800     .D.8.....|......
100440ac:	20001000 20002000 00000000 44003800     ... . . .....8.D
100440bc:	38004400 44004400 38004400 00000000     .D.8.D.D.D.8....
100440cc:	44003800 44004400 04003c00 38004400     .8.D.D.D.<...D.8
	...
100440e4:	00001000 00000000 10000000 00000000     ................
100440f4:	00000000 10000000 00000000 10000000     ................
10044104:	10001000 00000000 30000c00 30004000     ...........0.@.0
10044114:	00000c00 00000000 00000000 7c000000     ...............|
10044124:	7c000000 00000000 00000000 00000000     ...|............
10044134:	18006000 18000400 00006000 00000000     .`.......`......
10044144:	44003800 08000400 10001000 10000000     .8.D............
10044154:	00000000 44003800 54004c00 40005c00     .....8.D.L.T.\.@
10044164:	38004000 00000000 28001000 28002800     .@.8.......(.(.(
10044174:	7c002800 44004400 00000000 44007800     .(.|.D.D.....x.D
10044184:	78004400 44004400 78004400 00000000     .D.x.D.D.D.x....
10044194:	44003800 40004000 40004000 38004400     .8.D.@.@.@.@.D.8
100441a4:	00000000 48007000 44004400 44004400     .....p.H.D.D.D.D
100441b4:	70004800 00000000 40007c00 7c004000     .H.p.....|.@.@.|
100441c4:	40004000 7c004000 00000000 40007c00     .@.@.@.|.....|.@
100441d4:	78004000 40004000 40004000 00000000     .@.x.@.@.@.@....
100441e4:	44003800 40004000 44005c00 38004400     .8.D.@.@.\.D.D.8
100441f4:	00000000 44004400 7c004400 44004400     .....D.D.D.|.D.D
10044204:	44004400 00000000 10003800 10001000     .D.D.....8......
10044214:	10001000 38001000 00000000 04000400     .......8........
10044224:	04000400 04000400 38004400 00000000     .........D.8....
10044234:	48004400 60005000 48005000 44004800     .D.H.P.`.P.H.H.D
10044244:	00000000 40004000 40004000 40004000     .....@.@.@.@.@.@
10044254:	7c004000 00000000 6c004400 54006c00     .@.|.....D.l.l.T
10044264:	44004400 44004400 00000000 64004400     .D.D.D.D.....D.d
10044274:	54006400 4c005400 44004c00 00000000     .d.T.T.L.L.D....
10044284:	44003800 44004400 44004400 38004400     .8.D.D.D.D.D.D.8
10044294:	00000000 44007800 44004400 40007800     .....x.D.D.D.x.@
100442a4:	40004000 00000000 44003800 44004400     .@.@.....8.D.D.D
100442b4:	44004400 38005400 00000400 44007800     .D.D.T.8.....x.D
100442c4:	44004400 48007800 44004800 00000000     .D.D.x.H.H.D....
100442d4:	44003800 30004000 04000800 38004400     .8.D.@.0.....D.8
100442e4:	00000000 10007c00 10001000 10001000     .....|..........
100442f4:	10001000 00000000 44004400 44004400     .........D.D.D.D
10044304:	44004400 38004400 00000000 44004400     .D.D.D.8.....D.D
10044314:	28004400 28002800 10001000 00000000     .D.(.(.(........
10044324:	44004400 54005400 6c005400 28002800     .D.D.T.T.T.l.(.(
10044334:	00000000 28004400 10002800 28001000     .....D.(.(.....(
10044344:	44002800 00000000 44004400 28002800     .(.D.....D.D.(.(
10044354:	10001000 10001000 00000000 04007c00     .............|..
10044364:	10000800 20001000 7c004000 00000000     ....... .@.|....
10044374:	10001800 10001000 10001000 10001000     ................
10044384:	18001000 20002000 10001000 10001000     ..... . ........
10044394:	08000800 00000000 10003000 10001000     .........0......
100443a4:	10001000 10001000 30001000 28001000     ...........0...(
100443b4:	44002800 00000000 00000000 00000000     .(.D............
	...
100443d4:	fe000000 10002000 00000000 00000000     ..... ..........
	...
100443f0:	44003800 44003c00 34004c00 00000000     .8.D.<.D.L.4....
10044400:	40004000 64005800 44004400 58006400     .@.@.X.d.D.D.d.X
	...
10044418:	44003800 40004000 38004400 00000000     .8.D.@.@.D.8....
10044428:	04000400 4c003400 44004400 34004c00     .....4.L.D.D.L.4
	...
10044440:	44003800 40007c00 38004400 00000000     .8.D.|.@.D.8....
10044450:	10000c00 10007c00 10001000 10001000     .....|..........
	...
10044468:	4c003400 44004400 34004c00 78000400     .4.L.D.D.L.4...x
10044478:	40004000 64005800 44004400 44004400     .@.@.X.d.D.D.D.D
10044488:	00000000 00001000 10007000 10001000     .........p......
10044498:	10001000 00000000 00001000 10007000     .............p..
100444a8:	10001000 10001000 e0001000 40004000     .............@.@
100444b8:	50004800 50006000 44004800 00000000     .H.P.`.P.H.D....
100444c8:	10007000 10001000 10001000 10001000     .p..............
	...
100444e0:	54007800 54005400 54005400 00000000     .x.T.T.T.T.T....
100444f0:	00000000 64005800 44004400 44004400     .....X.d.D.D.D.D
	...
10044508:	44003800 44004400 38004400 00000000     .8.D.D.D.D.8....
10044518:	00000000 64005800 44004400 58006400     .....X.d.D.D.d.X
10044528:	40004000 00000000 4c003400 44004400     .@.@.....4.L.D.D
10044538:	34004c00 04000400 00000000 64005800     .L.4.........X.d
10044548:	40004000 40004000 00000000 00000000     .@.@.@.@........
10044558:	44003800 08003000 38004400 00000000     .8.D.0...D.8....
10044568:	20002000 20007800 20002000 18002000     . . .x. . . . ..
	...
10044580:	44004400 44004400 34004c00 00000000     .D.D.D.D.L.4....
10044590:	00000000 44004400 28002800 10002800     .....D.D.(.(.(..
	...
100445a8:	54005400 6c005400 28002800 00000000     .T.T.T.l.(.(....
100445b8:	00000000 28004400 10001000 44002800     .....D.(.....(.D
	...
100445d0:	44004400 28002800 10001000 60001000     .D.D.(.(.......`
100445e0:	00000000 08007c00 20001000 7c004000     .....|..... .@.|
100445f0:	00000000 10001800 10001000 20002000     ............. . 
10044600:	10001000 18001000 10001000 10001000     ................
10044610:	10001000 10001000 10001000 10003000     .............0..
10044620:	10001000 08000800 10001000 30001000     ...............0
10044630:	00000000 74000000 00004c00 00000000     .......t.L......
10044640:	00000000                                ....

10044644 <Font_7x10>:
10044644:	00000a07 10043ed8 00000000              .....>......

10044650 <UARTPrescTable>:
10044650:	00020001 00060004 000a0008 0010000c     ................
10044660:	00400020 01000080                        .@.....

Disassembly of section .init:

10044668 <_init>:
10044668:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
1004466a:	46c0      	nop			@ (mov r8, r8)

Disassembly of section .fini:

1004466c <_fini>:
1004466c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
1004466e:	46c0      	nop			@ (mov r8, r8)
